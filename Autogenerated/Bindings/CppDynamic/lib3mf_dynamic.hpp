/*++

Copyright (C) 2019 3MF Consortium (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of the 3MF Library

Interface version: 2.3.0

*/

#ifndef __LIB3MF_CPPHEADER_DYNAMIC_CPP
#define __LIB3MF_CPPHEADER_DYNAMIC_CPP

#include "lib3mf_types.hpp"
#include "lib3mf_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <array>
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace Lib3MF {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CBinaryStream;
class CWriter;
class CPersistentReaderSource;
class CReader;
class CPackagePart;
class CResource;
class CResourceIterator;
class CCustomXMLAttribute;
class CCustomXMLNode;
class CCustomXMLNodes;
class CCustomDOMTree;
class CSliceStackIterator;
class CObjectIterator;
class CMeshObjectIterator;
class CComponentsObjectIterator;
class CTexture2DIterator;
class CBaseMaterialGroupIterator;
class CColorGroupIterator;
class CTexture2DGroupIterator;
class CCompositeMaterialsIterator;
class CMultiPropertyGroupIterator;
class CMetaData;
class CMetaDataGroup;
class CObject;
class CMeshObject;
class CBeamLattice;
class CComponent;
class CComponentsObject;
class CBeamSet;
class CBaseMaterialGroup;
class CColorGroup;
class CTexture2DGroup;
class CCompositeMaterials;
class CMultiPropertyGroup;
class CAttachment;
class CTexture2D;
class CBuildItem;
class CBuildItemIterator;
class CSlice;
class CToolpathProfile;
class CToolpathLayerReader;
class CToolpathLayerData;
class CToolpath;
class CToolpathIterator;
class CSliceStack;
class CConsumer;
class CAccessRight;
class CContentEncryptionParams;
class CResourceData;
class CResourceDataGroup;
class CKeyStore;
class CModel;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLib3MFWrapper;
typedef CBase CLib3MFBase;
typedef CBinaryStream CLib3MFBinaryStream;
typedef CWriter CLib3MFWriter;
typedef CPersistentReaderSource CLib3MFPersistentReaderSource;
typedef CReader CLib3MFReader;
typedef CPackagePart CLib3MFPackagePart;
typedef CResource CLib3MFResource;
typedef CResourceIterator CLib3MFResourceIterator;
typedef CCustomXMLAttribute CLib3MFCustomXMLAttribute;
typedef CCustomXMLNode CLib3MFCustomXMLNode;
typedef CCustomXMLNodes CLib3MFCustomXMLNodes;
typedef CCustomDOMTree CLib3MFCustomDOMTree;
typedef CSliceStackIterator CLib3MFSliceStackIterator;
typedef CObjectIterator CLib3MFObjectIterator;
typedef CMeshObjectIterator CLib3MFMeshObjectIterator;
typedef CComponentsObjectIterator CLib3MFComponentsObjectIterator;
typedef CTexture2DIterator CLib3MFTexture2DIterator;
typedef CBaseMaterialGroupIterator CLib3MFBaseMaterialGroupIterator;
typedef CColorGroupIterator CLib3MFColorGroupIterator;
typedef CTexture2DGroupIterator CLib3MFTexture2DGroupIterator;
typedef CCompositeMaterialsIterator CLib3MFCompositeMaterialsIterator;
typedef CMultiPropertyGroupIterator CLib3MFMultiPropertyGroupIterator;
typedef CMetaData CLib3MFMetaData;
typedef CMetaDataGroup CLib3MFMetaDataGroup;
typedef CObject CLib3MFObject;
typedef CMeshObject CLib3MFMeshObject;
typedef CBeamLattice CLib3MFBeamLattice;
typedef CComponent CLib3MFComponent;
typedef CComponentsObject CLib3MFComponentsObject;
typedef CBeamSet CLib3MFBeamSet;
typedef CBaseMaterialGroup CLib3MFBaseMaterialGroup;
typedef CColorGroup CLib3MFColorGroup;
typedef CTexture2DGroup CLib3MFTexture2DGroup;
typedef CCompositeMaterials CLib3MFCompositeMaterials;
typedef CMultiPropertyGroup CLib3MFMultiPropertyGroup;
typedef CAttachment CLib3MFAttachment;
typedef CTexture2D CLib3MFTexture2D;
typedef CBuildItem CLib3MFBuildItem;
typedef CBuildItemIterator CLib3MFBuildItemIterator;
typedef CSlice CLib3MFSlice;
typedef CToolpathProfile CLib3MFToolpathProfile;
typedef CToolpathLayerReader CLib3MFToolpathLayerReader;
typedef CToolpathLayerData CLib3MFToolpathLayerData;
typedef CToolpath CLib3MFToolpath;
typedef CToolpathIterator CLib3MFToolpathIterator;
typedef CSliceStack CLib3MFSliceStack;
typedef CConsumer CLib3MFConsumer;
typedef CAccessRight CLib3MFAccessRight;
typedef CContentEncryptionParams CLib3MFContentEncryptionParams;
typedef CResourceData CLib3MFResourceData;
typedef CResourceDataGroup CLib3MFResourceDataGroup;
typedef CKeyStore CLib3MFKeyStore;
typedef CModel CLib3MFModel;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CBinaryStream> PBinaryStream;
typedef std::shared_ptr<CWriter> PWriter;
typedef std::shared_ptr<CPersistentReaderSource> PPersistentReaderSource;
typedef std::shared_ptr<CReader> PReader;
typedef std::shared_ptr<CPackagePart> PPackagePart;
typedef std::shared_ptr<CResource> PResource;
typedef std::shared_ptr<CResourceIterator> PResourceIterator;
typedef std::shared_ptr<CCustomXMLAttribute> PCustomXMLAttribute;
typedef std::shared_ptr<CCustomXMLNode> PCustomXMLNode;
typedef std::shared_ptr<CCustomXMLNodes> PCustomXMLNodes;
typedef std::shared_ptr<CCustomDOMTree> PCustomDOMTree;
typedef std::shared_ptr<CSliceStackIterator> PSliceStackIterator;
typedef std::shared_ptr<CObjectIterator> PObjectIterator;
typedef std::shared_ptr<CMeshObjectIterator> PMeshObjectIterator;
typedef std::shared_ptr<CComponentsObjectIterator> PComponentsObjectIterator;
typedef std::shared_ptr<CTexture2DIterator> PTexture2DIterator;
typedef std::shared_ptr<CBaseMaterialGroupIterator> PBaseMaterialGroupIterator;
typedef std::shared_ptr<CColorGroupIterator> PColorGroupIterator;
typedef std::shared_ptr<CTexture2DGroupIterator> PTexture2DGroupIterator;
typedef std::shared_ptr<CCompositeMaterialsIterator> PCompositeMaterialsIterator;
typedef std::shared_ptr<CMultiPropertyGroupIterator> PMultiPropertyGroupIterator;
typedef std::shared_ptr<CMetaData> PMetaData;
typedef std::shared_ptr<CMetaDataGroup> PMetaDataGroup;
typedef std::shared_ptr<CObject> PObject;
typedef std::shared_ptr<CMeshObject> PMeshObject;
typedef std::shared_ptr<CBeamLattice> PBeamLattice;
typedef std::shared_ptr<CComponent> PComponent;
typedef std::shared_ptr<CComponentsObject> PComponentsObject;
typedef std::shared_ptr<CBeamSet> PBeamSet;
typedef std::shared_ptr<CBaseMaterialGroup> PBaseMaterialGroup;
typedef std::shared_ptr<CColorGroup> PColorGroup;
typedef std::shared_ptr<CTexture2DGroup> PTexture2DGroup;
typedef std::shared_ptr<CCompositeMaterials> PCompositeMaterials;
typedef std::shared_ptr<CMultiPropertyGroup> PMultiPropertyGroup;
typedef std::shared_ptr<CAttachment> PAttachment;
typedef std::shared_ptr<CTexture2D> PTexture2D;
typedef std::shared_ptr<CBuildItem> PBuildItem;
typedef std::shared_ptr<CBuildItemIterator> PBuildItemIterator;
typedef std::shared_ptr<CSlice> PSlice;
typedef std::shared_ptr<CToolpathProfile> PToolpathProfile;
typedef std::shared_ptr<CToolpathLayerReader> PToolpathLayerReader;
typedef std::shared_ptr<CToolpathLayerData> PToolpathLayerData;
typedef std::shared_ptr<CToolpath> PToolpath;
typedef std::shared_ptr<CToolpathIterator> PToolpathIterator;
typedef std::shared_ptr<CSliceStack> PSliceStack;
typedef std::shared_ptr<CConsumer> PConsumer;
typedef std::shared_ptr<CAccessRight> PAccessRight;
typedef std::shared_ptr<CContentEncryptionParams> PContentEncryptionParams;
typedef std::shared_ptr<CResourceData> PResourceData;
typedef std::shared_ptr<CResourceDataGroup> PResourceDataGroup;
typedef std::shared_ptr<CKeyStore> PKeyStore;
typedef std::shared_ptr<CModel> PModel;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLib3MFWrapper;
typedef PBase PLib3MFBase;
typedef PBinaryStream PLib3MFBinaryStream;
typedef PWriter PLib3MFWriter;
typedef PPersistentReaderSource PLib3MFPersistentReaderSource;
typedef PReader PLib3MFReader;
typedef PPackagePart PLib3MFPackagePart;
typedef PResource PLib3MFResource;
typedef PResourceIterator PLib3MFResourceIterator;
typedef PCustomXMLAttribute PLib3MFCustomXMLAttribute;
typedef PCustomXMLNode PLib3MFCustomXMLNode;
typedef PCustomXMLNodes PLib3MFCustomXMLNodes;
typedef PCustomDOMTree PLib3MFCustomDOMTree;
typedef PSliceStackIterator PLib3MFSliceStackIterator;
typedef PObjectIterator PLib3MFObjectIterator;
typedef PMeshObjectIterator PLib3MFMeshObjectIterator;
typedef PComponentsObjectIterator PLib3MFComponentsObjectIterator;
typedef PTexture2DIterator PLib3MFTexture2DIterator;
typedef PBaseMaterialGroupIterator PLib3MFBaseMaterialGroupIterator;
typedef PColorGroupIterator PLib3MFColorGroupIterator;
typedef PTexture2DGroupIterator PLib3MFTexture2DGroupIterator;
typedef PCompositeMaterialsIterator PLib3MFCompositeMaterialsIterator;
typedef PMultiPropertyGroupIterator PLib3MFMultiPropertyGroupIterator;
typedef PMetaData PLib3MFMetaData;
typedef PMetaDataGroup PLib3MFMetaDataGroup;
typedef PObject PLib3MFObject;
typedef PMeshObject PLib3MFMeshObject;
typedef PBeamLattice PLib3MFBeamLattice;
typedef PComponent PLib3MFComponent;
typedef PComponentsObject PLib3MFComponentsObject;
typedef PBeamSet PLib3MFBeamSet;
typedef PBaseMaterialGroup PLib3MFBaseMaterialGroup;
typedef PColorGroup PLib3MFColorGroup;
typedef PTexture2DGroup PLib3MFTexture2DGroup;
typedef PCompositeMaterials PLib3MFCompositeMaterials;
typedef PMultiPropertyGroup PLib3MFMultiPropertyGroup;
typedef PAttachment PLib3MFAttachment;
typedef PTexture2D PLib3MFTexture2D;
typedef PBuildItem PLib3MFBuildItem;
typedef PBuildItemIterator PLib3MFBuildItemIterator;
typedef PSlice PLib3MFSlice;
typedef PToolpathProfile PLib3MFToolpathProfile;
typedef PToolpathLayerReader PLib3MFToolpathLayerReader;
typedef PToolpathLayerData PLib3MFToolpathLayerData;
typedef PToolpath PLib3MFToolpath;
typedef PToolpathIterator PLib3MFToolpathIterator;
typedef PSliceStack PLib3MFSliceStack;
typedef PConsumer PLib3MFConsumer;
typedef PAccessRight PLib3MFAccessRight;
typedef PContentEncryptionParams PLib3MFContentEncryptionParams;
typedef PResourceData PLib3MFResourceData;
typedef PResourceDataGroup PLib3MFResourceDataGroup;
typedef PKeyStore PLib3MFKeyStore;
typedef PModel PLib3MFModel;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	Lib3MFHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELib3MFException 
**************************************************************************************************************************/
class ELib3MFException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	Lib3MFResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELib3MFException(Lib3MFResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	Lib3MFResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIB3MF_SUCCESS: return "SUCCESS";
			case LIB3MF_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIB3MF_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIB3MF_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIB3MF_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIB3MF_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIB3MF_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIB3MF_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIB3MF_ERROR_CALCULATIONABORTED: return "CALCULATIONABORTED";
			case LIB3MF_ERROR_SHOULDNOTBECALLED: return "SHOULDNOTBECALLED";
			case LIB3MF_ERROR_READERCLASSUNKNOWN: return "READERCLASSUNKNOWN";
			case LIB3MF_ERROR_WRITERCLASSUNKNOWN: return "WRITERCLASSUNKNOWN";
			case LIB3MF_ERROR_ITERATORINVALIDINDEX: return "ITERATORINVALIDINDEX";
			case LIB3MF_ERROR_INVALIDMODELRESOURCE: return "INVALIDMODELRESOURCE";
			case LIB3MF_ERROR_RESOURCENOTFOUND: return "RESOURCENOTFOUND";
			case LIB3MF_ERROR_INVALIDMODEL: return "INVALIDMODEL";
			case LIB3MF_ERROR_INVALIDOBJECT: return "INVALIDOBJECT";
			case LIB3MF_ERROR_INVALIDMESHOBJECT: return "INVALIDMESHOBJECT";
			case LIB3MF_ERROR_INVALIDCOMPONENTSOBJECT: return "INVALIDCOMPONENTSOBJECT";
			case LIB3MF_ERROR_INVALIDCOMPONENT: return "INVALIDCOMPONENT";
			case LIB3MF_ERROR_INVALIDBUILDITEM: return "INVALIDBUILDITEM";
			case LIB3MF_ERROR_INVALIDBASEMATERIALGROUP: return "INVALIDBASEMATERIALGROUP";
			case LIB3MF_ERROR_INVALIDSLICESTACKRESOURCE: return "INVALIDSLICESTACKRESOURCE";
			case LIB3MF_ERROR_INVALIDTEXTURERESOURCE: return "INVALIDTEXTURERESOURCE";
			case LIB3MF_ERROR_INVALIDCOLORGROUP: return "INVALIDCOLORGROUP";
			case LIB3MF_ERROR_INVALIDTEXTURE2DGROUP: return "INVALIDTEXTURE2DGROUP";
			case LIB3MF_ERROR_INVALIDCOMPOSITEMATERIALS: return "INVALIDCOMPOSITEMATERIALS";
			case LIB3MF_ERROR_INVALIDMULTIPROPERTYGROUP: return "INVALIDMULTIPROPERTYGROUP";
			case LIB3MF_ERROR_INVALIDRESOURCEINDEX: return "INVALIDRESOURCEINDEX";
			case LIB3MF_ERROR_ATTACHMENTNOTFOUND: return "ATTACHMENTNOTFOUND";
			case LIB3MF_ERROR_FORBIDDENCYCLICREFERENCE: return "FORBIDDENCYCLICREFERENCE";
			case LIB3MF_ERROR_INVALIDATTACHMENTSTREAM: return "INVALIDATTACHMENTSTREAM";
			case LIB3MF_ERROR_INVALIDPROPERTYCOUNT: return "INVALIDPROPERTYCOUNT";
			case LIB3MF_ERROR_UNKOWNPROGRESSIDENTIFIER: return "UNKOWNPROGRESSIDENTIFIER";
			case LIB3MF_ERROR_ELEMENTCOUNTEXCEEDSLIMIT: return "ELEMENTCOUNTEXCEEDSLIMIT";
			case LIB3MF_ERROR_INVALIDRESOURCE: return "INVALIDRESOURCE";
			case LIB3MF_ERROR_INVALIDNODEINDEX: return "INVALIDNODEINDEX";
			case LIB3MF_ERROR_INVALIDATTRIBUTEINDEX: return "INVALIDATTRIBUTEINDEX";
			case LIB3MF_ERROR_DUPLICATECUSTOMDATA: return "DUPLICATECUSTOMDATA";
			case LIB3MF_ERROR_CUSTOMDATANOTFOUND: return "CUSTOMDATANOTFOUND";
			case LIB3MF_ERROR_BEAMLATTICE_INVALID_OBJECTTYPE: return "BEAMLATTICE_INVALID_OBJECTTYPE";
			case LIB3MF_ERROR_INVALIDKEYSTORE: return "INVALIDKEYSTORE";
			case LIB3MF_ERROR_INVALIDKEYSTORECONSUMER: return "INVALIDKEYSTORECONSUMER";
			case LIB3MF_ERROR_KEYSTORECONSUMERNOTFOUND: return "KEYSTORECONSUMERNOTFOUND";
			case LIB3MF_ERROR_KEYSTORERESOURCEDATANOTFOUND: return "KEYSTORERESOURCEDATANOTFOUND";
			case LIB3MF_ERROR_SECURECONTEXTNOTREGISTERED: return "SECURECONTEXTNOTREGISTERED";
			case LIB3MF_ERROR_INVALIDKEYSIZE: return "INVALIDKEYSIZE";
			case LIB3MF_ERROR_TOOLPATH_NOTWRITINGHEADER: return "TOOLPATH_NOTWRITINGHEADER";
			case LIB3MF_ERROR_TOOLPATH_NOTWRITINGDATA: return "TOOLPATH_NOTWRITINGDATA";
			case LIB3MF_ERROR_TOOLPATH_DATAHASBEENWRITTEN: return "TOOLPATH_DATAHASBEENWRITTEN";
			case LIB3MF_ERROR_TOOLPATH_INVALIDPOINTCOUNT: return "TOOLPATH_INVALIDPOINTCOUNT";
			case LIB3MF_ERROR_TOOLPATH_ATTRIBUTEALREADYDEFINED: return "TOOLPATH_ATTRIBUTEALREADYDEFINED";
			case LIB3MF_ERROR_TOOLPATH_INVALIDATTRIBUTETYPE: return "TOOLPATH_INVALIDATTRIBUTETYPE";
			case LIB3MF_ERROR_EMPTYNAMESPACEPREFIX: return "EMPTYNAMESPACEPREFIX";
			case LIB3MF_ERROR_EMPTYNAMESPACE: return "EMPTYNAMESPACE";
			case LIB3MF_ERROR_INVALIDNAMESPACEPREFIX: return "INVALIDNAMESPACEPREFIX";
			case LIB3MF_ERROR_WRITERDOESNOTSUPPORTNAMESPACES: return "WRITERDOESNOTSUPPORTNAMESPACES";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIB3MF_SUCCESS: return "success";
			case LIB3MF_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIB3MF_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIB3MF_ERROR_INVALIDCAST: return "a type cast failed";
			case LIB3MF_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIB3MF_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIB3MF_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIB3MF_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIB3MF_ERROR_CALCULATIONABORTED: return "a calculation has been aborted";
			case LIB3MF_ERROR_SHOULDNOTBECALLED: return "functionality should not be called";
			case LIB3MF_ERROR_READERCLASSUNKNOWN: return "the queried reader class is unknown";
			case LIB3MF_ERROR_WRITERCLASSUNKNOWN: return "the queried writer class is unknown";
			case LIB3MF_ERROR_ITERATORINVALIDINDEX: return "the current index of an iterator is invalid";
			case LIB3MF_ERROR_INVALIDMODELRESOURCE: return "no Model Resource has been given";
			case LIB3MF_ERROR_RESOURCENOTFOUND: return "Resource not found";
			case LIB3MF_ERROR_INVALIDMODEL: return "A model is invalid";
			case LIB3MF_ERROR_INVALIDOBJECT: return "An object is invalid";
			case LIB3MF_ERROR_INVALIDMESHOBJECT: return "A mesh object is invalid";
			case LIB3MF_ERROR_INVALIDCOMPONENTSOBJECT: return "A components object is invalid";
			case LIB3MF_ERROR_INVALIDCOMPONENT: return "A component is invalid";
			case LIB3MF_ERROR_INVALIDBUILDITEM: return "A build item is invalid";
			case LIB3MF_ERROR_INVALIDBASEMATERIALGROUP: return "A basematerialgroup is invalid";
			case LIB3MF_ERROR_INVALIDSLICESTACKRESOURCE: return "A slicestack resource is invalid";
			case LIB3MF_ERROR_INVALIDTEXTURERESOURCE: return "A texture resource is invalid";
			case LIB3MF_ERROR_INVALIDCOLORGROUP: return "A color group resource is invalid";
			case LIB3MF_ERROR_INVALIDTEXTURE2DGROUP: return "A texture2d group resource is invalid";
			case LIB3MF_ERROR_INVALIDCOMPOSITEMATERIALS: return "A composite materials resource is invalid";
			case LIB3MF_ERROR_INVALIDMULTIPROPERTYGROUP: return "A MultiPropertyGroup resource is invalid";
			case LIB3MF_ERROR_INVALIDRESOURCEINDEX: return "A resource index is invalid";
			case LIB3MF_ERROR_ATTACHMENTNOTFOUND: return "Attachment not found";
			case LIB3MF_ERROR_FORBIDDENCYCLICREFERENCE: return "A component references one of its ancestors";
			case LIB3MF_ERROR_INVALIDATTACHMENTSTREAM: return "An attachment stream is invalid";
			case LIB3MF_ERROR_INVALIDPROPERTYCOUNT: return "Invalid property count.";
			case LIB3MF_ERROR_UNKOWNPROGRESSIDENTIFIER: return "A progress identifier is unknown";
			case LIB3MF_ERROR_ELEMENTCOUNTEXCEEDSLIMIT: return "An element buffer exceeds its spec limit";
			case LIB3MF_ERROR_INVALIDRESOURCE: return "A resource is invalid";
			case LIB3MF_ERROR_INVALIDNODEINDEX: return "Invalid node index";
			case LIB3MF_ERROR_INVALIDATTRIBUTEINDEX: return "Invalid attribute index";
			case LIB3MF_ERROR_DUPLICATECUSTOMDATA: return "Duplicate custom data";
			case LIB3MF_ERROR_CUSTOMDATANOTFOUND: return "Custom data not found";
			case LIB3MF_ERROR_BEAMLATTICE_INVALID_OBJECTTYPE: return "This object type is not valid for beamlattices";
			case LIB3MF_ERROR_INVALIDKEYSTORE: return "The keystore object is invalid";
			case LIB3MF_ERROR_INVALIDKEYSTORECONSUMER: return "The consumer keystore object is invalid";
			case LIB3MF_ERROR_KEYSTORECONSUMERNOTFOUND: return "A consumer has not been found";
			case LIB3MF_ERROR_KEYSTORERESOURCEDATANOTFOUND: return "A resource data has not been found";
			case LIB3MF_ERROR_SECURECONTEXTNOTREGISTERED: return "A Key or Conentent encryption callback has not been registered";
			case LIB3MF_ERROR_INVALIDKEYSIZE: return "The key size is invalid";
			case LIB3MF_ERROR_TOOLPATH_NOTWRITINGHEADER: return "Not in toolpath header writing mode";
			case LIB3MF_ERROR_TOOLPATH_NOTWRITINGDATA: return "Not in toolpath data writing mode";
			case LIB3MF_ERROR_TOOLPATH_DATAHASBEENWRITTEN: return "Toolpath has already been written out";
			case LIB3MF_ERROR_TOOLPATH_INVALIDPOINTCOUNT: return "Toolpath has an invalid number of points";
			case LIB3MF_ERROR_TOOLPATH_ATTRIBUTEALREADYDEFINED: return "Toolpath attribute already defined";
			case LIB3MF_ERROR_TOOLPATH_INVALIDATTRIBUTETYPE: return "Toolpath attribute is of invalid type";
			case LIB3MF_ERROR_EMPTYNAMESPACEPREFIX: return "Empty namespace prefix.";
			case LIB3MF_ERROR_EMPTYNAMESPACE: return "Empty namespace.";
			case LIB3MF_ERROR_INVALIDNAMESPACEPREFIX: return "Invalid namespace prefix.";
			case LIB3MF_ERROR_WRITERDOESNOTSUPPORTNAMESPACES: return "Writer does not support namespaces.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLib3MFInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, Lib3MFResult nResult);

	inline void GetLibraryVersion(Lib3MF_uint32 & nMajor, Lib3MF_uint32 & nMinor, Lib3MF_uint32 & nMicro);
	inline bool GetPrereleaseInformation(std::string & sPrereleaseInfo);
	inline bool GetBuildInformation(std::string & sBuildInformation);
	inline void GetSpecificationVersion(const std::string & sSpecificationURL, bool & bIsSupported, Lib3MF_uint32 & nMajor, Lib3MF_uint32 & nMinor, Lib3MF_uint32 & nMicro);
	inline PModel CreateModel();
	inline void Release(classParam<CBase> pInstance);
	inline void Acquire(classParam<CBase> pInstance);
	inline void SetJournal(const std::string & sJournalPath);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sLastErrorString);
	inline Lib3MF_pvoid GetSymbolLookupMethod();
	inline void RetrieveProgressMessage(const eProgressIdentifier eTheProgressIdentifier, std::string & sProgressMessage);
	inline sColor RGBAToColor(const Lib3MF_uint8 nRed, const Lib3MF_uint8 nGreen, const Lib3MF_uint8 nBlue, const Lib3MF_uint8 nAlpha);
	inline sColor FloatRGBAToColor(const Lib3MF_single fRed, const Lib3MF_single fGreen, const Lib3MF_single fBlue, const Lib3MF_single fAlpha);
	inline void ColorToRGBA(const sColor & TheColor, Lib3MF_uint8 & nRed, Lib3MF_uint8 & nGreen, Lib3MF_uint8 & nBlue, Lib3MF_uint8 & nAlpha);
	inline void ColorToFloatRGBA(const sColor & TheColor, Lib3MF_single & fRed, Lib3MF_single & fGreen, Lib3MF_single & fBlue, Lib3MF_single & fAlpha);
	inline sTransform GetIdentityTransform();
	inline sTransform GetUniformScaleTransform(const Lib3MF_single fFactor);
	inline sTransform GetScaleTransform(const Lib3MF_single fFactorX, const Lib3MF_single fFactorY, const Lib3MF_single fFactorZ);
	inline sTransform GetTranslationTransform(const Lib3MF_single fVectorX, const Lib3MF_single fVectorY, const Lib3MF_single fVectorZ);

	inline CBase* polymorphicFactory(Lib3MFHandle);

private:
	sLib3MFDynamicWrapperTable m_WrapperTable;
	
	Lib3MFResult checkBinaryVersion()
	{
		Lib3MF_uint32 nMajor, nMinor, nMicro;
		GetLibraryVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIB3MF_VERSION_MAJOR) || (nMinor < LIB3MF_VERSION_MINOR) ) {
			return LIB3MF_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIB3MF_SUCCESS;
	}
	Lib3MFResult initWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable);
	Lib3MFResult releaseWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable);
	Lib3MFResult loadWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	Lib3MFResult loadWrapperTableFromSymbolLookupMethod(sLib3MFDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CBinaryStream;
	friend class CWriter;
	friend class CPersistentReaderSource;
	friend class CReader;
	friend class CPackagePart;
	friend class CResource;
	friend class CResourceIterator;
	friend class CCustomXMLAttribute;
	friend class CCustomXMLNode;
	friend class CCustomXMLNodes;
	friend class CCustomDOMTree;
	friend class CSliceStackIterator;
	friend class CObjectIterator;
	friend class CMeshObjectIterator;
	friend class CComponentsObjectIterator;
	friend class CTexture2DIterator;
	friend class CBaseMaterialGroupIterator;
	friend class CColorGroupIterator;
	friend class CTexture2DGroupIterator;
	friend class CCompositeMaterialsIterator;
	friend class CMultiPropertyGroupIterator;
	friend class CMetaData;
	friend class CMetaDataGroup;
	friend class CObject;
	friend class CMeshObject;
	friend class CBeamLattice;
	friend class CComponent;
	friend class CComponentsObject;
	friend class CBeamSet;
	friend class CBaseMaterialGroup;
	friend class CColorGroup;
	friend class CTexture2DGroup;
	friend class CCompositeMaterials;
	friend class CMultiPropertyGroup;
	friend class CAttachment;
	friend class CTexture2D;
	friend class CBuildItem;
	friend class CBuildItemIterator;
	friend class CSlice;
	friend class CToolpathProfile;
	friend class CToolpathLayerReader;
	friend class CToolpathLayerData;
	friend class CToolpath;
	friend class CToolpathIterator;
	friend class CSliceStack;
	friend class CConsumer;
	friend class CAccessRight;
	friend class CContentEncryptionParams;
	friend class CResourceData;
	friend class CResourceDataGroup;
	friend class CKeyStore;
	friend class CModel;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	Lib3MFHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(Lib3MFResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, Lib3MFHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->Release(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	Lib3MFHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}

	friend class CWrapper;
	inline Lib3MF_uint64 ClassTypeId();
};
	
/*************************************************************************************************************************
 Class CBinaryStream 
**************************************************************************************************************************/
class CBinaryStream : public CBase {
public:
	
	/**
	* CBinaryStream::CBinaryStream - Constructor for BinaryStream class.
	*/
	CBinaryStream(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetBinaryPath();
	inline std::string GetIndexPath();
	inline std::string GetUUID();
	inline void DisableDiscretizedArrayCompression();
	inline void EnableDiscretizedArrayCompression(const Lib3MF_double dUnits, const eBinaryStreamPredictionType ePredictionType);
	inline void EnableLZMA(const Lib3MF_uint32 nLZMALevel);
	inline void DisableLZMA();
};
	
/*************************************************************************************************************************
 Class CWriter 
**************************************************************************************************************************/
class CWriter : public CBase {
public:
	
	/**
	* CWriter::CWriter - Constructor for Writer class.
	*/
	CWriter(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void WriteToFile(const std::string & sFilename);
	inline Lib3MF_uint64 GetStreamSize();
	inline void WriteToBuffer(std::vector<Lib3MF_uint8> & BufferBuffer);
	inline void WriteToCallback(const WriteCallback pTheWriteCallback, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData);
	inline void SetProgressCallback(const ProgressCallback pProgressCallback, const Lib3MF_pvoid pUserData);
	inline Lib3MF_uint32 GetDecimalPrecision();
	inline void SetDecimalPrecision(const Lib3MF_uint32 nDecimalPrecision);
	inline void SetStrictModeActive(const bool bStrictModeActive);
	inline bool GetStrictModeActive();
	inline std::string GetWarning(const Lib3MF_uint32 nIndex, Lib3MF_uint32 & nErrorCode);
	inline Lib3MF_uint32 GetWarningCount();
	inline void AddKeyWrappingCallback(const std::string & sConsumerID, const KeyWrappingCallback pTheCallback, const Lib3MF_pvoid pUserData);
	inline void SetContentEncryptionCallback(const ContentEncryptionCallback pTheCallback, const Lib3MF_pvoid pUserData);
	inline PBinaryStream CreateBinaryStream(const std::string & sIndexPath, const std::string & sBinaryPath);
	inline void AssignBinaryStream(classParam<CBase> pInstance, classParam<CBinaryStream> pBinaryStream);
	inline void RegisterCustomNamespace(const std::string & sPrefix, const std::string & sNameSpace);
};
	
/*************************************************************************************************************************
 Class CPersistentReaderSource 
**************************************************************************************************************************/
class CPersistentReaderSource : public CBase {
public:
	
	/**
	* CPersistentReaderSource::CPersistentReaderSource - Constructor for PersistentReaderSource class.
	*/
	CPersistentReaderSource(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline ePersistentReaderSourceType GetSourceType();
	inline void InvalidateSourceData();
	inline bool SourceDataIsValid();
};
	
/*************************************************************************************************************************
 Class CReader 
**************************************************************************************************************************/
class CReader : public CBase {
public:
	
	/**
	* CReader::CReader - Constructor for Reader class.
	*/
	CReader(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void ReadFromPersistentSource(classParam<CPersistentReaderSource> pSource);
	inline void ReadFromFile(const std::string & sFilename);
	inline void ReadFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer);
	inline void ReadFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData);
	inline void SetProgressCallback(const ProgressCallback pProgressCallback, const Lib3MF_pvoid pUserData);
	inline void AddRelationToRead(const std::string & sRelationShipType);
	inline void RemoveRelationToRead(const std::string & sRelationShipType);
	inline void SetStrictModeActive(const bool bStrictModeActive);
	inline bool GetStrictModeActive();
	inline std::string GetWarning(const Lib3MF_uint32 nIndex, Lib3MF_uint32 & nErrorCode);
	inline Lib3MF_uint32 GetWarningCount();
	inline void AddKeyWrappingCallback(const std::string & sConsumerID, const KeyWrappingCallback pTheCallback, const Lib3MF_pvoid pUserData);
	inline void SetContentEncryptionCallback(const ContentEncryptionCallback pTheCallback, const Lib3MF_pvoid pUserData);
};
	
/*************************************************************************************************************************
 Class CPackagePart 
**************************************************************************************************************************/
class CPackagePart : public CBase {
public:
	
	/**
	* CPackagePart::CPackagePart - Constructor for PackagePart class.
	*/
	CPackagePart(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetPath();
	inline void SetPath(const std::string & sPath);
};
	
/*************************************************************************************************************************
 Class CResource 
**************************************************************************************************************************/
class CResource : public CBase {
public:
	
	/**
	* CResource::CResource - Constructor for Resource class.
	*/
	CResource(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetResourceID();
	inline Lib3MF_uint32 GetUniqueResourceID();
	inline PPackagePart PackagePart();
	inline void SetPackagePart(classParam<CPackagePart> pPackagePart);
	inline Lib3MF_uint32 GetModelResourceID();
};
	
/*************************************************************************************************************************
 Class CResourceIterator 
**************************************************************************************************************************/
class CResourceIterator : public CBase {
public:
	
	/**
	* CResourceIterator::CResourceIterator - Constructor for ResourceIterator class.
	*/
	CResourceIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PResource GetCurrent();
	inline PResourceIterator Clone();
	inline Lib3MF_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CCustomXMLAttribute 
**************************************************************************************************************************/
class CCustomXMLAttribute : public CBase {
public:
	
	/**
	* CCustomXMLAttribute::CCustomXMLAttribute - Constructor for CustomXMLAttribute class.
	*/
	CCustomXMLAttribute(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetValue();
	inline bool IsValidInteger(const Lib3MF_int64 nMinValue, const Lib3MF_int64 nMaxValue);
	inline Lib3MF_int64 GetIntegerValue(const Lib3MF_int64 nMinValue, const Lib3MF_int64 nMaxValue);
	inline bool IsValidDouble(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue);
	inline Lib3MF_double GetDoubleValue(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue);
	inline bool IsValidBool();
	inline bool GetBoolValue(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue);
	inline void SetValue(const std::string & sValue);
	inline void SetIntegerValue(const Lib3MF_int64 nValue);
	inline void SetDoubleValue(const Lib3MF_double dValue);
	inline void SetBoolValue(const bool bValue);
	inline void Remove();
};
	
/*************************************************************************************************************************
 Class CCustomXMLNode 
**************************************************************************************************************************/
class CCustomXMLNode : public CBase {
public:
	
	/**
	* CCustomXMLNode::CCustomXMLNode - Constructor for CustomXMLNode class.
	*/
	CCustomXMLNode(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetNameSpace();
	inline Lib3MF_uint64 GetAttributeCount();
	inline PCustomXMLAttribute GetAttribute(const Lib3MF_uint64 nIndex);
	inline bool HasAttribute(const std::string & sName);
	inline PCustomXMLAttribute FindAttribute(const std::string & sName, const bool bMustExist);
	inline bool RemoveAttribute(const std::string & sName);
	inline bool RemoveAttributeByIndex(const Lib3MF_uint64 nIndex);
	inline void AddAttribute(const std::string & sName, const std::string & sValue);
	inline void AddIntegerAttribute(const std::string & sName, const Lib3MF_int64 nValue);
	inline void AddDoubleAttribute(const std::string & sName, const Lib3MF_double dValue);
	inline void AddBoolAttribute(const std::string & sName, const bool bValue);
	inline PCustomXMLNodes GetChildren();
	inline Lib3MF_uint64 CountChildrenByName(const std::string & sName);
	inline PCustomXMLNodes GetChildrenByName(const std::string & sName);
	inline bool HasChild(const std::string & sName);
	inline bool HasUniqueChild(const std::string & sName);
	inline PCustomXMLNode FindChild(const std::string & sName, const bool bMustExist);
	inline PCustomXMLNode AddChild(const std::string & sName);
	inline void RemoveChild(classParam<CCustomXMLNode> pChildInstance);
	inline Lib3MF_uint64 RemoveChildrenWithName(const std::string & sName);
	inline void Remove();
};
	
/*************************************************************************************************************************
 Class CCustomXMLNodes 
**************************************************************************************************************************/
class CCustomXMLNodes : public CBase {
public:
	
	/**
	* CCustomXMLNodes::CCustomXMLNodes - Constructor for CustomXMLNodes class.
	*/
	CCustomXMLNodes(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint64 GetNodeCount();
	inline PCustomXMLNode GetNode(const Lib3MF_uint64 nIndex);
	inline Lib3MF_uint64 CountNodesByName(const std::string & sName);
	inline PCustomXMLNodes GetNodesByName(const std::string & sName);
	inline bool HasNode(const std::string & sName);
	inline bool HasUniqueNode(const std::string & sName);
	inline PCustomXMLNode FindNode(const std::string & sName, const bool bMustExist);
};
	
/*************************************************************************************************************************
 Class CCustomDOMTree 
**************************************************************************************************************************/
class CCustomDOMTree : public CBase {
public:
	
	/**
	* CCustomDOMTree::CCustomDOMTree - Constructor for CustomDOMTree class.
	*/
	CCustomDOMTree(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetNameSpace();
	inline PCustomXMLNode GetRootNode();
	inline std::string SaveToString();
};
	
/*************************************************************************************************************************
 Class CSliceStackIterator 
**************************************************************************************************************************/
class CSliceStackIterator : public CResourceIterator {
public:
	
	/**
	* CSliceStackIterator::CSliceStackIterator - Constructor for SliceStackIterator class.
	*/
	CSliceStackIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PSliceStack GetCurrentSliceStack();
};
	
/*************************************************************************************************************************
 Class CObjectIterator 
**************************************************************************************************************************/
class CObjectIterator : public CResourceIterator {
public:
	
	/**
	* CObjectIterator::CObjectIterator - Constructor for ObjectIterator class.
	*/
	CObjectIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PObject GetCurrentObject();
};
	
/*************************************************************************************************************************
 Class CMeshObjectIterator 
**************************************************************************************************************************/
class CMeshObjectIterator : public CResourceIterator {
public:
	
	/**
	* CMeshObjectIterator::CMeshObjectIterator - Constructor for MeshObjectIterator class.
	*/
	CMeshObjectIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PMeshObject GetCurrentMeshObject();
};
	
/*************************************************************************************************************************
 Class CComponentsObjectIterator 
**************************************************************************************************************************/
class CComponentsObjectIterator : public CResourceIterator {
public:
	
	/**
	* CComponentsObjectIterator::CComponentsObjectIterator - Constructor for ComponentsObjectIterator class.
	*/
	CComponentsObjectIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PComponentsObject GetCurrentComponentsObject();
};
	
/*************************************************************************************************************************
 Class CTexture2DIterator 
**************************************************************************************************************************/
class CTexture2DIterator : public CResourceIterator {
public:
	
	/**
	* CTexture2DIterator::CTexture2DIterator - Constructor for Texture2DIterator class.
	*/
	CTexture2DIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PTexture2D GetCurrentTexture2D();
};
	
/*************************************************************************************************************************
 Class CBaseMaterialGroupIterator 
**************************************************************************************************************************/
class CBaseMaterialGroupIterator : public CResourceIterator {
public:
	
	/**
	* CBaseMaterialGroupIterator::CBaseMaterialGroupIterator - Constructor for BaseMaterialGroupIterator class.
	*/
	CBaseMaterialGroupIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PBaseMaterialGroup GetCurrentBaseMaterialGroup();
};
	
/*************************************************************************************************************************
 Class CColorGroupIterator 
**************************************************************************************************************************/
class CColorGroupIterator : public CResourceIterator {
public:
	
	/**
	* CColorGroupIterator::CColorGroupIterator - Constructor for ColorGroupIterator class.
	*/
	CColorGroupIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PColorGroup GetCurrentColorGroup();
};
	
/*************************************************************************************************************************
 Class CTexture2DGroupIterator 
**************************************************************************************************************************/
class CTexture2DGroupIterator : public CResourceIterator {
public:
	
	/**
	* CTexture2DGroupIterator::CTexture2DGroupIterator - Constructor for Texture2DGroupIterator class.
	*/
	CTexture2DGroupIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PTexture2DGroup GetCurrentTexture2DGroup();
};
	
/*************************************************************************************************************************
 Class CCompositeMaterialsIterator 
**************************************************************************************************************************/
class CCompositeMaterialsIterator : public CResourceIterator {
public:
	
	/**
	* CCompositeMaterialsIterator::CCompositeMaterialsIterator - Constructor for CompositeMaterialsIterator class.
	*/
	CCompositeMaterialsIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PCompositeMaterials GetCurrentCompositeMaterials();
};
	
/*************************************************************************************************************************
 Class CMultiPropertyGroupIterator 
**************************************************************************************************************************/
class CMultiPropertyGroupIterator : public CResourceIterator {
public:
	
	/**
	* CMultiPropertyGroupIterator::CMultiPropertyGroupIterator - Constructor for MultiPropertyGroupIterator class.
	*/
	CMultiPropertyGroupIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PMultiPropertyGroup GetCurrentMultiPropertyGroup();
};
	
/*************************************************************************************************************************
 Class CMetaData 
**************************************************************************************************************************/
class CMetaData : public CBase {
public:
	
	/**
	* CMetaData::CMetaData - Constructor for MetaData class.
	*/
	CMetaData(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetNameSpace();
	inline void SetNameSpace(const std::string & sNameSpace);
	inline std::string GetName();
	inline void SetName(const std::string & sName);
	inline std::string GetKey();
	inline bool GetMustPreserve();
	inline void SetMustPreserve(const bool bMustPreserve);
	inline std::string GetType();
	inline void SetType(const std::string & sType);
	inline std::string GetValue();
	inline void SetValue(const std::string & sValue);
};
	
/*************************************************************************************************************************
 Class CMetaDataGroup 
**************************************************************************************************************************/
class CMetaDataGroup : public CBase {
public:
	
	/**
	* CMetaDataGroup::CMetaDataGroup - Constructor for MetaDataGroup class.
	*/
	CMetaDataGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetMetaDataCount();
	inline PMetaData GetMetaData(const Lib3MF_uint32 nIndex);
	inline PMetaData GetMetaDataByKey(const std::string & sNameSpace, const std::string & sName);
	inline void RemoveMetaDataByIndex(const Lib3MF_uint32 nIndex);
	inline void RemoveMetaData(classParam<CMetaData> pTheMetaData);
	inline PMetaData AddMetaData(const std::string & sNameSpace, const std::string & sName, const std::string & sValue, const std::string & sType, const bool bMustPreserve);
};
	
/*************************************************************************************************************************
 Class CObject 
**************************************************************************************************************************/
class CObject : public CResource {
public:
	
	/**
	* CObject::CObject - Constructor for Object class.
	*/
	CObject(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline eObjectType GetType();
	inline void SetType(const eObjectType eObjectType);
	inline std::string GetName();
	inline void SetName(const std::string & sName);
	inline std::string GetPartNumber();
	inline void SetPartNumber(const std::string & sPartNumber);
	inline bool IsMeshObject();
	inline bool IsComponentsObject();
	inline bool IsValid();
	inline void SetAttachmentAsThumbnail(classParam<CAttachment> pAttachment);
	inline PAttachment GetThumbnailAttachment();
	inline void ClearThumbnailAttachment();
	inline sBox GetOutbox();
	inline std::string GetUUID(bool & bHasUUID);
	inline void SetUUID(const std::string & sUUID);
	inline PMetaDataGroup GetMetaDataGroup();
	inline void SetSlicesMeshResolution(const eSlicesMeshResolution eMeshResolution);
	inline eSlicesMeshResolution GetSlicesMeshResolution();
	inline bool HasSlices(const bool bRecursive);
	inline void ClearSliceStack();
	inline PSliceStack GetSliceStack();
	inline void AssignSliceStack(classParam<CSliceStack> pSliceStackInstance);
};
	
/*************************************************************************************************************************
 Class CMeshObject 
**************************************************************************************************************************/
class CMeshObject : public CObject {
public:
	
	/**
	* CMeshObject::CMeshObject - Constructor for MeshObject class.
	*/
	CMeshObject(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CObject(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetVertexCount();
	inline Lib3MF_uint32 GetTriangleCount();
	inline sPosition GetVertex(const Lib3MF_uint32 nIndex);
	inline void SetVertex(const Lib3MF_uint32 nIndex, const sPosition & Coordinates);
	inline Lib3MF_uint32 AddVertex(const sPosition & Coordinates);
	inline void GetVertices(std::vector<sPosition> & VerticesBuffer);
	inline sTriangle GetTriangle(const Lib3MF_uint32 nIndex);
	inline void SetTriangle(const Lib3MF_uint32 nIndex, const sTriangle & Indices);
	inline Lib3MF_uint32 AddTriangle(const sTriangle & Indices);
	inline void GetTriangleIndices(std::vector<sTriangle> & IndicesBuffer);
	inline void SetObjectLevelProperty(const Lib3MF_uint32 nUniqueResourceID, const Lib3MF_uint32 nPropertyID);
	inline bool GetObjectLevelProperty(Lib3MF_uint32 & nUniqueResourceID, Lib3MF_uint32 & nPropertyID);
	inline void SetTriangleProperties(const Lib3MF_uint32 nIndex, const sTriangleProperties & Properties);
	inline void GetTriangleProperties(const Lib3MF_uint32 nIndex, sTriangleProperties & Property);
	inline void SetAllTriangleProperties(const CInputVector<sTriangleProperties> & PropertiesArrayBuffer);
	inline void GetAllTriangleProperties(std::vector<sTriangleProperties> & PropertiesArrayBuffer);
	inline void ClearAllProperties();
	inline void SetGeometry(const CInputVector<sPosition> & VerticesBuffer, const CInputVector<sTriangle> & IndicesBuffer);
	inline bool IsManifoldAndOriented();
	inline PBeamLattice BeamLattice();
};
	
/*************************************************************************************************************************
 Class CBeamLattice 
**************************************************************************************************************************/
class CBeamLattice : public CBase {
public:
	
	/**
	* CBeamLattice::CBeamLattice - Constructor for BeamLattice class.
	*/
	CBeamLattice(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_double GetMinLength();
	inline void SetMinLength(const Lib3MF_double dMinLength);
	inline void GetClipping(eBeamLatticeClipMode & eClipMode, Lib3MF_uint32 & nUniqueResourceID);
	inline void SetClipping(const eBeamLatticeClipMode eClipMode, const Lib3MF_uint32 nUniqueResourceID);
	inline bool GetRepresentation(Lib3MF_uint32 & nUniqueResourceID);
	inline void SetRepresentation(const Lib3MF_uint32 nUniqueResourceID);
	inline void GetBallOptions(eBeamLatticeBallMode & eBallMode, Lib3MF_double & dBallRadius);
	inline void SetBallOptions(const eBeamLatticeBallMode eBallMode, const Lib3MF_double dBallRadius);
	inline Lib3MF_uint32 GetBeamCount();
	inline sBeam GetBeam(const Lib3MF_uint32 nIndex);
	inline Lib3MF_uint32 AddBeam(const sBeam & BeamInfo);
	inline void SetBeam(const Lib3MF_uint32 nIndex, const sBeam & BeamInfo);
	inline void SetBeams(const CInputVector<sBeam> & BeamInfoBuffer);
	inline void GetBeams(std::vector<sBeam> & BeamInfoBuffer);
	inline Lib3MF_uint32 GetBallCount();
	inline sBall GetBall(const Lib3MF_uint32 nIndex);
	inline Lib3MF_uint32 AddBall(const sBall & BallInfo);
	inline void SetBall(const Lib3MF_uint32 nIndex, const sBall & BallInfo);
	inline void SetBalls(const CInputVector<sBall> & BallInfoBuffer);
	inline void GetBalls(std::vector<sBall> & BallInfoBuffer);
	inline Lib3MF_uint32 GetBeamSetCount();
	inline PBeamSet AddBeamSet();
	inline PBeamSet GetBeamSet(const Lib3MF_uint32 nIndex);
};
	
/*************************************************************************************************************************
 Class CComponent 
**************************************************************************************************************************/
class CComponent : public CBase {
public:
	
	/**
	* CComponent::CComponent - Constructor for Component class.
	*/
	CComponent(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PObject GetObjectResource();
	inline Lib3MF_uint32 GetObjectResourceID();
	inline std::string GetUUID(bool & bHasUUID);
	inline void SetUUID(const std::string & sUUID);
	inline bool HasTransform();
	inline sTransform GetTransform();
	inline void SetTransform(const sTransform & Transform);
};
	
/*************************************************************************************************************************
 Class CComponentsObject 
**************************************************************************************************************************/
class CComponentsObject : public CObject {
public:
	
	/**
	* CComponentsObject::CComponentsObject - Constructor for ComponentsObject class.
	*/
	CComponentsObject(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CObject(pWrapper, pHandle)
	{
	}
	
	inline PComponent AddComponent(classParam<CObject> pObjectResource, const sTransform & Transform);
	inline PComponent GetComponent(const Lib3MF_uint32 nIndex);
	inline Lib3MF_uint32 GetComponentCount();
};
	
/*************************************************************************************************************************
 Class CBeamSet 
**************************************************************************************************************************/
class CBeamSet : public CBase {
public:
	
	/**
	* CBeamSet::CBeamSet - Constructor for BeamSet class.
	*/
	CBeamSet(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetName(const std::string & sName);
	inline std::string GetName();
	inline void SetIdentifier(const std::string & sIdentifier);
	inline std::string GetIdentifier();
	inline Lib3MF_uint32 GetReferenceCount();
	inline void SetReferences(const CInputVector<Lib3MF_uint32> & ReferencesBuffer);
	inline void GetReferences(std::vector<Lib3MF_uint32> & ReferencesBuffer);
	inline Lib3MF_uint32 GetBallReferenceCount();
	inline void SetBallReferences(const CInputVector<Lib3MF_uint32> & BallReferencesBuffer);
	inline void GetBallReferences(std::vector<Lib3MF_uint32> & BallReferencesBuffer);
};
	
/*************************************************************************************************************************
 Class CBaseMaterialGroup 
**************************************************************************************************************************/
class CBaseMaterialGroup : public CResource {
public:
	
	/**
	* CBaseMaterialGroup::CBaseMaterialGroup - Constructor for BaseMaterialGroup class.
	*/
	CBaseMaterialGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetCount();
	inline void GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline Lib3MF_uint32 AddMaterial(const std::string & sName, const sColor & DisplayColor);
	inline void RemoveMaterial(const Lib3MF_uint32 nPropertyID);
	inline std::string GetName(const Lib3MF_uint32 nPropertyID);
	inline void SetName(const Lib3MF_uint32 nPropertyID, const std::string & sName);
	inline void SetDisplayColor(const Lib3MF_uint32 nPropertyID, const sColor & TheColor);
	inline sColor GetDisplayColor(const Lib3MF_uint32 nPropertyID);
};
	
/*************************************************************************************************************************
 Class CColorGroup 
**************************************************************************************************************************/
class CColorGroup : public CResource {
public:
	
	/**
	* CColorGroup::CColorGroup - Constructor for ColorGroup class.
	*/
	CColorGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetCount();
	inline void GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline Lib3MF_uint32 AddColor(const sColor & TheColor);
	inline void RemoveColor(const Lib3MF_uint32 nPropertyID);
	inline void SetColor(const Lib3MF_uint32 nPropertyID, const sColor & TheColor);
	inline sColor GetColor(const Lib3MF_uint32 nPropertyID);
};
	
/*************************************************************************************************************************
 Class CTexture2DGroup 
**************************************************************************************************************************/
class CTexture2DGroup : public CResource {
public:
	
	/**
	* CTexture2DGroup::CTexture2DGroup - Constructor for Texture2DGroup class.
	*/
	CTexture2DGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetCount();
	inline void GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline Lib3MF_uint32 AddTex2Coord(const sTex2Coord & UVCoordinate);
	inline sTex2Coord GetTex2Coord(const Lib3MF_uint32 nPropertyID);
	inline void RemoveTex2Coord(const Lib3MF_uint32 nPropertyID);
	inline PTexture2D GetTexture2D();
};
	
/*************************************************************************************************************************
 Class CCompositeMaterials 
**************************************************************************************************************************/
class CCompositeMaterials : public CResource {
public:
	
	/**
	* CCompositeMaterials::CCompositeMaterials - Constructor for CompositeMaterials class.
	*/
	CCompositeMaterials(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetCount();
	inline void GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline PBaseMaterialGroup GetBaseMaterialGroup();
	inline Lib3MF_uint32 AddComposite(const CInputVector<sCompositeConstituent> & CompositeBuffer);
	inline void RemoveComposite(const Lib3MF_uint32 nPropertyID);
	inline void GetComposite(const Lib3MF_uint32 nPropertyID, std::vector<sCompositeConstituent> & CompositeBuffer);
};
	
/*************************************************************************************************************************
 Class CMultiPropertyGroup 
**************************************************************************************************************************/
class CMultiPropertyGroup : public CResource {
public:
	
	/**
	* CMultiPropertyGroup::CMultiPropertyGroup - Constructor for MultiPropertyGroup class.
	*/
	CMultiPropertyGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_uint32 GetCount();
	inline void GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline Lib3MF_uint32 AddMultiProperty(const CInputVector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline void SetMultiProperty(const Lib3MF_uint32 nPropertyID, const CInputVector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline void GetMultiProperty(const Lib3MF_uint32 nPropertyID, std::vector<Lib3MF_uint32> & PropertyIDsBuffer);
	inline void RemoveMultiProperty(const Lib3MF_uint32 nPropertyID);
	inline Lib3MF_uint32 GetLayerCount();
	inline Lib3MF_uint32 AddLayer(const sMultiPropertyLayer & TheLayer);
	inline sMultiPropertyLayer GetLayer(const Lib3MF_uint32 nLayerIndex);
	inline void RemoveLayer(const Lib3MF_uint32 nLayerIndex);
};
	
/*************************************************************************************************************************
 Class CAttachment 
**************************************************************************************************************************/
class CAttachment : public CBase {
public:
	
	/**
	* CAttachment::CAttachment - Constructor for Attachment class.
	*/
	CAttachment(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetPath();
	inline void SetPath(const std::string & sPath);
	inline PPackagePart PackagePart();
	inline std::string GetRelationShipType();
	inline void SetRelationShipType(const std::string & sPath);
	inline void WriteToFile(const std::string & sFileName);
	inline void ReadFromFile(const std::string & sFileName);
	inline void ReadFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData);
	inline Lib3MF_uint64 GetStreamSize();
	inline void WriteToBuffer(std::vector<Lib3MF_uint8> & BufferBuffer);
	inline void ReadFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer);
};
	
/*************************************************************************************************************************
 Class CTexture2D 
**************************************************************************************************************************/
class CTexture2D : public CResource {
public:
	
	/**
	* CTexture2D::CTexture2D - Constructor for Texture2D class.
	*/
	CTexture2D(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline PAttachment GetAttachment();
	inline void SetAttachment(classParam<CAttachment> pAttachment);
	inline eTextureType GetContentType();
	inline void SetContentType(const eTextureType eContentType);
	inline void GetTileStyleUV(eTextureTileStyle & eTileStyleU, eTextureTileStyle & eTileStyleV);
	inline void SetTileStyleUV(const eTextureTileStyle eTileStyleU, const eTextureTileStyle eTileStyleV);
	inline eTextureFilter GetFilter();
	inline void SetFilter(const eTextureFilter eFilter);
};
	
/*************************************************************************************************************************
 Class CBuildItem 
**************************************************************************************************************************/
class CBuildItem : public CBase {
public:
	
	/**
	* CBuildItem::CBuildItem - Constructor for BuildItem class.
	*/
	CBuildItem(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PObject GetObjectResource();
	inline std::string GetUUID(bool & bHasUUID);
	inline void SetUUID(const std::string & sUUID);
	inline Lib3MF_uint32 GetObjectResourceID();
	inline bool HasObjectTransform();
	inline sTransform GetObjectTransform();
	inline void SetObjectTransform(const sTransform & Transform);
	inline std::string GetPartNumber();
	inline void SetPartNumber(const std::string & sSetPartnumber);
	inline PMetaDataGroup GetMetaDataGroup();
	inline sBox GetOutbox();
};
	
/*************************************************************************************************************************
 Class CBuildItemIterator 
**************************************************************************************************************************/
class CBuildItemIterator : public CBase {
public:
	
	/**
	* CBuildItemIterator::CBuildItemIterator - Constructor for BuildItemIterator class.
	*/
	CBuildItemIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBuildItem GetCurrent();
	inline PBuildItemIterator Clone();
	inline Lib3MF_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CSlice 
**************************************************************************************************************************/
class CSlice : public CBase {
public:
	
	/**
	* CSlice::CSlice - Constructor for Slice class.
	*/
	CSlice(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetVertices(const CInputVector<sPosition2D> & VerticesBuffer);
	inline void GetVertices(std::vector<sPosition2D> & VerticesBuffer);
	inline Lib3MF_uint64 GetVertexCount();
	inline Lib3MF_uint64 AddPolygon(const CInputVector<Lib3MF_uint32> & IndicesBuffer);
	inline Lib3MF_uint64 GetPolygonCount();
	inline void SetPolygonIndices(const Lib3MF_uint64 nIndex, const CInputVector<Lib3MF_uint32> & IndicesBuffer);
	inline void GetPolygonIndices(const Lib3MF_uint64 nIndex, std::vector<Lib3MF_uint32> & IndicesBuffer);
	inline Lib3MF_uint64 GetPolygonIndexCount(const Lib3MF_uint64 nIndex);
	inline Lib3MF_double GetZTop();
};
	
/*************************************************************************************************************************
 Class CToolpathProfile 
**************************************************************************************************************************/
class CToolpathProfile : public CBase {
public:
	
	/**
	* CToolpathProfile::CToolpathProfile - Constructor for ToolpathProfile class.
	*/
	CToolpathProfile(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline Lib3MF_uint32 GetParameterCount();
	inline std::string GetParameterName(const Lib3MF_uint32 nIndex);
	inline std::string GetParameterNameSpace(const Lib3MF_uint32 nIndex);
	inline bool HasParameterValue(const std::string & sNameSpaceName, const std::string & sValueName);
	inline std::string GetParameterValue(const std::string & sNameSpaceName, const std::string & sValueName);
	inline std::string GetParameterValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const std::string & sDefaultValue);
	inline Lib3MF_double GetParameterDoubleValue(const std::string & sNameSpaceName, const std::string & sValueName);
	inline Lib3MF_double GetParameterDoubleValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_double dDefaultValue);
	inline Lib3MF_int64 GetParameterIntegerValue(const std::string & sNameSpaceName, const std::string & sValueName);
	inline Lib3MF_int64 GetParameterIntegerValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_int64 nDefaultValue);
	inline bool GetParameterBoolValue(const std::string & sNameSpaceName, const std::string & sValueName);
	inline bool GetParameterBoolValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const bool bDefaultValue);
	inline void SetName(const std::string & sName);
	inline void SetParameterValue(const std::string & sNameSpaceName, const std::string & sValueName, const std::string & sValue);
	inline void SetParameterDoubleValue(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_double dValue);
	inline void SetParameterIntegerValue(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_int64 nValue);
	inline void SetParameterBoolValue(const std::string & sNameSpaceName, const std::string & sValueName, const bool bValue);
};
	
/*************************************************************************************************************************
 Class CToolpathLayerReader 
**************************************************************************************************************************/
class CToolpathLayerReader : public CBase {
public:
	
	/**
	* CToolpathLayerReader::CToolpathLayerReader - Constructor for ToolpathLayerReader class.
	*/
	CToolpathLayerReader(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetLayerDataUUID();
	inline Lib3MF_uint32 GetSegmentCount();
	inline void GetSegmentInfo(const Lib3MF_uint32 nIndex, eToolpathSegmentType & eType, Lib3MF_uint32 & nPointCount);
	inline PToolpathProfile GetSegmentProfile(const Lib3MF_uint32 nIndex);
	inline std::string GetSegmentProfileUUID(const Lib3MF_uint32 nIndex);
	inline PBuildItem GetSegmentPart(const Lib3MF_uint32 nIndex);
	inline std::string GetSegmentPartUUID(const Lib3MF_uint32 nIndex);
	inline void GetSegmentPointData(const Lib3MF_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer);
	inline void FindAttributeInfoByName(const std::string & sNameSpace, const std::string & sAttributeName, Lib3MF_uint32 & nID, eToolpathAttributeType & eAttributeType);
	inline Lib3MF_uint32 FindAttributeIDByName(const std::string & sNameSpace, const std::string & sAttributeName);
	inline eToolpathAttributeType FindAttributeValueByName(const std::string & sNameSpace, const std::string & sAttributeName);
	inline Lib3MF_int64 GetSegmentIntegerAttributeByID(const Lib3MF_uint32 nIndex, const Lib3MF_uint32 nID);
	inline Lib3MF_int64 GetSegmentIntegerAttributeByName(const Lib3MF_uint32 nIndex, const std::string & sNameSpace, const std::string & sAttributeName);
	inline Lib3MF_double GetSegmentDoubleAttributeByID(const Lib3MF_uint32 nIndex, const Lib3MF_uint32 nID);
	inline Lib3MF_double GetSegmentDoubleAttributeByName(const Lib3MF_uint32 nIndex, const std::string & sNameSpace, const std::string & sAttributeName);
	inline Lib3MF_uint32 GetCustomDataCount();
	inline PCustomDOMTree GetCustomData(const Lib3MF_uint32 nIndex);
	inline void GetCustomDataName(const Lib3MF_uint32 nIndex, std::string & sNameSpace, std::string & sDataName);
};
	
/*************************************************************************************************************************
 Class CToolpathLayerData 
**************************************************************************************************************************/
class CToolpathLayerData : public CBase {
public:
	
	/**
	* CToolpathLayerData::CToolpathLayerData - Constructor for ToolpathLayerData class.
	*/
	CToolpathLayerData(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetLayerDataUUID();
	inline Lib3MF_uint32 RegisterProfile(classParam<CToolpathProfile> pProfile);
	inline Lib3MF_uint32 RegisterBuildItem(classParam<CBuildItem> pBuildItem);
	inline void SetSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const std::string & sValue);
	inline void ClearSegmentAttributes();
	inline void WriteHatchData(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer);
	inline void WriteLoop(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer);
	inline void WritePolyline(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer);
	inline PCustomDOMTree AddCustomData(const std::string & sNameSpace, const std::string & sDataName);
	inline void Finish();
};
	
/*************************************************************************************************************************
 Class CToolpath 
**************************************************************************************************************************/
class CToolpath : public CResource {
public:
	
	/**
	* CToolpath::CToolpath - Constructor for Toolpath class.
	*/
	CToolpath(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_double GetUnits();
	inline Lib3MF_uint32 GetLayerCount();
	inline Lib3MF_uint32 GetProfileCount();
	inline PToolpathLayerData AddLayer(const Lib3MF_uint32 nZMax, const std::string & sPath, classParam<CWriter> pModelWriter);
	inline PAttachment GetLayerAttachment(const Lib3MF_uint32 nIndex);
	inline PToolpathLayerReader ReadLayerData(const Lib3MF_uint32 nIndex);
	inline std::string GetLayerPath(const Lib3MF_uint32 nIndex);
	inline Lib3MF_uint32 GetLayerZMax(const Lib3MF_uint32 nIndex);
	inline Lib3MF_uint32 GetLayerZ(const Lib3MF_uint32 nLayerIndex);
	inline PToolpathProfile AddProfile(const std::string & sName);
	inline PToolpathProfile GetProfile(const Lib3MF_uint32 nProfileIndex);
	inline PToolpathProfile GetProfileUUID(const std::string & sProfileUUID);
	inline Lib3MF_uint32 GetCustomDataCount();
	inline PCustomDOMTree GetCustomData(const Lib3MF_uint32 nIndex);
	inline void GetCustomDataName(const Lib3MF_uint32 nIndex, std::string & sNameSpace, std::string & sDataName);
	inline bool HasUniqueCustomData(const std::string & sNameSpace, const std::string & sDataName);
	inline PCustomDOMTree FindUniqueCustomData(const std::string & sNameSpace, const std::string & sDataName);
	inline PCustomDOMTree AddCustomData(const std::string & sNameSpace, const std::string & sDataName);
	inline Lib3MF_uint32 ClearCustomData();
	inline bool DeleteCustomData(classParam<CCustomDOMTree> pData);
	inline void RegisterCustomIntegerAttribute(const std::string & sNameSpace, const std::string & sAttributeName);
	inline void RegisterCustomDoubleAttribute(const std::string & sNameSpace, const std::string & sAttributeName);
};
	
/*************************************************************************************************************************
 Class CToolpathIterator 
**************************************************************************************************************************/
class CToolpathIterator : public CResourceIterator {
public:
	
	/**
	* CToolpathIterator::CToolpathIterator - Constructor for ToolpathIterator class.
	*/
	CToolpathIterator(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResourceIterator(pWrapper, pHandle)
	{
	}
	
	inline PToolpath GetCurrentToolpath();
};
	
/*************************************************************************************************************************
 Class CSliceStack 
**************************************************************************************************************************/
class CSliceStack : public CResource {
public:
	
	/**
	* CSliceStack::CSliceStack - Constructor for SliceStack class.
	*/
	CSliceStack(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CResource(pWrapper, pHandle)
	{
	}
	
	inline Lib3MF_double GetBottomZ();
	inline Lib3MF_uint64 GetSliceCount();
	inline PSlice GetSlice(const Lib3MF_uint64 nSliceIndex);
	inline PSlice AddSlice(const Lib3MF_double dZTop);
	inline Lib3MF_uint64 GetSliceRefCount();
	inline void AddSliceStackReference(classParam<CSliceStack> pTheSliceStack);
	inline PSliceStack GetSliceStackReference(const Lib3MF_uint64 nSliceRefIndex);
	inline void CollapseSliceReferences();
	inline void SetOwnPath(const std::string & sPath);
	inline std::string GetOwnPath();
};
	
/*************************************************************************************************************************
 Class CConsumer 
**************************************************************************************************************************/
class CConsumer : public CBase {
public:
	
	/**
	* CConsumer::CConsumer - Constructor for Consumer class.
	*/
	CConsumer(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetConsumerID();
	inline std::string GetKeyID();
	inline std::string GetKeyValue();
};
	
/*************************************************************************************************************************
 Class CAccessRight 
**************************************************************************************************************************/
class CAccessRight : public CBase {
public:
	
	/**
	* CAccessRight::CAccessRight - Constructor for AccessRight class.
	*/
	CAccessRight(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PConsumer GetConsumer();
	inline eWrappingAlgorithm GetWrappingAlgorithm();
	inline eMgfAlgorithm GetMgfAlgorithm();
	inline eDigestMethod GetDigestMethod();
};
	
/*************************************************************************************************************************
 Class CContentEncryptionParams 
**************************************************************************************************************************/
class CContentEncryptionParams : public CBase {
public:
	
	/**
	* CContentEncryptionParams::CContentEncryptionParams - Constructor for ContentEncryptionParams class.
	*/
	CContentEncryptionParams(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline eEncryptionAlgorithm GetEncryptionAlgorithm();
	inline void GetKey(std::vector<Lib3MF_uint8> & ByteDataBuffer);
	inline void GetInitializationVector(std::vector<Lib3MF_uint8> & ByteDataBuffer);
	inline void GetAuthenticationTag(std::vector<Lib3MF_uint8> & ByteDataBuffer);
	inline void SetAuthenticationTag(const CInputVector<Lib3MF_uint8> & ByteDataBuffer);
	inline void GetAdditionalAuthenticationData(std::vector<Lib3MF_uint8> & ByteDataBuffer);
	inline Lib3MF_uint64 GetDescriptor();
	inline std::string GetKeyUUID();
};
	
/*************************************************************************************************************************
 Class CResourceData 
**************************************************************************************************************************/
class CResourceData : public CBase {
public:
	
	/**
	* CResourceData::CResourceData - Constructor for ResourceData class.
	*/
	CResourceData(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PPackagePart GetPath();
	inline eEncryptionAlgorithm GetEncryptionAlgorithm();
	inline eCompression GetCompression();
	inline void GetAdditionalAuthenticationData(std::vector<Lib3MF_uint8> & ByteDataBuffer);
};
	
/*************************************************************************************************************************
 Class CResourceDataGroup 
**************************************************************************************************************************/
class CResourceDataGroup : public CBase {
public:
	
	/**
	* CResourceDataGroup::CResourceDataGroup - Constructor for ResourceDataGroup class.
	*/
	CResourceDataGroup(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetKeyUUID();
	inline PAccessRight AddAccessRight(classParam<CConsumer> pConsumer, const eWrappingAlgorithm eWrappingAlgorithm, const eMgfAlgorithm eMgfAlgorithm, const eDigestMethod eDigestMethod);
	inline PAccessRight FindAccessRightByConsumer(classParam<CConsumer> pConsumer);
	inline void RemoveAccessRight(classParam<CConsumer> pConsumer);
};
	
/*************************************************************************************************************************
 Class CKeyStore 
**************************************************************************************************************************/
class CKeyStore : public CBase {
public:
	
	/**
	* CKeyStore::CKeyStore - Constructor for KeyStore class.
	*/
	CKeyStore(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PConsumer AddConsumer(const std::string & sConsumerID, const std::string & sKeyID, const std::string & sKeyValue);
	inline Lib3MF_uint64 GetConsumerCount();
	inline PConsumer GetConsumer(const Lib3MF_uint64 nConsumerIndex);
	inline void RemoveConsumer(classParam<CConsumer> pConsumer);
	inline PConsumer FindConsumer(const std::string & sConsumerID);
	inline Lib3MF_uint64 GetResourceDataGroupCount();
	inline PResourceDataGroup AddResourceDataGroup();
	inline PResourceDataGroup GetResourceDataGroup(const Lib3MF_uint64 nResourceDataIndex);
	inline void RemoveResourceDataGroup(classParam<CResourceDataGroup> pResourceDataGroup);
	inline PResourceDataGroup FindResourceDataGroup(classParam<CPackagePart> pPartPath);
	inline PResourceData AddResourceData(classParam<CResourceDataGroup> pResourceDataGroup, classParam<CPackagePart> pPartPath, const eEncryptionAlgorithm eAlgorithm, const eCompression eCompression, const CInputVector<Lib3MF_uint8> & AdditionalAuthenticationDataBuffer);
	inline void RemoveResourceData(classParam<CResourceData> pResourceData);
	inline PResourceData FindResourceData(classParam<CPackagePart> pResourcePath);
	inline Lib3MF_uint64 GetResourceDataCount();
	inline PResourceData GetResourceData(const Lib3MF_uint64 nResourceDataIndex);
	inline std::string GetUUID(bool & bHasUUID);
	inline void SetUUID(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CModel 
**************************************************************************************************************************/
class CModel : public CBase {
public:
	
	/**
	* CModel::CModel - Constructor for Model class.
	*/
	CModel(CWrapper* pWrapper, Lib3MFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PPackagePart RootModelPart();
	inline PPackagePart FindOrCreatePackagePart(const std::string & sAbsolutePath);
	inline void SetUnit(const eModelUnit eUnit);
	inline eModelUnit GetUnit();
	inline std::string GetLanguage();
	inline void SetLanguage(const std::string & sLanguage);
	inline PWriter QueryWriter(const std::string & sWriterClass);
	inline PReader QueryReader(const std::string & sReaderClass);
	inline PResource GetResourceByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PTexture2D GetTexture2DByID(const Lib3MF_uint32 nUniqueResourceID);
	inline ePropertyType GetPropertyTypeByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PBaseMaterialGroup GetBaseMaterialGroupByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PTexture2DGroup GetTexture2DGroupByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PCompositeMaterials GetCompositeMaterialsByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PMultiPropertyGroup GetMultiPropertyGroupByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PMeshObject GetMeshObjectByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PComponentsObject GetComponentsObjectByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PColorGroup GetColorGroupByID(const Lib3MF_uint32 nUniqueResourceID);
	inline PSliceStack GetSliceStackByID(const Lib3MF_uint32 nUniqueResourceID);
	inline std::string GetBuildUUID(bool & bHasUUID);
	inline void SetBuildUUID(const std::string & sUUID);
	inline PBuildItemIterator GetBuildItems();
	inline sBox GetOutbox();
	inline PResourceIterator GetResources();
	inline PObjectIterator GetObjects();
	inline PMeshObjectIterator GetMeshObjects();
	inline PComponentsObjectIterator GetComponentsObjects();
	inline PTexture2DIterator GetTexture2Ds();
	inline PBaseMaterialGroupIterator GetBaseMaterialGroups();
	inline PColorGroupIterator GetColorGroups();
	inline PTexture2DGroupIterator GetTexture2DGroups();
	inline PCompositeMaterialsIterator GetCompositeMaterials();
	inline PMultiPropertyGroupIterator GetMultiPropertyGroups();
	inline PToolpathIterator GetToolpaths();
	inline PSliceStackIterator GetSliceStacks();
	inline PModel MergeToModel();
	inline PMeshObject AddMeshObject();
	inline PComponentsObject AddComponentsObject();
	inline PSliceStack AddSliceStack(const Lib3MF_double dZBottom);
	inline PTexture2D AddTexture2DFromAttachment(classParam<CAttachment> pTextureAttachment);
	inline PBaseMaterialGroup AddBaseMaterialGroup();
	inline PColorGroup AddColorGroup();
	inline PTexture2DGroup AddTexture2DGroup(classParam<CTexture2D> pTexture2DInstance);
	inline PCompositeMaterials AddCompositeMaterials(classParam<CBaseMaterialGroup> pBaseMaterialGroupInstance);
	inline PMultiPropertyGroup AddMultiPropertyGroup();
	inline PBuildItem AddBuildItem(classParam<CObject> pObject, const sTransform & Transform);
	inline void RemoveBuildItem(classParam<CBuildItem> pBuildItemInstance);
	inline PToolpath AddToolpath(const Lib3MF_double dUnitFactor);
	inline PMetaDataGroup GetMetaDataGroup();
	inline PAttachment AddAttachment(const std::string & sURI, const std::string & sRelationShipType);
	inline void RemoveAttachment(classParam<CAttachment> pAttachmentInstance);
	inline PAttachment GetAttachment(const Lib3MF_uint32 nIndex);
	inline PAttachment FindAttachment(const std::string & sURI);
	inline Lib3MF_uint32 GetAttachmentCount();
	inline bool HasPackageThumbnailAttachment();
	inline PAttachment CreatePackageThumbnailAttachment();
	inline PAttachment GetPackageThumbnailAttachment();
	inline void RemovePackageThumbnailAttachment();
	inline void AddCustomContentType(const std::string & sExtension, const std::string & sContentType);
	inline void RemoveCustomContentType(const std::string & sExtension);
	inline void SetRandomNumberCallback(const RandomNumberCallback pTheCallback, const Lib3MF_pvoid pUserData);
	inline PKeyStore GetKeyStore();
	inline PPersistentReaderSource CreatePersistentSourceFromFile(const std::string & sFilename);
	inline PPersistentReaderSource CreatePersistentSourceFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer);
	inline PPersistentReaderSource CreatePersistentSourceFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData);
};

/*************************************************************************************************************************
 RTTI: Polymorphic Factory implementation
**************************************************************************************************************************/

/**
* IMPORTANT: PolymorphicFactory method should not be used by application directly.
*            It's designed to be used on Lib3MFHandle object only once.
*            If it's used on any existing object as a form of dynamic cast then
*            CWrapper::AcquireInstance(CBase object) must be called after instantiating new object.
*            This is important to keep reference count matching between application and library sides.
*/
inline CBase* CWrapper::polymorphicFactory(Lib3MFHandle pHandle)
{
	Lib3MF_uint64 resultClassTypeId = 0;
	CheckError(nullptr, m_WrapperTable.m_Base_ClassTypeId(pHandle, &resultClassTypeId));
	switch(resultClassTypeId) {
		case 0x856632D0BAF1D8B7UL: return new CBase(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Base"
		case 0xA0EB26254C981E1AUL: return new CBinaryStream(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BinaryStream"
		case 0xE76F642F363FD7E9UL: return new CWriter(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Writer"
		case 0xBE46884397CE1319UL: return new CPersistentReaderSource(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::PersistentReaderSource"
		case 0x2D86831DA59FBE72UL: return new CReader(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Reader"
		case 0x0E55A826D377483EUL: return new CPackagePart(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::PackagePart"
		case 0xDFE3889D1B269CBBUL: return new CResource(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Resource"
		case 0x460F3515E2621DBEUL: return new CResourceIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ResourceIterator"
		case 0xEA18C54DBD42B5F6UL: return new CCustomXMLAttribute(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CustomXMLAttribute"
		case 0x26B5AD02041EDF96UL: return new CCustomXMLNode(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CustomXMLNode"
		case 0x8C4B47C97D310E89UL: return new CCustomXMLNodes(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CustomXMLNodes"
		case 0x5E0CF70A6DB6256AUL: return new CCustomDOMTree(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CustomDOMTree"
		case 0x69684DB99FA813F6UL: return new CSliceStackIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::SliceStackIterator"
		case 0xDE92510BD2112288UL: return new CObjectIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ObjectIterator"
		case 0xF4196034E2B9FDE6UL: return new CMeshObjectIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MeshObjectIterator"
		case 0x564DE4217ED7614AUL: return new CComponentsObjectIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ComponentsObjectIterator"
		case 0x4BD32B4870FFC03BUL: return new CTexture2DIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Texture2DIterator"
		case 0x65E6EDD9362C79CBUL: return new CBaseMaterialGroupIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BaseMaterialGroupIterator"
		case 0x10274A1757C729C0UL: return new CColorGroupIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ColorGroupIterator"
		case 0x30D55F4DB88FE0CAUL: return new CTexture2DGroupIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Texture2DGroupIterator"
		case 0xA99CC6C3F70FB6F9UL: return new CCompositeMaterialsIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CompositeMaterialsIterator"
		case 0xC2BDF5D8CBBDB1F0UL: return new CMultiPropertyGroupIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MultiPropertyGroupIterator"
		case 0xD17716D063DE2C22UL: return new CMetaData(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MetaData"
		case 0x0C3B85369E9B25D3UL: return new CMetaDataGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MetaDataGroup"
		case 0x2DA2136F577A779CUL: return new CObject(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Object"
		case 0x3B3A6DC6EC610497UL: return new CMeshObject(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MeshObject"
		case 0x63B3B461B30B4BA5UL: return new CBeamLattice(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BeamLattice"
		case 0x4ECDB6A6F69F2BEBUL: return new CComponent(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Component"
		case 0x6522CF04EB283FEDUL: return new CComponentsObject(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ComponentsObject"
		case 0x30CCDBE90E00B55BUL: return new CBeamSet(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BeamSet"
		case 0xB27D4656E16609FAUL: return new CBaseMaterialGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BaseMaterialGroup"
		case 0xD085FB2E49CDB5B1UL: return new CColorGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ColorGroup"
		case 0xBC1208397E37055DUL: return new CTexture2DGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Texture2DGroup"
		case 0xCE16224D688B86F2UL: return new CCompositeMaterials(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::CompositeMaterials"
		case 0xB989E02E43158FE6UL: return new CMultiPropertyGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::MultiPropertyGroup"
		case 0x8CE7A1191A63A35DUL: return new CAttachment(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Attachment"
		case 0xE0441CF976B36319UL: return new CTexture2D(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Texture2D"
		case 0x68FB2D5FFC4BA12AUL: return new CBuildItem(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BuildItem"
		case 0xA7D21BD364910860UL: return new CBuildItemIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::BuildItemIterator"
		case 0x2198BCF4D8DF9C40UL: return new CSlice(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Slice"
		case 0xC869620B90242CA7UL: return new CToolpathProfile(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ToolpathProfile"
		case 0x28DD7D3718F0616EUL: return new CToolpathLayerReader(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ToolpathLayerReader"
		case 0x28C0E70CC44F931AUL: return new CToolpathLayerData(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ToolpathLayerData"
		case 0xF0AAB2C814D9FFB1UL: return new CToolpath(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Toolpath"
		case 0xD0F24425A07F2A81UL: return new CToolpathIterator(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ToolpathIterator"
		case 0x6594B031B6096238UL: return new CSliceStack(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::SliceStack"
		case 0xD9E46D5E6D8118EEUL: return new CConsumer(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Consumer"
		case 0x385C42FC5609498AUL: return new CAccessRight(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::AccessRight"
		case 0x7FB36B91D4CE4671UL: return new CContentEncryptionParams(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ContentEncryptionParams"
		case 0x1A47A5E258E22EF9UL: return new CResourceData(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ResourceData"
		case 0xD59067227E428AA4UL: return new CResourceDataGroup(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::ResourceDataGroup"
		case 0x1CC9E0CC082253C6UL: return new CKeyStore(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::KeyStore"
		case 0x5A8164ECEDB03F09UL: return new CModel(this, pHandle); break; // First 64 bits of SHA1 of a string: "Lib3MF::Model"
	}
	return new CBase(this, pHandle);
}
	
	/**
	* CWrapper::GetLibraryVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetLibraryVersion(Lib3MF_uint32 & nMajor, Lib3MF_uint32 & nMinor, Lib3MF_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetLibraryVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetPrereleaseInformation - retrieves prerelease information of this library.
	* @return Does the library provide prerelease version?
	* @param[out] sPrereleaseInfo - retrieves prerelease information of this library.
	*/
	inline bool CWrapper::GetPrereleaseInformation(std::string & sPrereleaseInfo)
	{
		bool resultHasPrereleaseInfo = 0;
		Lib3MF_uint32 bytesNeededPrereleaseInfo = 0;
		Lib3MF_uint32 bytesWrittenPrereleaseInfo = 0;
		CheckError(nullptr,m_WrapperTable.m_GetPrereleaseInformation(&resultHasPrereleaseInfo, 0, &bytesNeededPrereleaseInfo, nullptr));
		std::vector<char> bufferPrereleaseInfo(bytesNeededPrereleaseInfo);
		CheckError(nullptr,m_WrapperTable.m_GetPrereleaseInformation(&resultHasPrereleaseInfo, bytesNeededPrereleaseInfo, &bytesWrittenPrereleaseInfo, &bufferPrereleaseInfo[0]));
		sPrereleaseInfo = std::string(&bufferPrereleaseInfo[0]);
		
		return resultHasPrereleaseInfo;
	}
	
	/**
	* CWrapper::GetBuildInformation - retrieves build information of this library.
	* @return Does the library provide build version?
	* @param[out] sBuildInformation - retrieves build information of this library.
	*/
	inline bool CWrapper::GetBuildInformation(std::string & sBuildInformation)
	{
		bool resultHasBuildInfo = 0;
		Lib3MF_uint32 bytesNeededBuildInformation = 0;
		Lib3MF_uint32 bytesWrittenBuildInformation = 0;
		CheckError(nullptr,m_WrapperTable.m_GetBuildInformation(&resultHasBuildInfo, 0, &bytesNeededBuildInformation, nullptr));
		std::vector<char> bufferBuildInformation(bytesNeededBuildInformation);
		CheckError(nullptr,m_WrapperTable.m_GetBuildInformation(&resultHasBuildInfo, bytesNeededBuildInformation, &bytesWrittenBuildInformation, &bufferBuildInformation[0]));
		sBuildInformation = std::string(&bufferBuildInformation[0]);
		
		return resultHasBuildInfo;
	}
	
	/**
	* CWrapper::GetSpecificationVersion - retrieves whether a specification is supported, and if so, which version.
	* @param[in] sSpecificationURL - URL of extension to check
	* @param[out] bIsSupported - returns whether this specification is supported
	* @param[out] nMajor - returns the major version of the extension (if IsSupported)
	* @param[out] nMinor - returns the minor version of the extension (if IsSupported)
	* @param[out] nMicro - returns the micro version of the extension (if IsSupported)
	*/
	inline void CWrapper::GetSpecificationVersion(const std::string & sSpecificationURL, bool & bIsSupported, Lib3MF_uint32 & nMajor, Lib3MF_uint32 & nMinor, Lib3MF_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetSpecificationVersion(sSpecificationURL.c_str(), &bIsSupported, &nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::CreateModel - creates an empty model instance.
	* @return returns an empty model instance
	*/
	inline PModel CWrapper::CreateModel()
	{
		Lib3MFHandle hModel = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateModel(&hModel));
		
		if (!hModel) {
			CheckError(nullptr,LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CModel>(dynamic_cast<CModel*>(this->polymorphicFactory(hModel)));
	}
	
	/**
	* CWrapper::Release - releases shared ownership of an object instance
	* @param[in] pInstance - the object instance to release
	*/
	inline void CWrapper::Release(classParam<CBase> pInstance)
	{
		Lib3MFHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_Release(hInstance));
	}
	
	/**
	* CWrapper::Acquire - acquires shared ownership of an object instance
	* @param[in] pInstance - the object instance to acquire
	*/
	inline void CWrapper::Acquire(classParam<CBase> pInstance)
	{
		Lib3MFHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_Acquire(hInstance));
	}
	
	/**
	* CWrapper::SetJournal - Sets the journal file path
	* @param[in] sJournalPath - File name of the journal file
	*/
	inline void CWrapper::SetJournal(const std::string & sJournalPath)
	{
		CheckError(nullptr,m_WrapperTable.m_SetJournal(sJournalPath.c_str()));
	}
	
	/**
	* CWrapper::GetLastError - Retrieves the last error string of an instance
	* @param[in] pInstance - Object where the error occured.
	* @param[out] sLastErrorString - Last Error String
	* @return Returns if the instance has a last error.
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sLastErrorString)
	{
		Lib3MFHandle hInstance = pInstance.GetHandle();
		Lib3MF_uint32 bytesNeededLastErrorString = 0;
		Lib3MF_uint32 bytesWrittenLastErrorString = 0;
		bool resultHasLastError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededLastErrorString, nullptr, &resultHasLastError));
		std::vector<char> bufferLastErrorString(bytesNeededLastErrorString);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededLastErrorString, &bytesWrittenLastErrorString, &bufferLastErrorString[0], &resultHasLastError));
		sLastErrorString = std::string(&bufferLastErrorString[0]);
		
		return resultHasLastError;
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline Lib3MF_pvoid CWrapper::GetSymbolLookupMethod()
	{
		Lib3MF_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::RetrieveProgressMessage - Return an English text for a progress identifier.|Note: this is the only function you can call from your callback function.
	* @param[in] eTheProgressIdentifier - the progress identifier that is passed to the callback function
	* @param[out] sProgressMessage - English text for the progress identifier
	*/
	inline void CWrapper::RetrieveProgressMessage(const eProgressIdentifier eTheProgressIdentifier, std::string & sProgressMessage)
	{
		Lib3MF_uint32 bytesNeededProgressMessage = 0;
		Lib3MF_uint32 bytesWrittenProgressMessage = 0;
		CheckError(nullptr,m_WrapperTable.m_RetrieveProgressMessage(eTheProgressIdentifier, 0, &bytesNeededProgressMessage, nullptr));
		std::vector<char> bufferProgressMessage(bytesNeededProgressMessage);
		CheckError(nullptr,m_WrapperTable.m_RetrieveProgressMessage(eTheProgressIdentifier, bytesNeededProgressMessage, &bytesWrittenProgressMessage, &bufferProgressMessage[0]));
		sProgressMessage = std::string(&bufferProgressMessage[0]);
	}
	
	/**
	* CWrapper::RGBAToColor - Creates a Color from uint8 RGBA values
	* @param[in] nRed - Red value of color (0-255)
	* @param[in] nGreen - Green value of color (0-255)
	* @param[in] nBlue - Blue value of color (0-255)
	* @param[in] nAlpha - Alpha value of color (0-255)
	* @return Assembled color
	*/
	inline sColor CWrapper::RGBAToColor(const Lib3MF_uint8 nRed, const Lib3MF_uint8 nGreen, const Lib3MF_uint8 nBlue, const Lib3MF_uint8 nAlpha)
	{
		sColor resultTheColor;
		CheckError(nullptr,m_WrapperTable.m_RGBAToColor(nRed, nGreen, nBlue, nAlpha, &resultTheColor));
		
		return resultTheColor;
	}
	
	/**
	* CWrapper::FloatRGBAToColor - Creates a Color from uint8 RGBA values
	* @param[in] fRed - Red value of color (0-1)
	* @param[in] fGreen - Green value of color (0-1)
	* @param[in] fBlue - Blue value of color (0-1)
	* @param[in] fAlpha - Alpha value of color (0-1)
	* @return Assembled color
	*/
	inline sColor CWrapper::FloatRGBAToColor(const Lib3MF_single fRed, const Lib3MF_single fGreen, const Lib3MF_single fBlue, const Lib3MF_single fAlpha)
	{
		sColor resultTheColor;
		CheckError(nullptr,m_WrapperTable.m_FloatRGBAToColor(fRed, fGreen, fBlue, fAlpha, &resultTheColor));
		
		return resultTheColor;
	}
	
	/**
	* CWrapper::ColorToRGBA - Calculates uint8-RGBA-values from a Color
	* @param[in] TheColor - Color to handle
	* @param[out] nRed - Red value of color (0-255)
	* @param[out] nGreen - Green value of color (0-255)
	* @param[out] nBlue - Blue value of color (0-255)
	* @param[out] nAlpha - Alpha value of color (0-255)
	*/
	inline void CWrapper::ColorToRGBA(const sColor & TheColor, Lib3MF_uint8 & nRed, Lib3MF_uint8 & nGreen, Lib3MF_uint8 & nBlue, Lib3MF_uint8 & nAlpha)
	{
		CheckError(nullptr,m_WrapperTable.m_ColorToRGBA(&TheColor, &nRed, &nGreen, &nBlue, &nAlpha));
	}
	
	/**
	* CWrapper::ColorToFloatRGBA - Calculates float-RGBA-values from a Color
	* @param[in] TheColor - Color to handle
	* @param[out] fRed - Red value of color (0-1)
	* @param[out] fGreen - Green value of color (0-1)
	* @param[out] fBlue - Blue value of color (0-1)
	* @param[out] fAlpha - Alpha value of color (0-1)
	*/
	inline void CWrapper::ColorToFloatRGBA(const sColor & TheColor, Lib3MF_single & fRed, Lib3MF_single & fGreen, Lib3MF_single & fBlue, Lib3MF_single & fAlpha)
	{
		CheckError(nullptr,m_WrapperTable.m_ColorToFloatRGBA(&TheColor, &fRed, &fGreen, &fBlue, &fAlpha));
	}
	
	/**
	* CWrapper::GetIdentityTransform - Creates an identity transform
	* @return Transformation matrix.
	*/
	inline sTransform CWrapper::GetIdentityTransform()
	{
		sTransform resultTransform;
		CheckError(nullptr,m_WrapperTable.m_GetIdentityTransform(&resultTransform));
		
		return resultTransform;
	}
	
	/**
	* CWrapper::GetUniformScaleTransform - Creates a uniform scale transform
	* @param[in] fFactor - Factor in X, Y and Z
	* @return Transformation matrix.
	*/
	inline sTransform CWrapper::GetUniformScaleTransform(const Lib3MF_single fFactor)
	{
		sTransform resultTransform;
		CheckError(nullptr,m_WrapperTable.m_GetUniformScaleTransform(fFactor, &resultTransform));
		
		return resultTransform;
	}
	
	/**
	* CWrapper::GetScaleTransform - Creates a scale transform
	* @param[in] fFactorX - Factor in X
	* @param[in] fFactorY - Factor in Y
	* @param[in] fFactorZ - Factor in Z
	* @return Transformation matrix.
	*/
	inline sTransform CWrapper::GetScaleTransform(const Lib3MF_single fFactorX, const Lib3MF_single fFactorY, const Lib3MF_single fFactorZ)
	{
		sTransform resultTransform;
		CheckError(nullptr,m_WrapperTable.m_GetScaleTransform(fFactorX, fFactorY, fFactorZ, &resultTransform));
		
		return resultTransform;
	}
	
	/**
	* CWrapper::GetTranslationTransform - Creates an translation transform
	* @param[in] fVectorX - Translation in X
	* @param[in] fVectorY - Translation in Y
	* @param[in] fVectorZ - Translation in Z
	* @return Transformation matrix.
	*/
	inline sTransform CWrapper::GetTranslationTransform(const Lib3MF_single fVectorX, const Lib3MF_single fVectorY, const Lib3MF_single fVectorZ)
	{
		sTransform resultTransform;
		CheckError(nullptr,m_WrapperTable.m_GetTranslationTransform(fVectorX, fVectorY, fVectorZ, &resultTransform));
		
		return resultTransform;
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, Lib3MFResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELib3MFException(nResult, sErrorMessage);
		}
	}
	

	inline Lib3MFResult CWrapper::initWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Base_ClassTypeId = nullptr;
		pWrapperTable->m_BinaryStream_GetBinaryPath = nullptr;
		pWrapperTable->m_BinaryStream_GetIndexPath = nullptr;
		pWrapperTable->m_BinaryStream_GetUUID = nullptr;
		pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression = nullptr;
		pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression = nullptr;
		pWrapperTable->m_BinaryStream_EnableLZMA = nullptr;
		pWrapperTable->m_BinaryStream_DisableLZMA = nullptr;
		pWrapperTable->m_Writer_WriteToFile = nullptr;
		pWrapperTable->m_Writer_GetStreamSize = nullptr;
		pWrapperTable->m_Writer_WriteToBuffer = nullptr;
		pWrapperTable->m_Writer_WriteToCallback = nullptr;
		pWrapperTable->m_Writer_SetProgressCallback = nullptr;
		pWrapperTable->m_Writer_GetDecimalPrecision = nullptr;
		pWrapperTable->m_Writer_SetDecimalPrecision = nullptr;
		pWrapperTable->m_Writer_SetStrictModeActive = nullptr;
		pWrapperTable->m_Writer_GetStrictModeActive = nullptr;
		pWrapperTable->m_Writer_GetWarning = nullptr;
		pWrapperTable->m_Writer_GetWarningCount = nullptr;
		pWrapperTable->m_Writer_AddKeyWrappingCallback = nullptr;
		pWrapperTable->m_Writer_SetContentEncryptionCallback = nullptr;
		pWrapperTable->m_Writer_CreateBinaryStream = nullptr;
		pWrapperTable->m_Writer_AssignBinaryStream = nullptr;
		pWrapperTable->m_Writer_RegisterCustomNamespace = nullptr;
		pWrapperTable->m_PersistentReaderSource_GetSourceType = nullptr;
		pWrapperTable->m_PersistentReaderSource_InvalidateSourceData = nullptr;
		pWrapperTable->m_PersistentReaderSource_SourceDataIsValid = nullptr;
		pWrapperTable->m_Reader_ReadFromPersistentSource = nullptr;
		pWrapperTable->m_Reader_ReadFromFile = nullptr;
		pWrapperTable->m_Reader_ReadFromBuffer = nullptr;
		pWrapperTable->m_Reader_ReadFromCallback = nullptr;
		pWrapperTable->m_Reader_SetProgressCallback = nullptr;
		pWrapperTable->m_Reader_AddRelationToRead = nullptr;
		pWrapperTable->m_Reader_RemoveRelationToRead = nullptr;
		pWrapperTable->m_Reader_SetStrictModeActive = nullptr;
		pWrapperTable->m_Reader_GetStrictModeActive = nullptr;
		pWrapperTable->m_Reader_GetWarning = nullptr;
		pWrapperTable->m_Reader_GetWarningCount = nullptr;
		pWrapperTable->m_Reader_AddKeyWrappingCallback = nullptr;
		pWrapperTable->m_Reader_SetContentEncryptionCallback = nullptr;
		pWrapperTable->m_PackagePart_GetPath = nullptr;
		pWrapperTable->m_PackagePart_SetPath = nullptr;
		pWrapperTable->m_Resource_GetResourceID = nullptr;
		pWrapperTable->m_Resource_GetUniqueResourceID = nullptr;
		pWrapperTable->m_Resource_PackagePart = nullptr;
		pWrapperTable->m_Resource_SetPackagePart = nullptr;
		pWrapperTable->m_Resource_GetModelResourceID = nullptr;
		pWrapperTable->m_ResourceIterator_MoveNext = nullptr;
		pWrapperTable->m_ResourceIterator_MovePrevious = nullptr;
		pWrapperTable->m_ResourceIterator_GetCurrent = nullptr;
		pWrapperTable->m_ResourceIterator_Clone = nullptr;
		pWrapperTable->m_ResourceIterator_Count = nullptr;
		pWrapperTable->m_CustomXMLAttribute_GetName = nullptr;
		pWrapperTable->m_CustomXMLAttribute_GetValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_IsValidInteger = nullptr;
		pWrapperTable->m_CustomXMLAttribute_GetIntegerValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_IsValidDouble = nullptr;
		pWrapperTable->m_CustomXMLAttribute_GetDoubleValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_IsValidBool = nullptr;
		pWrapperTable->m_CustomXMLAttribute_GetBoolValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_SetValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_SetIntegerValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_SetDoubleValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_SetBoolValue = nullptr;
		pWrapperTable->m_CustomXMLAttribute_Remove = nullptr;
		pWrapperTable->m_CustomXMLNode_GetName = nullptr;
		pWrapperTable->m_CustomXMLNode_GetNameSpace = nullptr;
		pWrapperTable->m_CustomXMLNode_GetAttributeCount = nullptr;
		pWrapperTable->m_CustomXMLNode_GetAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_HasAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_FindAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_RemoveAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex = nullptr;
		pWrapperTable->m_CustomXMLNode_AddAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_AddIntegerAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_AddDoubleAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_AddBoolAttribute = nullptr;
		pWrapperTable->m_CustomXMLNode_GetChildren = nullptr;
		pWrapperTable->m_CustomXMLNode_CountChildrenByName = nullptr;
		pWrapperTable->m_CustomXMLNode_GetChildrenByName = nullptr;
		pWrapperTable->m_CustomXMLNode_HasChild = nullptr;
		pWrapperTable->m_CustomXMLNode_HasUniqueChild = nullptr;
		pWrapperTable->m_CustomXMLNode_FindChild = nullptr;
		pWrapperTable->m_CustomXMLNode_AddChild = nullptr;
		pWrapperTable->m_CustomXMLNode_RemoveChild = nullptr;
		pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName = nullptr;
		pWrapperTable->m_CustomXMLNode_Remove = nullptr;
		pWrapperTable->m_CustomXMLNodes_GetNodeCount = nullptr;
		pWrapperTable->m_CustomXMLNodes_GetNode = nullptr;
		pWrapperTable->m_CustomXMLNodes_CountNodesByName = nullptr;
		pWrapperTable->m_CustomXMLNodes_GetNodesByName = nullptr;
		pWrapperTable->m_CustomXMLNodes_HasNode = nullptr;
		pWrapperTable->m_CustomXMLNodes_HasUniqueNode = nullptr;
		pWrapperTable->m_CustomXMLNodes_FindNode = nullptr;
		pWrapperTable->m_CustomDOMTree_GetNameSpace = nullptr;
		pWrapperTable->m_CustomDOMTree_GetRootNode = nullptr;
		pWrapperTable->m_CustomDOMTree_SaveToString = nullptr;
		pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack = nullptr;
		pWrapperTable->m_ObjectIterator_GetCurrentObject = nullptr;
		pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject = nullptr;
		pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject = nullptr;
		pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D = nullptr;
		pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup = nullptr;
		pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup = nullptr;
		pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup = nullptr;
		pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials = nullptr;
		pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup = nullptr;
		pWrapperTable->m_MetaData_GetNameSpace = nullptr;
		pWrapperTable->m_MetaData_SetNameSpace = nullptr;
		pWrapperTable->m_MetaData_GetName = nullptr;
		pWrapperTable->m_MetaData_SetName = nullptr;
		pWrapperTable->m_MetaData_GetKey = nullptr;
		pWrapperTable->m_MetaData_GetMustPreserve = nullptr;
		pWrapperTable->m_MetaData_SetMustPreserve = nullptr;
		pWrapperTable->m_MetaData_GetType = nullptr;
		pWrapperTable->m_MetaData_SetType = nullptr;
		pWrapperTable->m_MetaData_GetValue = nullptr;
		pWrapperTable->m_MetaData_SetValue = nullptr;
		pWrapperTable->m_MetaDataGroup_GetMetaDataCount = nullptr;
		pWrapperTable->m_MetaDataGroup_GetMetaData = nullptr;
		pWrapperTable->m_MetaDataGroup_GetMetaDataByKey = nullptr;
		pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex = nullptr;
		pWrapperTable->m_MetaDataGroup_RemoveMetaData = nullptr;
		pWrapperTable->m_MetaDataGroup_AddMetaData = nullptr;
		pWrapperTable->m_Object_GetType = nullptr;
		pWrapperTable->m_Object_SetType = nullptr;
		pWrapperTable->m_Object_GetName = nullptr;
		pWrapperTable->m_Object_SetName = nullptr;
		pWrapperTable->m_Object_GetPartNumber = nullptr;
		pWrapperTable->m_Object_SetPartNumber = nullptr;
		pWrapperTable->m_Object_IsMeshObject = nullptr;
		pWrapperTable->m_Object_IsComponentsObject = nullptr;
		pWrapperTable->m_Object_IsValid = nullptr;
		pWrapperTable->m_Object_SetAttachmentAsThumbnail = nullptr;
		pWrapperTable->m_Object_GetThumbnailAttachment = nullptr;
		pWrapperTable->m_Object_ClearThumbnailAttachment = nullptr;
		pWrapperTable->m_Object_GetOutbox = nullptr;
		pWrapperTable->m_Object_GetUUID = nullptr;
		pWrapperTable->m_Object_SetUUID = nullptr;
		pWrapperTable->m_Object_GetMetaDataGroup = nullptr;
		pWrapperTable->m_Object_SetSlicesMeshResolution = nullptr;
		pWrapperTable->m_Object_GetSlicesMeshResolution = nullptr;
		pWrapperTable->m_Object_HasSlices = nullptr;
		pWrapperTable->m_Object_ClearSliceStack = nullptr;
		pWrapperTable->m_Object_GetSliceStack = nullptr;
		pWrapperTable->m_Object_AssignSliceStack = nullptr;
		pWrapperTable->m_MeshObject_GetVertexCount = nullptr;
		pWrapperTable->m_MeshObject_GetTriangleCount = nullptr;
		pWrapperTable->m_MeshObject_GetVertex = nullptr;
		pWrapperTable->m_MeshObject_SetVertex = nullptr;
		pWrapperTable->m_MeshObject_AddVertex = nullptr;
		pWrapperTable->m_MeshObject_GetVertices = nullptr;
		pWrapperTable->m_MeshObject_GetTriangle = nullptr;
		pWrapperTable->m_MeshObject_SetTriangle = nullptr;
		pWrapperTable->m_MeshObject_AddTriangle = nullptr;
		pWrapperTable->m_MeshObject_GetTriangleIndices = nullptr;
		pWrapperTable->m_MeshObject_SetObjectLevelProperty = nullptr;
		pWrapperTable->m_MeshObject_GetObjectLevelProperty = nullptr;
		pWrapperTable->m_MeshObject_SetTriangleProperties = nullptr;
		pWrapperTable->m_MeshObject_GetTriangleProperties = nullptr;
		pWrapperTable->m_MeshObject_SetAllTriangleProperties = nullptr;
		pWrapperTable->m_MeshObject_GetAllTriangleProperties = nullptr;
		pWrapperTable->m_MeshObject_ClearAllProperties = nullptr;
		pWrapperTable->m_MeshObject_SetGeometry = nullptr;
		pWrapperTable->m_MeshObject_IsManifoldAndOriented = nullptr;
		pWrapperTable->m_MeshObject_BeamLattice = nullptr;
		pWrapperTable->m_BeamLattice_GetMinLength = nullptr;
		pWrapperTable->m_BeamLattice_SetMinLength = nullptr;
		pWrapperTable->m_BeamLattice_GetClipping = nullptr;
		pWrapperTable->m_BeamLattice_SetClipping = nullptr;
		pWrapperTable->m_BeamLattice_GetRepresentation = nullptr;
		pWrapperTable->m_BeamLattice_SetRepresentation = nullptr;
		pWrapperTable->m_BeamLattice_GetBallOptions = nullptr;
		pWrapperTable->m_BeamLattice_SetBallOptions = nullptr;
		pWrapperTable->m_BeamLattice_GetBeamCount = nullptr;
		pWrapperTable->m_BeamLattice_GetBeam = nullptr;
		pWrapperTable->m_BeamLattice_AddBeam = nullptr;
		pWrapperTable->m_BeamLattice_SetBeam = nullptr;
		pWrapperTable->m_BeamLattice_SetBeams = nullptr;
		pWrapperTable->m_BeamLattice_GetBeams = nullptr;
		pWrapperTable->m_BeamLattice_GetBallCount = nullptr;
		pWrapperTable->m_BeamLattice_GetBall = nullptr;
		pWrapperTable->m_BeamLattice_AddBall = nullptr;
		pWrapperTable->m_BeamLattice_SetBall = nullptr;
		pWrapperTable->m_BeamLattice_SetBalls = nullptr;
		pWrapperTable->m_BeamLattice_GetBalls = nullptr;
		pWrapperTable->m_BeamLattice_GetBeamSetCount = nullptr;
		pWrapperTable->m_BeamLattice_AddBeamSet = nullptr;
		pWrapperTable->m_BeamLattice_GetBeamSet = nullptr;
		pWrapperTable->m_Component_GetObjectResource = nullptr;
		pWrapperTable->m_Component_GetObjectResourceID = nullptr;
		pWrapperTable->m_Component_GetUUID = nullptr;
		pWrapperTable->m_Component_SetUUID = nullptr;
		pWrapperTable->m_Component_HasTransform = nullptr;
		pWrapperTable->m_Component_GetTransform = nullptr;
		pWrapperTable->m_Component_SetTransform = nullptr;
		pWrapperTable->m_ComponentsObject_AddComponent = nullptr;
		pWrapperTable->m_ComponentsObject_GetComponent = nullptr;
		pWrapperTable->m_ComponentsObject_GetComponentCount = nullptr;
		pWrapperTable->m_BeamSet_SetName = nullptr;
		pWrapperTable->m_BeamSet_GetName = nullptr;
		pWrapperTable->m_BeamSet_SetIdentifier = nullptr;
		pWrapperTable->m_BeamSet_GetIdentifier = nullptr;
		pWrapperTable->m_BeamSet_GetReferenceCount = nullptr;
		pWrapperTable->m_BeamSet_SetReferences = nullptr;
		pWrapperTable->m_BeamSet_GetReferences = nullptr;
		pWrapperTable->m_BeamSet_GetBallReferenceCount = nullptr;
		pWrapperTable->m_BeamSet_SetBallReferences = nullptr;
		pWrapperTable->m_BeamSet_GetBallReferences = nullptr;
		pWrapperTable->m_BaseMaterialGroup_GetCount = nullptr;
		pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs = nullptr;
		pWrapperTable->m_BaseMaterialGroup_AddMaterial = nullptr;
		pWrapperTable->m_BaseMaterialGroup_RemoveMaterial = nullptr;
		pWrapperTable->m_BaseMaterialGroup_GetName = nullptr;
		pWrapperTable->m_BaseMaterialGroup_SetName = nullptr;
		pWrapperTable->m_BaseMaterialGroup_SetDisplayColor = nullptr;
		pWrapperTable->m_BaseMaterialGroup_GetDisplayColor = nullptr;
		pWrapperTable->m_ColorGroup_GetCount = nullptr;
		pWrapperTable->m_ColorGroup_GetAllPropertyIDs = nullptr;
		pWrapperTable->m_ColorGroup_AddColor = nullptr;
		pWrapperTable->m_ColorGroup_RemoveColor = nullptr;
		pWrapperTable->m_ColorGroup_SetColor = nullptr;
		pWrapperTable->m_ColorGroup_GetColor = nullptr;
		pWrapperTable->m_Texture2DGroup_GetCount = nullptr;
		pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs = nullptr;
		pWrapperTable->m_Texture2DGroup_AddTex2Coord = nullptr;
		pWrapperTable->m_Texture2DGroup_GetTex2Coord = nullptr;
		pWrapperTable->m_Texture2DGroup_RemoveTex2Coord = nullptr;
		pWrapperTable->m_Texture2DGroup_GetTexture2D = nullptr;
		pWrapperTable->m_CompositeMaterials_GetCount = nullptr;
		pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs = nullptr;
		pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup = nullptr;
		pWrapperTable->m_CompositeMaterials_AddComposite = nullptr;
		pWrapperTable->m_CompositeMaterials_RemoveComposite = nullptr;
		pWrapperTable->m_CompositeMaterials_GetComposite = nullptr;
		pWrapperTable->m_MultiPropertyGroup_GetCount = nullptr;
		pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs = nullptr;
		pWrapperTable->m_MultiPropertyGroup_AddMultiProperty = nullptr;
		pWrapperTable->m_MultiPropertyGroup_SetMultiProperty = nullptr;
		pWrapperTable->m_MultiPropertyGroup_GetMultiProperty = nullptr;
		pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty = nullptr;
		pWrapperTable->m_MultiPropertyGroup_GetLayerCount = nullptr;
		pWrapperTable->m_MultiPropertyGroup_AddLayer = nullptr;
		pWrapperTable->m_MultiPropertyGroup_GetLayer = nullptr;
		pWrapperTable->m_MultiPropertyGroup_RemoveLayer = nullptr;
		pWrapperTable->m_Attachment_GetPath = nullptr;
		pWrapperTable->m_Attachment_SetPath = nullptr;
		pWrapperTable->m_Attachment_PackagePart = nullptr;
		pWrapperTable->m_Attachment_GetRelationShipType = nullptr;
		pWrapperTable->m_Attachment_SetRelationShipType = nullptr;
		pWrapperTable->m_Attachment_WriteToFile = nullptr;
		pWrapperTable->m_Attachment_ReadFromFile = nullptr;
		pWrapperTable->m_Attachment_ReadFromCallback = nullptr;
		pWrapperTable->m_Attachment_GetStreamSize = nullptr;
		pWrapperTable->m_Attachment_WriteToBuffer = nullptr;
		pWrapperTable->m_Attachment_ReadFromBuffer = nullptr;
		pWrapperTable->m_Texture2D_GetAttachment = nullptr;
		pWrapperTable->m_Texture2D_SetAttachment = nullptr;
		pWrapperTable->m_Texture2D_GetContentType = nullptr;
		pWrapperTable->m_Texture2D_SetContentType = nullptr;
		pWrapperTable->m_Texture2D_GetTileStyleUV = nullptr;
		pWrapperTable->m_Texture2D_SetTileStyleUV = nullptr;
		pWrapperTable->m_Texture2D_GetFilter = nullptr;
		pWrapperTable->m_Texture2D_SetFilter = nullptr;
		pWrapperTable->m_BuildItem_GetObjectResource = nullptr;
		pWrapperTable->m_BuildItem_GetUUID = nullptr;
		pWrapperTable->m_BuildItem_SetUUID = nullptr;
		pWrapperTable->m_BuildItem_GetObjectResourceID = nullptr;
		pWrapperTable->m_BuildItem_HasObjectTransform = nullptr;
		pWrapperTable->m_BuildItem_GetObjectTransform = nullptr;
		pWrapperTable->m_BuildItem_SetObjectTransform = nullptr;
		pWrapperTable->m_BuildItem_GetPartNumber = nullptr;
		pWrapperTable->m_BuildItem_SetPartNumber = nullptr;
		pWrapperTable->m_BuildItem_GetMetaDataGroup = nullptr;
		pWrapperTable->m_BuildItem_GetOutbox = nullptr;
		pWrapperTable->m_BuildItemIterator_MoveNext = nullptr;
		pWrapperTable->m_BuildItemIterator_MovePrevious = nullptr;
		pWrapperTable->m_BuildItemIterator_GetCurrent = nullptr;
		pWrapperTable->m_BuildItemIterator_Clone = nullptr;
		pWrapperTable->m_BuildItemIterator_Count = nullptr;
		pWrapperTable->m_Slice_SetVertices = nullptr;
		pWrapperTable->m_Slice_GetVertices = nullptr;
		pWrapperTable->m_Slice_GetVertexCount = nullptr;
		pWrapperTable->m_Slice_AddPolygon = nullptr;
		pWrapperTable->m_Slice_GetPolygonCount = nullptr;
		pWrapperTable->m_Slice_SetPolygonIndices = nullptr;
		pWrapperTable->m_Slice_GetPolygonIndices = nullptr;
		pWrapperTable->m_Slice_GetPolygonIndexCount = nullptr;
		pWrapperTable->m_Slice_GetZTop = nullptr;
		pWrapperTable->m_ToolpathProfile_GetUUID = nullptr;
		pWrapperTable->m_ToolpathProfile_GetName = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterCount = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterName = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterNameSpace = nullptr;
		pWrapperTable->m_ToolpathProfile_HasParameterValue = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterValue = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterValueDef = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValue = nullptr;
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef = nullptr;
		pWrapperTable->m_ToolpathProfile_SetName = nullptr;
		pWrapperTable->m_ToolpathProfile_SetParameterValue = nullptr;
		pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue = nullptr;
		pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue = nullptr;
		pWrapperTable->m_ToolpathProfile_SetParameterBoolValue = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentCount = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPart = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData = nullptr;
		pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName = nullptr;
		pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName = nullptr;
		pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetCustomData = nullptr;
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataName = nullptr;
		pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID = nullptr;
		pWrapperTable->m_ToolpathLayerData_RegisterProfile = nullptr;
		pWrapperTable->m_ToolpathLayerData_RegisterBuildItem = nullptr;
		pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute = nullptr;
		pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes = nullptr;
		pWrapperTable->m_ToolpathLayerData_WriteHatchData = nullptr;
		pWrapperTable->m_ToolpathLayerData_WriteLoop = nullptr;
		pWrapperTable->m_ToolpathLayerData_WritePolyline = nullptr;
		pWrapperTable->m_ToolpathLayerData_AddCustomData = nullptr;
		pWrapperTable->m_ToolpathLayerData_Finish = nullptr;
		pWrapperTable->m_Toolpath_GetUnits = nullptr;
		pWrapperTable->m_Toolpath_GetLayerCount = nullptr;
		pWrapperTable->m_Toolpath_GetProfileCount = nullptr;
		pWrapperTable->m_Toolpath_AddLayer = nullptr;
		pWrapperTable->m_Toolpath_GetLayerAttachment = nullptr;
		pWrapperTable->m_Toolpath_ReadLayerData = nullptr;
		pWrapperTable->m_Toolpath_GetLayerPath = nullptr;
		pWrapperTable->m_Toolpath_GetLayerZMax = nullptr;
		pWrapperTable->m_Toolpath_GetLayerZ = nullptr;
		pWrapperTable->m_Toolpath_AddProfile = nullptr;
		pWrapperTable->m_Toolpath_GetProfile = nullptr;
		pWrapperTable->m_Toolpath_GetProfileUUID = nullptr;
		pWrapperTable->m_Toolpath_GetCustomDataCount = nullptr;
		pWrapperTable->m_Toolpath_GetCustomData = nullptr;
		pWrapperTable->m_Toolpath_GetCustomDataName = nullptr;
		pWrapperTable->m_Toolpath_HasUniqueCustomData = nullptr;
		pWrapperTable->m_Toolpath_FindUniqueCustomData = nullptr;
		pWrapperTable->m_Toolpath_AddCustomData = nullptr;
		pWrapperTable->m_Toolpath_ClearCustomData = nullptr;
		pWrapperTable->m_Toolpath_DeleteCustomData = nullptr;
		pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute = nullptr;
		pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute = nullptr;
		pWrapperTable->m_ToolpathIterator_GetCurrentToolpath = nullptr;
		pWrapperTable->m_SliceStack_GetBottomZ = nullptr;
		pWrapperTable->m_SliceStack_GetSliceCount = nullptr;
		pWrapperTable->m_SliceStack_GetSlice = nullptr;
		pWrapperTable->m_SliceStack_AddSlice = nullptr;
		pWrapperTable->m_SliceStack_GetSliceRefCount = nullptr;
		pWrapperTable->m_SliceStack_AddSliceStackReference = nullptr;
		pWrapperTable->m_SliceStack_GetSliceStackReference = nullptr;
		pWrapperTable->m_SliceStack_CollapseSliceReferences = nullptr;
		pWrapperTable->m_SliceStack_SetOwnPath = nullptr;
		pWrapperTable->m_SliceStack_GetOwnPath = nullptr;
		pWrapperTable->m_Consumer_GetConsumerID = nullptr;
		pWrapperTable->m_Consumer_GetKeyID = nullptr;
		pWrapperTable->m_Consumer_GetKeyValue = nullptr;
		pWrapperTable->m_AccessRight_GetConsumer = nullptr;
		pWrapperTable->m_AccessRight_GetWrappingAlgorithm = nullptr;
		pWrapperTable->m_AccessRight_GetMgfAlgorithm = nullptr;
		pWrapperTable->m_AccessRight_GetDigestMethod = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetKey = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetInitializationVector = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag = nullptr;
		pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetDescriptor = nullptr;
		pWrapperTable->m_ContentEncryptionParams_GetKeyUUID = nullptr;
		pWrapperTable->m_ResourceData_GetPath = nullptr;
		pWrapperTable->m_ResourceData_GetEncryptionAlgorithm = nullptr;
		pWrapperTable->m_ResourceData_GetCompression = nullptr;
		pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData = nullptr;
		pWrapperTable->m_ResourceDataGroup_GetKeyUUID = nullptr;
		pWrapperTable->m_ResourceDataGroup_AddAccessRight = nullptr;
		pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer = nullptr;
		pWrapperTable->m_ResourceDataGroup_RemoveAccessRight = nullptr;
		pWrapperTable->m_KeyStore_AddConsumer = nullptr;
		pWrapperTable->m_KeyStore_GetConsumerCount = nullptr;
		pWrapperTable->m_KeyStore_GetConsumer = nullptr;
		pWrapperTable->m_KeyStore_RemoveConsumer = nullptr;
		pWrapperTable->m_KeyStore_FindConsumer = nullptr;
		pWrapperTable->m_KeyStore_GetResourceDataGroupCount = nullptr;
		pWrapperTable->m_KeyStore_AddResourceDataGroup = nullptr;
		pWrapperTable->m_KeyStore_GetResourceDataGroup = nullptr;
		pWrapperTable->m_KeyStore_RemoveResourceDataGroup = nullptr;
		pWrapperTable->m_KeyStore_FindResourceDataGroup = nullptr;
		pWrapperTable->m_KeyStore_AddResourceData = nullptr;
		pWrapperTable->m_KeyStore_RemoveResourceData = nullptr;
		pWrapperTable->m_KeyStore_FindResourceData = nullptr;
		pWrapperTable->m_KeyStore_GetResourceDataCount = nullptr;
		pWrapperTable->m_KeyStore_GetResourceData = nullptr;
		pWrapperTable->m_KeyStore_GetUUID = nullptr;
		pWrapperTable->m_KeyStore_SetUUID = nullptr;
		pWrapperTable->m_Model_RootModelPart = nullptr;
		pWrapperTable->m_Model_FindOrCreatePackagePart = nullptr;
		pWrapperTable->m_Model_SetUnit = nullptr;
		pWrapperTable->m_Model_GetUnit = nullptr;
		pWrapperTable->m_Model_GetLanguage = nullptr;
		pWrapperTable->m_Model_SetLanguage = nullptr;
		pWrapperTable->m_Model_QueryWriter = nullptr;
		pWrapperTable->m_Model_QueryReader = nullptr;
		pWrapperTable->m_Model_GetResourceByID = nullptr;
		pWrapperTable->m_Model_GetTexture2DByID = nullptr;
		pWrapperTable->m_Model_GetPropertyTypeByID = nullptr;
		pWrapperTable->m_Model_GetBaseMaterialGroupByID = nullptr;
		pWrapperTable->m_Model_GetTexture2DGroupByID = nullptr;
		pWrapperTable->m_Model_GetCompositeMaterialsByID = nullptr;
		pWrapperTable->m_Model_GetMultiPropertyGroupByID = nullptr;
		pWrapperTable->m_Model_GetMeshObjectByID = nullptr;
		pWrapperTable->m_Model_GetComponentsObjectByID = nullptr;
		pWrapperTable->m_Model_GetColorGroupByID = nullptr;
		pWrapperTable->m_Model_GetSliceStackByID = nullptr;
		pWrapperTable->m_Model_GetBuildUUID = nullptr;
		pWrapperTable->m_Model_SetBuildUUID = nullptr;
		pWrapperTable->m_Model_GetBuildItems = nullptr;
		pWrapperTable->m_Model_GetOutbox = nullptr;
		pWrapperTable->m_Model_GetResources = nullptr;
		pWrapperTable->m_Model_GetObjects = nullptr;
		pWrapperTable->m_Model_GetMeshObjects = nullptr;
		pWrapperTable->m_Model_GetComponentsObjects = nullptr;
		pWrapperTable->m_Model_GetTexture2Ds = nullptr;
		pWrapperTable->m_Model_GetBaseMaterialGroups = nullptr;
		pWrapperTable->m_Model_GetColorGroups = nullptr;
		pWrapperTable->m_Model_GetTexture2DGroups = nullptr;
		pWrapperTable->m_Model_GetCompositeMaterials = nullptr;
		pWrapperTable->m_Model_GetMultiPropertyGroups = nullptr;
		pWrapperTable->m_Model_GetToolpaths = nullptr;
		pWrapperTable->m_Model_GetSliceStacks = nullptr;
		pWrapperTable->m_Model_MergeToModel = nullptr;
		pWrapperTable->m_Model_AddMeshObject = nullptr;
		pWrapperTable->m_Model_AddComponentsObject = nullptr;
		pWrapperTable->m_Model_AddSliceStack = nullptr;
		pWrapperTable->m_Model_AddTexture2DFromAttachment = nullptr;
		pWrapperTable->m_Model_AddBaseMaterialGroup = nullptr;
		pWrapperTable->m_Model_AddColorGroup = nullptr;
		pWrapperTable->m_Model_AddTexture2DGroup = nullptr;
		pWrapperTable->m_Model_AddCompositeMaterials = nullptr;
		pWrapperTable->m_Model_AddMultiPropertyGroup = nullptr;
		pWrapperTable->m_Model_AddBuildItem = nullptr;
		pWrapperTable->m_Model_RemoveBuildItem = nullptr;
		pWrapperTable->m_Model_AddToolpath = nullptr;
		pWrapperTable->m_Model_GetMetaDataGroup = nullptr;
		pWrapperTable->m_Model_AddAttachment = nullptr;
		pWrapperTable->m_Model_RemoveAttachment = nullptr;
		pWrapperTable->m_Model_GetAttachment = nullptr;
		pWrapperTable->m_Model_FindAttachment = nullptr;
		pWrapperTable->m_Model_GetAttachmentCount = nullptr;
		pWrapperTable->m_Model_HasPackageThumbnailAttachment = nullptr;
		pWrapperTable->m_Model_CreatePackageThumbnailAttachment = nullptr;
		pWrapperTable->m_Model_GetPackageThumbnailAttachment = nullptr;
		pWrapperTable->m_Model_RemovePackageThumbnailAttachment = nullptr;
		pWrapperTable->m_Model_AddCustomContentType = nullptr;
		pWrapperTable->m_Model_RemoveCustomContentType = nullptr;
		pWrapperTable->m_Model_SetRandomNumberCallback = nullptr;
		pWrapperTable->m_Model_GetKeyStore = nullptr;
		pWrapperTable->m_Model_CreatePersistentSourceFromFile = nullptr;
		pWrapperTable->m_Model_CreatePersistentSourceFromBuffer = nullptr;
		pWrapperTable->m_Model_CreatePersistentSourceFromCallback = nullptr;
		pWrapperTable->m_GetLibraryVersion = nullptr;
		pWrapperTable->m_GetPrereleaseInformation = nullptr;
		pWrapperTable->m_GetBuildInformation = nullptr;
		pWrapperTable->m_GetSpecificationVersion = nullptr;
		pWrapperTable->m_CreateModel = nullptr;
		pWrapperTable->m_Release = nullptr;
		pWrapperTable->m_Acquire = nullptr;
		pWrapperTable->m_SetJournal = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_RetrieveProgressMessage = nullptr;
		pWrapperTable->m_RGBAToColor = nullptr;
		pWrapperTable->m_FloatRGBAToColor = nullptr;
		pWrapperTable->m_ColorToRGBA = nullptr;
		pWrapperTable->m_ColorToFloatRGBA = nullptr;
		pWrapperTable->m_GetIdentityTransform = nullptr;
		pWrapperTable->m_GetUniformScaleTransform = nullptr;
		pWrapperTable->m_GetScaleTransform = nullptr;
		pWrapperTable->m_GetTranslationTransform = nullptr;
		
		return LIB3MF_SUCCESS;
	}

	inline Lib3MFResult CWrapper::releaseWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIB3MF_SUCCESS;
	}

	inline Lib3MFResult CWrapper::loadWrapperTable(sLib3MFDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIB3MF_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIB3MF_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIB3MF_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Base_ClassTypeId = (PLib3MFBase_ClassTypeIdPtr) GetProcAddress(hLibrary, "lib3mf_base_classtypeid");
		#else // _WIN32
		pWrapperTable->m_Base_ClassTypeId = (PLib3MFBase_ClassTypeIdPtr) dlsym(hLibrary, "lib3mf_base_classtypeid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_ClassTypeId == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_GetBinaryPath = (PLib3MFBinaryStream_GetBinaryPathPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_getbinarypath");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_GetBinaryPath = (PLib3MFBinaryStream_GetBinaryPathPtr) dlsym(hLibrary, "lib3mf_binarystream_getbinarypath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_GetBinaryPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_GetIndexPath = (PLib3MFBinaryStream_GetIndexPathPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_getindexpath");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_GetIndexPath = (PLib3MFBinaryStream_GetIndexPathPtr) dlsym(hLibrary, "lib3mf_binarystream_getindexpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_GetIndexPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_GetUUID = (PLib3MFBinaryStream_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_getuuid");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_GetUUID = (PLib3MFBinaryStream_GetUUIDPtr) dlsym(hLibrary, "lib3mf_binarystream_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression = (PLib3MFBinaryStream_DisableDiscretizedArrayCompressionPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_disablediscretizedarraycompression");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression = (PLib3MFBinaryStream_DisableDiscretizedArrayCompressionPtr) dlsym(hLibrary, "lib3mf_binarystream_disablediscretizedarraycompression");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression = (PLib3MFBinaryStream_EnableDiscretizedArrayCompressionPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_enablediscretizedarraycompression");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression = (PLib3MFBinaryStream_EnableDiscretizedArrayCompressionPtr) dlsym(hLibrary, "lib3mf_binarystream_enablediscretizedarraycompression");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_EnableLZMA = (PLib3MFBinaryStream_EnableLZMAPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_enablelzma");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_EnableLZMA = (PLib3MFBinaryStream_EnableLZMAPtr) dlsym(hLibrary, "lib3mf_binarystream_enablelzma");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_EnableLZMA == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BinaryStream_DisableLZMA = (PLib3MFBinaryStream_DisableLZMAPtr) GetProcAddress(hLibrary, "lib3mf_binarystream_disablelzma");
		#else // _WIN32
		pWrapperTable->m_BinaryStream_DisableLZMA = (PLib3MFBinaryStream_DisableLZMAPtr) dlsym(hLibrary, "lib3mf_binarystream_disablelzma");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BinaryStream_DisableLZMA == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_WriteToFile = (PLib3MFWriter_WriteToFilePtr) GetProcAddress(hLibrary, "lib3mf_writer_writetofile");
		#else // _WIN32
		pWrapperTable->m_Writer_WriteToFile = (PLib3MFWriter_WriteToFilePtr) dlsym(hLibrary, "lib3mf_writer_writetofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_WriteToFile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_GetStreamSize = (PLib3MFWriter_GetStreamSizePtr) GetProcAddress(hLibrary, "lib3mf_writer_getstreamsize");
		#else // _WIN32
		pWrapperTable->m_Writer_GetStreamSize = (PLib3MFWriter_GetStreamSizePtr) dlsym(hLibrary, "lib3mf_writer_getstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_GetStreamSize == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_WriteToBuffer = (PLib3MFWriter_WriteToBufferPtr) GetProcAddress(hLibrary, "lib3mf_writer_writetobuffer");
		#else // _WIN32
		pWrapperTable->m_Writer_WriteToBuffer = (PLib3MFWriter_WriteToBufferPtr) dlsym(hLibrary, "lib3mf_writer_writetobuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_WriteToBuffer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_WriteToCallback = (PLib3MFWriter_WriteToCallbackPtr) GetProcAddress(hLibrary, "lib3mf_writer_writetocallback");
		#else // _WIN32
		pWrapperTable->m_Writer_WriteToCallback = (PLib3MFWriter_WriteToCallbackPtr) dlsym(hLibrary, "lib3mf_writer_writetocallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_WriteToCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_SetProgressCallback = (PLib3MFWriter_SetProgressCallbackPtr) GetProcAddress(hLibrary, "lib3mf_writer_setprogresscallback");
		#else // _WIN32
		pWrapperTable->m_Writer_SetProgressCallback = (PLib3MFWriter_SetProgressCallbackPtr) dlsym(hLibrary, "lib3mf_writer_setprogresscallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_SetProgressCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_GetDecimalPrecision = (PLib3MFWriter_GetDecimalPrecisionPtr) GetProcAddress(hLibrary, "lib3mf_writer_getdecimalprecision");
		#else // _WIN32
		pWrapperTable->m_Writer_GetDecimalPrecision = (PLib3MFWriter_GetDecimalPrecisionPtr) dlsym(hLibrary, "lib3mf_writer_getdecimalprecision");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_GetDecimalPrecision == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_SetDecimalPrecision = (PLib3MFWriter_SetDecimalPrecisionPtr) GetProcAddress(hLibrary, "lib3mf_writer_setdecimalprecision");
		#else // _WIN32
		pWrapperTable->m_Writer_SetDecimalPrecision = (PLib3MFWriter_SetDecimalPrecisionPtr) dlsym(hLibrary, "lib3mf_writer_setdecimalprecision");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_SetDecimalPrecision == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_SetStrictModeActive = (PLib3MFWriter_SetStrictModeActivePtr) GetProcAddress(hLibrary, "lib3mf_writer_setstrictmodeactive");
		#else // _WIN32
		pWrapperTable->m_Writer_SetStrictModeActive = (PLib3MFWriter_SetStrictModeActivePtr) dlsym(hLibrary, "lib3mf_writer_setstrictmodeactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_SetStrictModeActive == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_GetStrictModeActive = (PLib3MFWriter_GetStrictModeActivePtr) GetProcAddress(hLibrary, "lib3mf_writer_getstrictmodeactive");
		#else // _WIN32
		pWrapperTable->m_Writer_GetStrictModeActive = (PLib3MFWriter_GetStrictModeActivePtr) dlsym(hLibrary, "lib3mf_writer_getstrictmodeactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_GetStrictModeActive == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_GetWarning = (PLib3MFWriter_GetWarningPtr) GetProcAddress(hLibrary, "lib3mf_writer_getwarning");
		#else // _WIN32
		pWrapperTable->m_Writer_GetWarning = (PLib3MFWriter_GetWarningPtr) dlsym(hLibrary, "lib3mf_writer_getwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_GetWarning == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_GetWarningCount = (PLib3MFWriter_GetWarningCountPtr) GetProcAddress(hLibrary, "lib3mf_writer_getwarningcount");
		#else // _WIN32
		pWrapperTable->m_Writer_GetWarningCount = (PLib3MFWriter_GetWarningCountPtr) dlsym(hLibrary, "lib3mf_writer_getwarningcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_GetWarningCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_AddKeyWrappingCallback = (PLib3MFWriter_AddKeyWrappingCallbackPtr) GetProcAddress(hLibrary, "lib3mf_writer_addkeywrappingcallback");
		#else // _WIN32
		pWrapperTable->m_Writer_AddKeyWrappingCallback = (PLib3MFWriter_AddKeyWrappingCallbackPtr) dlsym(hLibrary, "lib3mf_writer_addkeywrappingcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_AddKeyWrappingCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_SetContentEncryptionCallback = (PLib3MFWriter_SetContentEncryptionCallbackPtr) GetProcAddress(hLibrary, "lib3mf_writer_setcontentencryptioncallback");
		#else // _WIN32
		pWrapperTable->m_Writer_SetContentEncryptionCallback = (PLib3MFWriter_SetContentEncryptionCallbackPtr) dlsym(hLibrary, "lib3mf_writer_setcontentencryptioncallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_SetContentEncryptionCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_CreateBinaryStream = (PLib3MFWriter_CreateBinaryStreamPtr) GetProcAddress(hLibrary, "lib3mf_writer_createbinarystream");
		#else // _WIN32
		pWrapperTable->m_Writer_CreateBinaryStream = (PLib3MFWriter_CreateBinaryStreamPtr) dlsym(hLibrary, "lib3mf_writer_createbinarystream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_CreateBinaryStream == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_AssignBinaryStream = (PLib3MFWriter_AssignBinaryStreamPtr) GetProcAddress(hLibrary, "lib3mf_writer_assignbinarystream");
		#else // _WIN32
		pWrapperTable->m_Writer_AssignBinaryStream = (PLib3MFWriter_AssignBinaryStreamPtr) dlsym(hLibrary, "lib3mf_writer_assignbinarystream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_AssignBinaryStream == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Writer_RegisterCustomNamespace = (PLib3MFWriter_RegisterCustomNamespacePtr) GetProcAddress(hLibrary, "lib3mf_writer_registercustomnamespace");
		#else // _WIN32
		pWrapperTable->m_Writer_RegisterCustomNamespace = (PLib3MFWriter_RegisterCustomNamespacePtr) dlsym(hLibrary, "lib3mf_writer_registercustomnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Writer_RegisterCustomNamespace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistentReaderSource_GetSourceType = (PLib3MFPersistentReaderSource_GetSourceTypePtr) GetProcAddress(hLibrary, "lib3mf_persistentreadersource_getsourcetype");
		#else // _WIN32
		pWrapperTable->m_PersistentReaderSource_GetSourceType = (PLib3MFPersistentReaderSource_GetSourceTypePtr) dlsym(hLibrary, "lib3mf_persistentreadersource_getsourcetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistentReaderSource_GetSourceType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistentReaderSource_InvalidateSourceData = (PLib3MFPersistentReaderSource_InvalidateSourceDataPtr) GetProcAddress(hLibrary, "lib3mf_persistentreadersource_invalidatesourcedata");
		#else // _WIN32
		pWrapperTable->m_PersistentReaderSource_InvalidateSourceData = (PLib3MFPersistentReaderSource_InvalidateSourceDataPtr) dlsym(hLibrary, "lib3mf_persistentreadersource_invalidatesourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistentReaderSource_InvalidateSourceData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistentReaderSource_SourceDataIsValid = (PLib3MFPersistentReaderSource_SourceDataIsValidPtr) GetProcAddress(hLibrary, "lib3mf_persistentreadersource_sourcedataisvalid");
		#else // _WIN32
		pWrapperTable->m_PersistentReaderSource_SourceDataIsValid = (PLib3MFPersistentReaderSource_SourceDataIsValidPtr) dlsym(hLibrary, "lib3mf_persistentreadersource_sourcedataisvalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistentReaderSource_SourceDataIsValid == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_ReadFromPersistentSource = (PLib3MFReader_ReadFromPersistentSourcePtr) GetProcAddress(hLibrary, "lib3mf_reader_readfrompersistentsource");
		#else // _WIN32
		pWrapperTable->m_Reader_ReadFromPersistentSource = (PLib3MFReader_ReadFromPersistentSourcePtr) dlsym(hLibrary, "lib3mf_reader_readfrompersistentsource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_ReadFromPersistentSource == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_ReadFromFile = (PLib3MFReader_ReadFromFilePtr) GetProcAddress(hLibrary, "lib3mf_reader_readfromfile");
		#else // _WIN32
		pWrapperTable->m_Reader_ReadFromFile = (PLib3MFReader_ReadFromFilePtr) dlsym(hLibrary, "lib3mf_reader_readfromfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_ReadFromFile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_ReadFromBuffer = (PLib3MFReader_ReadFromBufferPtr) GetProcAddress(hLibrary, "lib3mf_reader_readfrombuffer");
		#else // _WIN32
		pWrapperTable->m_Reader_ReadFromBuffer = (PLib3MFReader_ReadFromBufferPtr) dlsym(hLibrary, "lib3mf_reader_readfrombuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_ReadFromBuffer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_ReadFromCallback = (PLib3MFReader_ReadFromCallbackPtr) GetProcAddress(hLibrary, "lib3mf_reader_readfromcallback");
		#else // _WIN32
		pWrapperTable->m_Reader_ReadFromCallback = (PLib3MFReader_ReadFromCallbackPtr) dlsym(hLibrary, "lib3mf_reader_readfromcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_ReadFromCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_SetProgressCallback = (PLib3MFReader_SetProgressCallbackPtr) GetProcAddress(hLibrary, "lib3mf_reader_setprogresscallback");
		#else // _WIN32
		pWrapperTable->m_Reader_SetProgressCallback = (PLib3MFReader_SetProgressCallbackPtr) dlsym(hLibrary, "lib3mf_reader_setprogresscallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_SetProgressCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_AddRelationToRead = (PLib3MFReader_AddRelationToReadPtr) GetProcAddress(hLibrary, "lib3mf_reader_addrelationtoread");
		#else // _WIN32
		pWrapperTable->m_Reader_AddRelationToRead = (PLib3MFReader_AddRelationToReadPtr) dlsym(hLibrary, "lib3mf_reader_addrelationtoread");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_AddRelationToRead == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_RemoveRelationToRead = (PLib3MFReader_RemoveRelationToReadPtr) GetProcAddress(hLibrary, "lib3mf_reader_removerelationtoread");
		#else // _WIN32
		pWrapperTable->m_Reader_RemoveRelationToRead = (PLib3MFReader_RemoveRelationToReadPtr) dlsym(hLibrary, "lib3mf_reader_removerelationtoread");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_RemoveRelationToRead == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_SetStrictModeActive = (PLib3MFReader_SetStrictModeActivePtr) GetProcAddress(hLibrary, "lib3mf_reader_setstrictmodeactive");
		#else // _WIN32
		pWrapperTable->m_Reader_SetStrictModeActive = (PLib3MFReader_SetStrictModeActivePtr) dlsym(hLibrary, "lib3mf_reader_setstrictmodeactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_SetStrictModeActive == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_GetStrictModeActive = (PLib3MFReader_GetStrictModeActivePtr) GetProcAddress(hLibrary, "lib3mf_reader_getstrictmodeactive");
		#else // _WIN32
		pWrapperTable->m_Reader_GetStrictModeActive = (PLib3MFReader_GetStrictModeActivePtr) dlsym(hLibrary, "lib3mf_reader_getstrictmodeactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_GetStrictModeActive == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_GetWarning = (PLib3MFReader_GetWarningPtr) GetProcAddress(hLibrary, "lib3mf_reader_getwarning");
		#else // _WIN32
		pWrapperTable->m_Reader_GetWarning = (PLib3MFReader_GetWarningPtr) dlsym(hLibrary, "lib3mf_reader_getwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_GetWarning == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_GetWarningCount = (PLib3MFReader_GetWarningCountPtr) GetProcAddress(hLibrary, "lib3mf_reader_getwarningcount");
		#else // _WIN32
		pWrapperTable->m_Reader_GetWarningCount = (PLib3MFReader_GetWarningCountPtr) dlsym(hLibrary, "lib3mf_reader_getwarningcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_GetWarningCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_AddKeyWrappingCallback = (PLib3MFReader_AddKeyWrappingCallbackPtr) GetProcAddress(hLibrary, "lib3mf_reader_addkeywrappingcallback");
		#else // _WIN32
		pWrapperTable->m_Reader_AddKeyWrappingCallback = (PLib3MFReader_AddKeyWrappingCallbackPtr) dlsym(hLibrary, "lib3mf_reader_addkeywrappingcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_AddKeyWrappingCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Reader_SetContentEncryptionCallback = (PLib3MFReader_SetContentEncryptionCallbackPtr) GetProcAddress(hLibrary, "lib3mf_reader_setcontentencryptioncallback");
		#else // _WIN32
		pWrapperTable->m_Reader_SetContentEncryptionCallback = (PLib3MFReader_SetContentEncryptionCallbackPtr) dlsym(hLibrary, "lib3mf_reader_setcontentencryptioncallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Reader_SetContentEncryptionCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PackagePart_GetPath = (PLib3MFPackagePart_GetPathPtr) GetProcAddress(hLibrary, "lib3mf_packagepart_getpath");
		#else // _WIN32
		pWrapperTable->m_PackagePart_GetPath = (PLib3MFPackagePart_GetPathPtr) dlsym(hLibrary, "lib3mf_packagepart_getpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PackagePart_GetPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PackagePart_SetPath = (PLib3MFPackagePart_SetPathPtr) GetProcAddress(hLibrary, "lib3mf_packagepart_setpath");
		#else // _WIN32
		pWrapperTable->m_PackagePart_SetPath = (PLib3MFPackagePart_SetPathPtr) dlsym(hLibrary, "lib3mf_packagepart_setpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PackagePart_SetPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Resource_GetResourceID = (PLib3MFResource_GetResourceIDPtr) GetProcAddress(hLibrary, "lib3mf_resource_getresourceid");
		#else // _WIN32
		pWrapperTable->m_Resource_GetResourceID = (PLib3MFResource_GetResourceIDPtr) dlsym(hLibrary, "lib3mf_resource_getresourceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Resource_GetResourceID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Resource_GetUniqueResourceID = (PLib3MFResource_GetUniqueResourceIDPtr) GetProcAddress(hLibrary, "lib3mf_resource_getuniqueresourceid");
		#else // _WIN32
		pWrapperTable->m_Resource_GetUniqueResourceID = (PLib3MFResource_GetUniqueResourceIDPtr) dlsym(hLibrary, "lib3mf_resource_getuniqueresourceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Resource_GetUniqueResourceID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Resource_PackagePart = (PLib3MFResource_PackagePartPtr) GetProcAddress(hLibrary, "lib3mf_resource_packagepart");
		#else // _WIN32
		pWrapperTable->m_Resource_PackagePart = (PLib3MFResource_PackagePartPtr) dlsym(hLibrary, "lib3mf_resource_packagepart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Resource_PackagePart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Resource_SetPackagePart = (PLib3MFResource_SetPackagePartPtr) GetProcAddress(hLibrary, "lib3mf_resource_setpackagepart");
		#else // _WIN32
		pWrapperTable->m_Resource_SetPackagePart = (PLib3MFResource_SetPackagePartPtr) dlsym(hLibrary, "lib3mf_resource_setpackagepart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Resource_SetPackagePart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Resource_GetModelResourceID = (PLib3MFResource_GetModelResourceIDPtr) GetProcAddress(hLibrary, "lib3mf_resource_getmodelresourceid");
		#else // _WIN32
		pWrapperTable->m_Resource_GetModelResourceID = (PLib3MFResource_GetModelResourceIDPtr) dlsym(hLibrary, "lib3mf_resource_getmodelresourceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Resource_GetModelResourceID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceIterator_MoveNext = (PLib3MFResourceIterator_MoveNextPtr) GetProcAddress(hLibrary, "lib3mf_resourceiterator_movenext");
		#else // _WIN32
		pWrapperTable->m_ResourceIterator_MoveNext = (PLib3MFResourceIterator_MoveNextPtr) dlsym(hLibrary, "lib3mf_resourceiterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceIterator_MoveNext == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceIterator_MovePrevious = (PLib3MFResourceIterator_MovePreviousPtr) GetProcAddress(hLibrary, "lib3mf_resourceiterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_ResourceIterator_MovePrevious = (PLib3MFResourceIterator_MovePreviousPtr) dlsym(hLibrary, "lib3mf_resourceiterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceIterator_MovePrevious == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceIterator_GetCurrent = (PLib3MFResourceIterator_GetCurrentPtr) GetProcAddress(hLibrary, "lib3mf_resourceiterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_ResourceIterator_GetCurrent = (PLib3MFResourceIterator_GetCurrentPtr) dlsym(hLibrary, "lib3mf_resourceiterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceIterator_GetCurrent == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceIterator_Clone = (PLib3MFResourceIterator_ClonePtr) GetProcAddress(hLibrary, "lib3mf_resourceiterator_clone");
		#else // _WIN32
		pWrapperTable->m_ResourceIterator_Clone = (PLib3MFResourceIterator_ClonePtr) dlsym(hLibrary, "lib3mf_resourceiterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceIterator_Clone == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceIterator_Count = (PLib3MFResourceIterator_CountPtr) GetProcAddress(hLibrary, "lib3mf_resourceiterator_count");
		#else // _WIN32
		pWrapperTable->m_ResourceIterator_Count = (PLib3MFResourceIterator_CountPtr) dlsym(hLibrary, "lib3mf_resourceiterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceIterator_Count == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetName = (PLib3MFCustomXMLAttribute_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_getname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetName = (PLib3MFCustomXMLAttribute_GetNamePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetValue = (PLib3MFCustomXMLAttribute_GetValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_getvalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetValue = (PLib3MFCustomXMLAttribute_GetValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_getvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_GetValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidInteger = (PLib3MFCustomXMLAttribute_IsValidIntegerPtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_isvalidinteger");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidInteger = (PLib3MFCustomXMLAttribute_IsValidIntegerPtr) dlsym(hLibrary, "lib3mf_customxmlattribute_isvalidinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_IsValidInteger == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetIntegerValue = (PLib3MFCustomXMLAttribute_GetIntegerValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_getintegervalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetIntegerValue = (PLib3MFCustomXMLAttribute_GetIntegerValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_getintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_GetIntegerValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidDouble = (PLib3MFCustomXMLAttribute_IsValidDoublePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_isvaliddouble");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidDouble = (PLib3MFCustomXMLAttribute_IsValidDoublePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_isvaliddouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_IsValidDouble == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetDoubleValue = (PLib3MFCustomXMLAttribute_GetDoubleValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_getdoublevalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetDoubleValue = (PLib3MFCustomXMLAttribute_GetDoubleValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_getdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_GetDoubleValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidBool = (PLib3MFCustomXMLAttribute_IsValidBoolPtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_isvalidbool");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_IsValidBool = (PLib3MFCustomXMLAttribute_IsValidBoolPtr) dlsym(hLibrary, "lib3mf_customxmlattribute_isvalidbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_IsValidBool == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetBoolValue = (PLib3MFCustomXMLAttribute_GetBoolValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_getboolvalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_GetBoolValue = (PLib3MFCustomXMLAttribute_GetBoolValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_getboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_GetBoolValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetValue = (PLib3MFCustomXMLAttribute_SetValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_setvalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetValue = (PLib3MFCustomXMLAttribute_SetValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_setvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_SetValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetIntegerValue = (PLib3MFCustomXMLAttribute_SetIntegerValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_setintegervalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetIntegerValue = (PLib3MFCustomXMLAttribute_SetIntegerValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_setintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_SetIntegerValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetDoubleValue = (PLib3MFCustomXMLAttribute_SetDoubleValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_setdoublevalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetDoubleValue = (PLib3MFCustomXMLAttribute_SetDoubleValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_setdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_SetDoubleValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetBoolValue = (PLib3MFCustomXMLAttribute_SetBoolValuePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_setboolvalue");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_SetBoolValue = (PLib3MFCustomXMLAttribute_SetBoolValuePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_setboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_SetBoolValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLAttribute_Remove = (PLib3MFCustomXMLAttribute_RemovePtr) GetProcAddress(hLibrary, "lib3mf_customxmlattribute_remove");
		#else // _WIN32
		pWrapperTable->m_CustomXMLAttribute_Remove = (PLib3MFCustomXMLAttribute_RemovePtr) dlsym(hLibrary, "lib3mf_customxmlattribute_remove");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLAttribute_Remove == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetName = (PLib3MFCustomXMLNode_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetName = (PLib3MFCustomXMLNode_GetNamePtr) dlsym(hLibrary, "lib3mf_customxmlnode_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetNameSpace = (PLib3MFCustomXMLNode_GetNameSpacePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getnamespace");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetNameSpace = (PLib3MFCustomXMLNode_GetNameSpacePtr) dlsym(hLibrary, "lib3mf_customxmlnode_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetNameSpace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetAttributeCount = (PLib3MFCustomXMLNode_GetAttributeCountPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getattributecount");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetAttributeCount = (PLib3MFCustomXMLNode_GetAttributeCountPtr) dlsym(hLibrary, "lib3mf_customxmlnode_getattributecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetAttributeCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetAttribute = (PLib3MFCustomXMLNode_GetAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetAttribute = (PLib3MFCustomXMLNode_GetAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_getattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_HasAttribute = (PLib3MFCustomXMLNode_HasAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_hasattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_HasAttribute = (PLib3MFCustomXMLNode_HasAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_hasattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_HasAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_FindAttribute = (PLib3MFCustomXMLNode_FindAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_findattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_FindAttribute = (PLib3MFCustomXMLNode_FindAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_findattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_FindAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveAttribute = (PLib3MFCustomXMLNode_RemoveAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_removeattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveAttribute = (PLib3MFCustomXMLNode_RemoveAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_removeattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_RemoveAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex = (PLib3MFCustomXMLNode_RemoveAttributeByIndexPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_removeattributebyindex");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex = (PLib3MFCustomXMLNode_RemoveAttributeByIndexPtr) dlsym(hLibrary, "lib3mf_customxmlnode_removeattributebyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_AddAttribute = (PLib3MFCustomXMLNode_AddAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_addattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_AddAttribute = (PLib3MFCustomXMLNode_AddAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_addattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_AddAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_AddIntegerAttribute = (PLib3MFCustomXMLNode_AddIntegerAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_addintegerattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_AddIntegerAttribute = (PLib3MFCustomXMLNode_AddIntegerAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_addintegerattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_AddIntegerAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_AddDoubleAttribute = (PLib3MFCustomXMLNode_AddDoubleAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_adddoubleattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_AddDoubleAttribute = (PLib3MFCustomXMLNode_AddDoubleAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_adddoubleattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_AddDoubleAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_AddBoolAttribute = (PLib3MFCustomXMLNode_AddBoolAttributePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_addboolattribute");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_AddBoolAttribute = (PLib3MFCustomXMLNode_AddBoolAttributePtr) dlsym(hLibrary, "lib3mf_customxmlnode_addboolattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_AddBoolAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetChildren = (PLib3MFCustomXMLNode_GetChildrenPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getchildren");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetChildren = (PLib3MFCustomXMLNode_GetChildrenPtr) dlsym(hLibrary, "lib3mf_customxmlnode_getchildren");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetChildren == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_CountChildrenByName = (PLib3MFCustomXMLNode_CountChildrenByNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_countchildrenbyname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_CountChildrenByName = (PLib3MFCustomXMLNode_CountChildrenByNamePtr) dlsym(hLibrary, "lib3mf_customxmlnode_countchildrenbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_CountChildrenByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_GetChildrenByName = (PLib3MFCustomXMLNode_GetChildrenByNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_getchildrenbyname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_GetChildrenByName = (PLib3MFCustomXMLNode_GetChildrenByNamePtr) dlsym(hLibrary, "lib3mf_customxmlnode_getchildrenbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_GetChildrenByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_HasChild = (PLib3MFCustomXMLNode_HasChildPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_haschild");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_HasChild = (PLib3MFCustomXMLNode_HasChildPtr) dlsym(hLibrary, "lib3mf_customxmlnode_haschild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_HasChild == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_HasUniqueChild = (PLib3MFCustomXMLNode_HasUniqueChildPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_hasuniquechild");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_HasUniqueChild = (PLib3MFCustomXMLNode_HasUniqueChildPtr) dlsym(hLibrary, "lib3mf_customxmlnode_hasuniquechild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_HasUniqueChild == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_FindChild = (PLib3MFCustomXMLNode_FindChildPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_findchild");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_FindChild = (PLib3MFCustomXMLNode_FindChildPtr) dlsym(hLibrary, "lib3mf_customxmlnode_findchild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_FindChild == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_AddChild = (PLib3MFCustomXMLNode_AddChildPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_addchild");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_AddChild = (PLib3MFCustomXMLNode_AddChildPtr) dlsym(hLibrary, "lib3mf_customxmlnode_addchild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_AddChild == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveChild = (PLib3MFCustomXMLNode_RemoveChildPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_removechild");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveChild = (PLib3MFCustomXMLNode_RemoveChildPtr) dlsym(hLibrary, "lib3mf_customxmlnode_removechild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_RemoveChild == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName = (PLib3MFCustomXMLNode_RemoveChildrenWithNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_removechildrenwithname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName = (PLib3MFCustomXMLNode_RemoveChildrenWithNamePtr) dlsym(hLibrary, "lib3mf_customxmlnode_removechildrenwithname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNode_Remove = (PLib3MFCustomXMLNode_RemovePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnode_remove");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNode_Remove = (PLib3MFCustomXMLNode_RemovePtr) dlsym(hLibrary, "lib3mf_customxmlnode_remove");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNode_Remove == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNodeCount = (PLib3MFCustomXMLNodes_GetNodeCountPtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_getnodecount");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNodeCount = (PLib3MFCustomXMLNodes_GetNodeCountPtr) dlsym(hLibrary, "lib3mf_customxmlnodes_getnodecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_GetNodeCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNode = (PLib3MFCustomXMLNodes_GetNodePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_getnode");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNode = (PLib3MFCustomXMLNodes_GetNodePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_getnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_GetNode == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_CountNodesByName = (PLib3MFCustomXMLNodes_CountNodesByNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_countnodesbyname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_CountNodesByName = (PLib3MFCustomXMLNodes_CountNodesByNamePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_countnodesbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_CountNodesByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNodesByName = (PLib3MFCustomXMLNodes_GetNodesByNamePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_getnodesbyname");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_GetNodesByName = (PLib3MFCustomXMLNodes_GetNodesByNamePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_getnodesbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_GetNodesByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_HasNode = (PLib3MFCustomXMLNodes_HasNodePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_hasnode");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_HasNode = (PLib3MFCustomXMLNodes_HasNodePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_hasnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_HasNode == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_HasUniqueNode = (PLib3MFCustomXMLNodes_HasUniqueNodePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_hasuniquenode");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_HasUniqueNode = (PLib3MFCustomXMLNodes_HasUniqueNodePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_hasuniquenode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_HasUniqueNode == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomXMLNodes_FindNode = (PLib3MFCustomXMLNodes_FindNodePtr) GetProcAddress(hLibrary, "lib3mf_customxmlnodes_findnode");
		#else // _WIN32
		pWrapperTable->m_CustomXMLNodes_FindNode = (PLib3MFCustomXMLNodes_FindNodePtr) dlsym(hLibrary, "lib3mf_customxmlnodes_findnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomXMLNodes_FindNode == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDOMTree_GetNameSpace = (PLib3MFCustomDOMTree_GetNameSpacePtr) GetProcAddress(hLibrary, "lib3mf_customdomtree_getnamespace");
		#else // _WIN32
		pWrapperTable->m_CustomDOMTree_GetNameSpace = (PLib3MFCustomDOMTree_GetNameSpacePtr) dlsym(hLibrary, "lib3mf_customdomtree_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDOMTree_GetNameSpace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDOMTree_GetRootNode = (PLib3MFCustomDOMTree_GetRootNodePtr) GetProcAddress(hLibrary, "lib3mf_customdomtree_getrootnode");
		#else // _WIN32
		pWrapperTable->m_CustomDOMTree_GetRootNode = (PLib3MFCustomDOMTree_GetRootNodePtr) dlsym(hLibrary, "lib3mf_customdomtree_getrootnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDOMTree_GetRootNode == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDOMTree_SaveToString = (PLib3MFCustomDOMTree_SaveToStringPtr) GetProcAddress(hLibrary, "lib3mf_customdomtree_savetostring");
		#else // _WIN32
		pWrapperTable->m_CustomDOMTree_SaveToString = (PLib3MFCustomDOMTree_SaveToStringPtr) dlsym(hLibrary, "lib3mf_customdomtree_savetostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDOMTree_SaveToString == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack = (PLib3MFSliceStackIterator_GetCurrentSliceStackPtr) GetProcAddress(hLibrary, "lib3mf_slicestackiterator_getcurrentslicestack");
		#else // _WIN32
		pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack = (PLib3MFSliceStackIterator_GetCurrentSliceStackPtr) dlsym(hLibrary, "lib3mf_slicestackiterator_getcurrentslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ObjectIterator_GetCurrentObject = (PLib3MFObjectIterator_GetCurrentObjectPtr) GetProcAddress(hLibrary, "lib3mf_objectiterator_getcurrentobject");
		#else // _WIN32
		pWrapperTable->m_ObjectIterator_GetCurrentObject = (PLib3MFObjectIterator_GetCurrentObjectPtr) dlsym(hLibrary, "lib3mf_objectiterator_getcurrentobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ObjectIterator_GetCurrentObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject = (PLib3MFMeshObjectIterator_GetCurrentMeshObjectPtr) GetProcAddress(hLibrary, "lib3mf_meshobjectiterator_getcurrentmeshobject");
		#else // _WIN32
		pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject = (PLib3MFMeshObjectIterator_GetCurrentMeshObjectPtr) dlsym(hLibrary, "lib3mf_meshobjectiterator_getcurrentmeshobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject = (PLib3MFComponentsObjectIterator_GetCurrentComponentsObjectPtr) GetProcAddress(hLibrary, "lib3mf_componentsobjectiterator_getcurrentcomponentsobject");
		#else // _WIN32
		pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject = (PLib3MFComponentsObjectIterator_GetCurrentComponentsObjectPtr) dlsym(hLibrary, "lib3mf_componentsobjectiterator_getcurrentcomponentsobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D = (PLib3MFTexture2DIterator_GetCurrentTexture2DPtr) GetProcAddress(hLibrary, "lib3mf_texture2diterator_getcurrenttexture2d");
		#else // _WIN32
		pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D = (PLib3MFTexture2DIterator_GetCurrentTexture2DPtr) dlsym(hLibrary, "lib3mf_texture2diterator_getcurrenttexture2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup = (PLib3MFBaseMaterialGroupIterator_GetCurrentBaseMaterialGroupPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup = (PLib3MFBaseMaterialGroupIterator_GetCurrentBaseMaterialGroupPtr) dlsym(hLibrary, "lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup = (PLib3MFColorGroupIterator_GetCurrentColorGroupPtr) GetProcAddress(hLibrary, "lib3mf_colorgroupiterator_getcurrentcolorgroup");
		#else // _WIN32
		pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup = (PLib3MFColorGroupIterator_GetCurrentColorGroupPtr) dlsym(hLibrary, "lib3mf_colorgroupiterator_getcurrentcolorgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup = (PLib3MFTexture2DGroupIterator_GetCurrentTexture2DGroupPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup = (PLib3MFTexture2DGroupIterator_GetCurrentTexture2DGroupPtr) dlsym(hLibrary, "lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials = (PLib3MFCompositeMaterialsIterator_GetCurrentCompositeMaterialsPtr) GetProcAddress(hLibrary, "lib3mf_compositematerialsiterator_getcurrentcompositematerials");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials = (PLib3MFCompositeMaterialsIterator_GetCurrentCompositeMaterialsPtr) dlsym(hLibrary, "lib3mf_compositematerialsiterator_getcurrentcompositematerials");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup = (PLib3MFMultiPropertyGroupIterator_GetCurrentMultiPropertyGroupPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup = (PLib3MFMultiPropertyGroupIterator_GetCurrentMultiPropertyGroupPtr) dlsym(hLibrary, "lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetNameSpace = (PLib3MFMetaData_GetNameSpacePtr) GetProcAddress(hLibrary, "lib3mf_metadata_getnamespace");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetNameSpace = (PLib3MFMetaData_GetNameSpacePtr) dlsym(hLibrary, "lib3mf_metadata_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetNameSpace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_SetNameSpace = (PLib3MFMetaData_SetNameSpacePtr) GetProcAddress(hLibrary, "lib3mf_metadata_setnamespace");
		#else // _WIN32
		pWrapperTable->m_MetaData_SetNameSpace = (PLib3MFMetaData_SetNameSpacePtr) dlsym(hLibrary, "lib3mf_metadata_setnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_SetNameSpace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetName = (PLib3MFMetaData_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_metadata_getname");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetName = (PLib3MFMetaData_GetNamePtr) dlsym(hLibrary, "lib3mf_metadata_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_SetName = (PLib3MFMetaData_SetNamePtr) GetProcAddress(hLibrary, "lib3mf_metadata_setname");
		#else // _WIN32
		pWrapperTable->m_MetaData_SetName = (PLib3MFMetaData_SetNamePtr) dlsym(hLibrary, "lib3mf_metadata_setname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_SetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetKey = (PLib3MFMetaData_GetKeyPtr) GetProcAddress(hLibrary, "lib3mf_metadata_getkey");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetKey = (PLib3MFMetaData_GetKeyPtr) dlsym(hLibrary, "lib3mf_metadata_getkey");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetKey == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetMustPreserve = (PLib3MFMetaData_GetMustPreservePtr) GetProcAddress(hLibrary, "lib3mf_metadata_getmustpreserve");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetMustPreserve = (PLib3MFMetaData_GetMustPreservePtr) dlsym(hLibrary, "lib3mf_metadata_getmustpreserve");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetMustPreserve == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_SetMustPreserve = (PLib3MFMetaData_SetMustPreservePtr) GetProcAddress(hLibrary, "lib3mf_metadata_setmustpreserve");
		#else // _WIN32
		pWrapperTable->m_MetaData_SetMustPreserve = (PLib3MFMetaData_SetMustPreservePtr) dlsym(hLibrary, "lib3mf_metadata_setmustpreserve");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_SetMustPreserve == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetType = (PLib3MFMetaData_GetTypePtr) GetProcAddress(hLibrary, "lib3mf_metadata_gettype");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetType = (PLib3MFMetaData_GetTypePtr) dlsym(hLibrary, "lib3mf_metadata_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_SetType = (PLib3MFMetaData_SetTypePtr) GetProcAddress(hLibrary, "lib3mf_metadata_settype");
		#else // _WIN32
		pWrapperTable->m_MetaData_SetType = (PLib3MFMetaData_SetTypePtr) dlsym(hLibrary, "lib3mf_metadata_settype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_SetType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_GetValue = (PLib3MFMetaData_GetValuePtr) GetProcAddress(hLibrary, "lib3mf_metadata_getvalue");
		#else // _WIN32
		pWrapperTable->m_MetaData_GetValue = (PLib3MFMetaData_GetValuePtr) dlsym(hLibrary, "lib3mf_metadata_getvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_GetValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaData_SetValue = (PLib3MFMetaData_SetValuePtr) GetProcAddress(hLibrary, "lib3mf_metadata_setvalue");
		#else // _WIN32
		pWrapperTable->m_MetaData_SetValue = (PLib3MFMetaData_SetValuePtr) dlsym(hLibrary, "lib3mf_metadata_setvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaData_SetValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaDataCount = (PLib3MFMetaDataGroup_GetMetaDataCountPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_getmetadatacount");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaDataCount = (PLib3MFMetaDataGroup_GetMetaDataCountPtr) dlsym(hLibrary, "lib3mf_metadatagroup_getmetadatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_GetMetaDataCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaData = (PLib3MFMetaDataGroup_GetMetaDataPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_getmetadata");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaData = (PLib3MFMetaDataGroup_GetMetaDataPtr) dlsym(hLibrary, "lib3mf_metadatagroup_getmetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_GetMetaData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaDataByKey = (PLib3MFMetaDataGroup_GetMetaDataByKeyPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_getmetadatabykey");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_GetMetaDataByKey = (PLib3MFMetaDataGroup_GetMetaDataByKeyPtr) dlsym(hLibrary, "lib3mf_metadatagroup_getmetadatabykey");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_GetMetaDataByKey == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex = (PLib3MFMetaDataGroup_RemoveMetaDataByIndexPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_removemetadatabyindex");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex = (PLib3MFMetaDataGroup_RemoveMetaDataByIndexPtr) dlsym(hLibrary, "lib3mf_metadatagroup_removemetadatabyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_RemoveMetaData = (PLib3MFMetaDataGroup_RemoveMetaDataPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_removemetadata");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_RemoveMetaData = (PLib3MFMetaDataGroup_RemoveMetaDataPtr) dlsym(hLibrary, "lib3mf_metadatagroup_removemetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_RemoveMetaData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MetaDataGroup_AddMetaData = (PLib3MFMetaDataGroup_AddMetaDataPtr) GetProcAddress(hLibrary, "lib3mf_metadatagroup_addmetadata");
		#else // _WIN32
		pWrapperTable->m_MetaDataGroup_AddMetaData = (PLib3MFMetaDataGroup_AddMetaDataPtr) dlsym(hLibrary, "lib3mf_metadatagroup_addmetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MetaDataGroup_AddMetaData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetType = (PLib3MFObject_GetTypePtr) GetProcAddress(hLibrary, "lib3mf_object_gettype");
		#else // _WIN32
		pWrapperTable->m_Object_GetType = (PLib3MFObject_GetTypePtr) dlsym(hLibrary, "lib3mf_object_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetType = (PLib3MFObject_SetTypePtr) GetProcAddress(hLibrary, "lib3mf_object_settype");
		#else // _WIN32
		pWrapperTable->m_Object_SetType = (PLib3MFObject_SetTypePtr) dlsym(hLibrary, "lib3mf_object_settype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetName = (PLib3MFObject_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_object_getname");
		#else // _WIN32
		pWrapperTable->m_Object_GetName = (PLib3MFObject_GetNamePtr) dlsym(hLibrary, "lib3mf_object_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetName = (PLib3MFObject_SetNamePtr) GetProcAddress(hLibrary, "lib3mf_object_setname");
		#else // _WIN32
		pWrapperTable->m_Object_SetName = (PLib3MFObject_SetNamePtr) dlsym(hLibrary, "lib3mf_object_setname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetPartNumber = (PLib3MFObject_GetPartNumberPtr) GetProcAddress(hLibrary, "lib3mf_object_getpartnumber");
		#else // _WIN32
		pWrapperTable->m_Object_GetPartNumber = (PLib3MFObject_GetPartNumberPtr) dlsym(hLibrary, "lib3mf_object_getpartnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetPartNumber == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetPartNumber = (PLib3MFObject_SetPartNumberPtr) GetProcAddress(hLibrary, "lib3mf_object_setpartnumber");
		#else // _WIN32
		pWrapperTable->m_Object_SetPartNumber = (PLib3MFObject_SetPartNumberPtr) dlsym(hLibrary, "lib3mf_object_setpartnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetPartNumber == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_IsMeshObject = (PLib3MFObject_IsMeshObjectPtr) GetProcAddress(hLibrary, "lib3mf_object_ismeshobject");
		#else // _WIN32
		pWrapperTable->m_Object_IsMeshObject = (PLib3MFObject_IsMeshObjectPtr) dlsym(hLibrary, "lib3mf_object_ismeshobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_IsMeshObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_IsComponentsObject = (PLib3MFObject_IsComponentsObjectPtr) GetProcAddress(hLibrary, "lib3mf_object_iscomponentsobject");
		#else // _WIN32
		pWrapperTable->m_Object_IsComponentsObject = (PLib3MFObject_IsComponentsObjectPtr) dlsym(hLibrary, "lib3mf_object_iscomponentsobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_IsComponentsObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_IsValid = (PLib3MFObject_IsValidPtr) GetProcAddress(hLibrary, "lib3mf_object_isvalid");
		#else // _WIN32
		pWrapperTable->m_Object_IsValid = (PLib3MFObject_IsValidPtr) dlsym(hLibrary, "lib3mf_object_isvalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_IsValid == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetAttachmentAsThumbnail = (PLib3MFObject_SetAttachmentAsThumbnailPtr) GetProcAddress(hLibrary, "lib3mf_object_setattachmentasthumbnail");
		#else // _WIN32
		pWrapperTable->m_Object_SetAttachmentAsThumbnail = (PLib3MFObject_SetAttachmentAsThumbnailPtr) dlsym(hLibrary, "lib3mf_object_setattachmentasthumbnail");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetAttachmentAsThumbnail == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetThumbnailAttachment = (PLib3MFObject_GetThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_object_getthumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Object_GetThumbnailAttachment = (PLib3MFObject_GetThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_object_getthumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_ClearThumbnailAttachment = (PLib3MFObject_ClearThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_object_clearthumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Object_ClearThumbnailAttachment = (PLib3MFObject_ClearThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_object_clearthumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_ClearThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetOutbox = (PLib3MFObject_GetOutboxPtr) GetProcAddress(hLibrary, "lib3mf_object_getoutbox");
		#else // _WIN32
		pWrapperTable->m_Object_GetOutbox = (PLib3MFObject_GetOutboxPtr) dlsym(hLibrary, "lib3mf_object_getoutbox");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetOutbox == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetUUID = (PLib3MFObject_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_object_getuuid");
		#else // _WIN32
		pWrapperTable->m_Object_GetUUID = (PLib3MFObject_GetUUIDPtr) dlsym(hLibrary, "lib3mf_object_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetUUID = (PLib3MFObject_SetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_object_setuuid");
		#else // _WIN32
		pWrapperTable->m_Object_SetUUID = (PLib3MFObject_SetUUIDPtr) dlsym(hLibrary, "lib3mf_object_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetMetaDataGroup = (PLib3MFObject_GetMetaDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_object_getmetadatagroup");
		#else // _WIN32
		pWrapperTable->m_Object_GetMetaDataGroup = (PLib3MFObject_GetMetaDataGroupPtr) dlsym(hLibrary, "lib3mf_object_getmetadatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetMetaDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_SetSlicesMeshResolution = (PLib3MFObject_SetSlicesMeshResolutionPtr) GetProcAddress(hLibrary, "lib3mf_object_setslicesmeshresolution");
		#else // _WIN32
		pWrapperTable->m_Object_SetSlicesMeshResolution = (PLib3MFObject_SetSlicesMeshResolutionPtr) dlsym(hLibrary, "lib3mf_object_setslicesmeshresolution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_SetSlicesMeshResolution == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetSlicesMeshResolution = (PLib3MFObject_GetSlicesMeshResolutionPtr) GetProcAddress(hLibrary, "lib3mf_object_getslicesmeshresolution");
		#else // _WIN32
		pWrapperTable->m_Object_GetSlicesMeshResolution = (PLib3MFObject_GetSlicesMeshResolutionPtr) dlsym(hLibrary, "lib3mf_object_getslicesmeshresolution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetSlicesMeshResolution == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_HasSlices = (PLib3MFObject_HasSlicesPtr) GetProcAddress(hLibrary, "lib3mf_object_hasslices");
		#else // _WIN32
		pWrapperTable->m_Object_HasSlices = (PLib3MFObject_HasSlicesPtr) dlsym(hLibrary, "lib3mf_object_hasslices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_HasSlices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_ClearSliceStack = (PLib3MFObject_ClearSliceStackPtr) GetProcAddress(hLibrary, "lib3mf_object_clearslicestack");
		#else // _WIN32
		pWrapperTable->m_Object_ClearSliceStack = (PLib3MFObject_ClearSliceStackPtr) dlsym(hLibrary, "lib3mf_object_clearslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_ClearSliceStack == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_GetSliceStack = (PLib3MFObject_GetSliceStackPtr) GetProcAddress(hLibrary, "lib3mf_object_getslicestack");
		#else // _WIN32
		pWrapperTable->m_Object_GetSliceStack = (PLib3MFObject_GetSliceStackPtr) dlsym(hLibrary, "lib3mf_object_getslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_GetSliceStack == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Object_AssignSliceStack = (PLib3MFObject_AssignSliceStackPtr) GetProcAddress(hLibrary, "lib3mf_object_assignslicestack");
		#else // _WIN32
		pWrapperTable->m_Object_AssignSliceStack = (PLib3MFObject_AssignSliceStackPtr) dlsym(hLibrary, "lib3mf_object_assignslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Object_AssignSliceStack == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertexCount = (PLib3MFMeshObject_GetVertexCountPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_getvertexcount");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertexCount = (PLib3MFMeshObject_GetVertexCountPtr) dlsym(hLibrary, "lib3mf_meshobject_getvertexcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertexCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangleCount = (PLib3MFMeshObject_GetTriangleCountPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_gettrianglecount");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangleCount = (PLib3MFMeshObject_GetTriangleCountPtr) dlsym(hLibrary, "lib3mf_meshobject_gettrianglecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangleCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertex = (PLib3MFMeshObject_GetVertexPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_getvertex");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertex = (PLib3MFMeshObject_GetVertexPtr) dlsym(hLibrary, "lib3mf_meshobject_getvertex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertex == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetVertex = (PLib3MFMeshObject_SetVertexPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_setvertex");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetVertex = (PLib3MFMeshObject_SetVertexPtr) dlsym(hLibrary, "lib3mf_meshobject_setvertex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetVertex == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_AddVertex = (PLib3MFMeshObject_AddVertexPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_addvertex");
		#else // _WIN32
		pWrapperTable->m_MeshObject_AddVertex = (PLib3MFMeshObject_AddVertexPtr) dlsym(hLibrary, "lib3mf_meshobject_addvertex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_AddVertex == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertices = (PLib3MFMeshObject_GetVerticesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_getvertices");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertices = (PLib3MFMeshObject_GetVerticesPtr) dlsym(hLibrary, "lib3mf_meshobject_getvertices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangle = (PLib3MFMeshObject_GetTrianglePtr) GetProcAddress(hLibrary, "lib3mf_meshobject_gettriangle");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangle = (PLib3MFMeshObject_GetTrianglePtr) dlsym(hLibrary, "lib3mf_meshobject_gettriangle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangle == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetTriangle = (PLib3MFMeshObject_SetTrianglePtr) GetProcAddress(hLibrary, "lib3mf_meshobject_settriangle");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetTriangle = (PLib3MFMeshObject_SetTrianglePtr) dlsym(hLibrary, "lib3mf_meshobject_settriangle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetTriangle == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_AddTriangle = (PLib3MFMeshObject_AddTrianglePtr) GetProcAddress(hLibrary, "lib3mf_meshobject_addtriangle");
		#else // _WIN32
		pWrapperTable->m_MeshObject_AddTriangle = (PLib3MFMeshObject_AddTrianglePtr) dlsym(hLibrary, "lib3mf_meshobject_addtriangle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_AddTriangle == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangleIndices = (PLib3MFMeshObject_GetTriangleIndicesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_gettriangleindices");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangleIndices = (PLib3MFMeshObject_GetTriangleIndicesPtr) dlsym(hLibrary, "lib3mf_meshobject_gettriangleindices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangleIndices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetObjectLevelProperty = (PLib3MFMeshObject_SetObjectLevelPropertyPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_setobjectlevelproperty");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetObjectLevelProperty = (PLib3MFMeshObject_SetObjectLevelPropertyPtr) dlsym(hLibrary, "lib3mf_meshobject_setobjectlevelproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetObjectLevelProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetObjectLevelProperty = (PLib3MFMeshObject_GetObjectLevelPropertyPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_getobjectlevelproperty");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetObjectLevelProperty = (PLib3MFMeshObject_GetObjectLevelPropertyPtr) dlsym(hLibrary, "lib3mf_meshobject_getobjectlevelproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetObjectLevelProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetTriangleProperties = (PLib3MFMeshObject_SetTrianglePropertiesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_settriangleproperties");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetTriangleProperties = (PLib3MFMeshObject_SetTrianglePropertiesPtr) dlsym(hLibrary, "lib3mf_meshobject_settriangleproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetTriangleProperties == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangleProperties = (PLib3MFMeshObject_GetTrianglePropertiesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_gettriangleproperties");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangleProperties = (PLib3MFMeshObject_GetTrianglePropertiesPtr) dlsym(hLibrary, "lib3mf_meshobject_gettriangleproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangleProperties == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetAllTriangleProperties = (PLib3MFMeshObject_SetAllTrianglePropertiesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_setalltriangleproperties");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetAllTriangleProperties = (PLib3MFMeshObject_SetAllTrianglePropertiesPtr) dlsym(hLibrary, "lib3mf_meshobject_setalltriangleproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetAllTriangleProperties == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetAllTriangleProperties = (PLib3MFMeshObject_GetAllTrianglePropertiesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_getalltriangleproperties");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetAllTriangleProperties = (PLib3MFMeshObject_GetAllTrianglePropertiesPtr) dlsym(hLibrary, "lib3mf_meshobject_getalltriangleproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetAllTriangleProperties == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_ClearAllProperties = (PLib3MFMeshObject_ClearAllPropertiesPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_clearallproperties");
		#else // _WIN32
		pWrapperTable->m_MeshObject_ClearAllProperties = (PLib3MFMeshObject_ClearAllPropertiesPtr) dlsym(hLibrary, "lib3mf_meshobject_clearallproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_ClearAllProperties == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_SetGeometry = (PLib3MFMeshObject_SetGeometryPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_setgeometry");
		#else // _WIN32
		pWrapperTable->m_MeshObject_SetGeometry = (PLib3MFMeshObject_SetGeometryPtr) dlsym(hLibrary, "lib3mf_meshobject_setgeometry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_SetGeometry == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_IsManifoldAndOriented = (PLib3MFMeshObject_IsManifoldAndOrientedPtr) GetProcAddress(hLibrary, "lib3mf_meshobject_ismanifoldandoriented");
		#else // _WIN32
		pWrapperTable->m_MeshObject_IsManifoldAndOriented = (PLib3MFMeshObject_IsManifoldAndOrientedPtr) dlsym(hLibrary, "lib3mf_meshobject_ismanifoldandoriented");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_IsManifoldAndOriented == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_BeamLattice = (PLib3MFMeshObject_BeamLatticePtr) GetProcAddress(hLibrary, "lib3mf_meshobject_beamlattice");
		#else // _WIN32
		pWrapperTable->m_MeshObject_BeamLattice = (PLib3MFMeshObject_BeamLatticePtr) dlsym(hLibrary, "lib3mf_meshobject_beamlattice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_BeamLattice == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetMinLength = (PLib3MFBeamLattice_GetMinLengthPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getminlength");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetMinLength = (PLib3MFBeamLattice_GetMinLengthPtr) dlsym(hLibrary, "lib3mf_beamlattice_getminlength");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetMinLength == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetMinLength = (PLib3MFBeamLattice_SetMinLengthPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setminlength");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetMinLength = (PLib3MFBeamLattice_SetMinLengthPtr) dlsym(hLibrary, "lib3mf_beamlattice_setminlength");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetMinLength == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetClipping = (PLib3MFBeamLattice_GetClippingPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getclipping");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetClipping = (PLib3MFBeamLattice_GetClippingPtr) dlsym(hLibrary, "lib3mf_beamlattice_getclipping");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetClipping == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetClipping = (PLib3MFBeamLattice_SetClippingPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setclipping");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetClipping = (PLib3MFBeamLattice_SetClippingPtr) dlsym(hLibrary, "lib3mf_beamlattice_setclipping");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetClipping == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetRepresentation = (PLib3MFBeamLattice_GetRepresentationPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getrepresentation");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetRepresentation = (PLib3MFBeamLattice_GetRepresentationPtr) dlsym(hLibrary, "lib3mf_beamlattice_getrepresentation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetRepresentation == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetRepresentation = (PLib3MFBeamLattice_SetRepresentationPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setrepresentation");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetRepresentation = (PLib3MFBeamLattice_SetRepresentationPtr) dlsym(hLibrary, "lib3mf_beamlattice_setrepresentation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetRepresentation == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBallOptions = (PLib3MFBeamLattice_GetBallOptionsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getballoptions");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBallOptions = (PLib3MFBeamLattice_GetBallOptionsPtr) dlsym(hLibrary, "lib3mf_beamlattice_getballoptions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBallOptions == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetBallOptions = (PLib3MFBeamLattice_SetBallOptionsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setballoptions");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetBallOptions = (PLib3MFBeamLattice_SetBallOptionsPtr) dlsym(hLibrary, "lib3mf_beamlattice_setballoptions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetBallOptions == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBeamCount = (PLib3MFBeamLattice_GetBeamCountPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getbeamcount");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBeamCount = (PLib3MFBeamLattice_GetBeamCountPtr) dlsym(hLibrary, "lib3mf_beamlattice_getbeamcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBeamCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBeam = (PLib3MFBeamLattice_GetBeamPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getbeam");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBeam = (PLib3MFBeamLattice_GetBeamPtr) dlsym(hLibrary, "lib3mf_beamlattice_getbeam");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBeam == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_AddBeam = (PLib3MFBeamLattice_AddBeamPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_addbeam");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_AddBeam = (PLib3MFBeamLattice_AddBeamPtr) dlsym(hLibrary, "lib3mf_beamlattice_addbeam");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_AddBeam == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetBeam = (PLib3MFBeamLattice_SetBeamPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setbeam");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetBeam = (PLib3MFBeamLattice_SetBeamPtr) dlsym(hLibrary, "lib3mf_beamlattice_setbeam");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetBeam == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetBeams = (PLib3MFBeamLattice_SetBeamsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setbeams");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetBeams = (PLib3MFBeamLattice_SetBeamsPtr) dlsym(hLibrary, "lib3mf_beamlattice_setbeams");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetBeams == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBeams = (PLib3MFBeamLattice_GetBeamsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getbeams");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBeams = (PLib3MFBeamLattice_GetBeamsPtr) dlsym(hLibrary, "lib3mf_beamlattice_getbeams");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBeams == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBallCount = (PLib3MFBeamLattice_GetBallCountPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getballcount");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBallCount = (PLib3MFBeamLattice_GetBallCountPtr) dlsym(hLibrary, "lib3mf_beamlattice_getballcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBallCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBall = (PLib3MFBeamLattice_GetBallPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getball");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBall = (PLib3MFBeamLattice_GetBallPtr) dlsym(hLibrary, "lib3mf_beamlattice_getball");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBall == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_AddBall = (PLib3MFBeamLattice_AddBallPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_addball");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_AddBall = (PLib3MFBeamLattice_AddBallPtr) dlsym(hLibrary, "lib3mf_beamlattice_addball");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_AddBall == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetBall = (PLib3MFBeamLattice_SetBallPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setball");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetBall = (PLib3MFBeamLattice_SetBallPtr) dlsym(hLibrary, "lib3mf_beamlattice_setball");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetBall == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_SetBalls = (PLib3MFBeamLattice_SetBallsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_setballs");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_SetBalls = (PLib3MFBeamLattice_SetBallsPtr) dlsym(hLibrary, "lib3mf_beamlattice_setballs");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_SetBalls == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBalls = (PLib3MFBeamLattice_GetBallsPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getballs");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBalls = (PLib3MFBeamLattice_GetBallsPtr) dlsym(hLibrary, "lib3mf_beamlattice_getballs");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBalls == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBeamSetCount = (PLib3MFBeamLattice_GetBeamSetCountPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getbeamsetcount");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBeamSetCount = (PLib3MFBeamLattice_GetBeamSetCountPtr) dlsym(hLibrary, "lib3mf_beamlattice_getbeamsetcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBeamSetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_AddBeamSet = (PLib3MFBeamLattice_AddBeamSetPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_addbeamset");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_AddBeamSet = (PLib3MFBeamLattice_AddBeamSetPtr) dlsym(hLibrary, "lib3mf_beamlattice_addbeamset");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_AddBeamSet == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamLattice_GetBeamSet = (PLib3MFBeamLattice_GetBeamSetPtr) GetProcAddress(hLibrary, "lib3mf_beamlattice_getbeamset");
		#else // _WIN32
		pWrapperTable->m_BeamLattice_GetBeamSet = (PLib3MFBeamLattice_GetBeamSetPtr) dlsym(hLibrary, "lib3mf_beamlattice_getbeamset");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamLattice_GetBeamSet == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_GetObjectResource = (PLib3MFComponent_GetObjectResourcePtr) GetProcAddress(hLibrary, "lib3mf_component_getobjectresource");
		#else // _WIN32
		pWrapperTable->m_Component_GetObjectResource = (PLib3MFComponent_GetObjectResourcePtr) dlsym(hLibrary, "lib3mf_component_getobjectresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_GetObjectResource == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_GetObjectResourceID = (PLib3MFComponent_GetObjectResourceIDPtr) GetProcAddress(hLibrary, "lib3mf_component_getobjectresourceid");
		#else // _WIN32
		pWrapperTable->m_Component_GetObjectResourceID = (PLib3MFComponent_GetObjectResourceIDPtr) dlsym(hLibrary, "lib3mf_component_getobjectresourceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_GetObjectResourceID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_GetUUID = (PLib3MFComponent_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_component_getuuid");
		#else // _WIN32
		pWrapperTable->m_Component_GetUUID = (PLib3MFComponent_GetUUIDPtr) dlsym(hLibrary, "lib3mf_component_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_SetUUID = (PLib3MFComponent_SetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_component_setuuid");
		#else // _WIN32
		pWrapperTable->m_Component_SetUUID = (PLib3MFComponent_SetUUIDPtr) dlsym(hLibrary, "lib3mf_component_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_SetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_HasTransform = (PLib3MFComponent_HasTransformPtr) GetProcAddress(hLibrary, "lib3mf_component_hastransform");
		#else // _WIN32
		pWrapperTable->m_Component_HasTransform = (PLib3MFComponent_HasTransformPtr) dlsym(hLibrary, "lib3mf_component_hastransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_HasTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_GetTransform = (PLib3MFComponent_GetTransformPtr) GetProcAddress(hLibrary, "lib3mf_component_gettransform");
		#else // _WIN32
		pWrapperTable->m_Component_GetTransform = (PLib3MFComponent_GetTransformPtr) dlsym(hLibrary, "lib3mf_component_gettransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_GetTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Component_SetTransform = (PLib3MFComponent_SetTransformPtr) GetProcAddress(hLibrary, "lib3mf_component_settransform");
		#else // _WIN32
		pWrapperTable->m_Component_SetTransform = (PLib3MFComponent_SetTransformPtr) dlsym(hLibrary, "lib3mf_component_settransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Component_SetTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ComponentsObject_AddComponent = (PLib3MFComponentsObject_AddComponentPtr) GetProcAddress(hLibrary, "lib3mf_componentsobject_addcomponent");
		#else // _WIN32
		pWrapperTable->m_ComponentsObject_AddComponent = (PLib3MFComponentsObject_AddComponentPtr) dlsym(hLibrary, "lib3mf_componentsobject_addcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ComponentsObject_AddComponent == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ComponentsObject_GetComponent = (PLib3MFComponentsObject_GetComponentPtr) GetProcAddress(hLibrary, "lib3mf_componentsobject_getcomponent");
		#else // _WIN32
		pWrapperTable->m_ComponentsObject_GetComponent = (PLib3MFComponentsObject_GetComponentPtr) dlsym(hLibrary, "lib3mf_componentsobject_getcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ComponentsObject_GetComponent == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ComponentsObject_GetComponentCount = (PLib3MFComponentsObject_GetComponentCountPtr) GetProcAddress(hLibrary, "lib3mf_componentsobject_getcomponentcount");
		#else // _WIN32
		pWrapperTable->m_ComponentsObject_GetComponentCount = (PLib3MFComponentsObject_GetComponentCountPtr) dlsym(hLibrary, "lib3mf_componentsobject_getcomponentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ComponentsObject_GetComponentCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_SetName = (PLib3MFBeamSet_SetNamePtr) GetProcAddress(hLibrary, "lib3mf_beamset_setname");
		#else // _WIN32
		pWrapperTable->m_BeamSet_SetName = (PLib3MFBeamSet_SetNamePtr) dlsym(hLibrary, "lib3mf_beamset_setname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_SetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetName = (PLib3MFBeamSet_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_beamset_getname");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetName = (PLib3MFBeamSet_GetNamePtr) dlsym(hLibrary, "lib3mf_beamset_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_SetIdentifier = (PLib3MFBeamSet_SetIdentifierPtr) GetProcAddress(hLibrary, "lib3mf_beamset_setidentifier");
		#else // _WIN32
		pWrapperTable->m_BeamSet_SetIdentifier = (PLib3MFBeamSet_SetIdentifierPtr) dlsym(hLibrary, "lib3mf_beamset_setidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_SetIdentifier == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetIdentifier = (PLib3MFBeamSet_GetIdentifierPtr) GetProcAddress(hLibrary, "lib3mf_beamset_getidentifier");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetIdentifier = (PLib3MFBeamSet_GetIdentifierPtr) dlsym(hLibrary, "lib3mf_beamset_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetIdentifier == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetReferenceCount = (PLib3MFBeamSet_GetReferenceCountPtr) GetProcAddress(hLibrary, "lib3mf_beamset_getreferencecount");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetReferenceCount = (PLib3MFBeamSet_GetReferenceCountPtr) dlsym(hLibrary, "lib3mf_beamset_getreferencecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetReferenceCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_SetReferences = (PLib3MFBeamSet_SetReferencesPtr) GetProcAddress(hLibrary, "lib3mf_beamset_setreferences");
		#else // _WIN32
		pWrapperTable->m_BeamSet_SetReferences = (PLib3MFBeamSet_SetReferencesPtr) dlsym(hLibrary, "lib3mf_beamset_setreferences");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_SetReferences == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetReferences = (PLib3MFBeamSet_GetReferencesPtr) GetProcAddress(hLibrary, "lib3mf_beamset_getreferences");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetReferences = (PLib3MFBeamSet_GetReferencesPtr) dlsym(hLibrary, "lib3mf_beamset_getreferences");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetReferences == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetBallReferenceCount = (PLib3MFBeamSet_GetBallReferenceCountPtr) GetProcAddress(hLibrary, "lib3mf_beamset_getballreferencecount");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetBallReferenceCount = (PLib3MFBeamSet_GetBallReferenceCountPtr) dlsym(hLibrary, "lib3mf_beamset_getballreferencecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetBallReferenceCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_SetBallReferences = (PLib3MFBeamSet_SetBallReferencesPtr) GetProcAddress(hLibrary, "lib3mf_beamset_setballreferences");
		#else // _WIN32
		pWrapperTable->m_BeamSet_SetBallReferences = (PLib3MFBeamSet_SetBallReferencesPtr) dlsym(hLibrary, "lib3mf_beamset_setballreferences");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_SetBallReferences == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BeamSet_GetBallReferences = (PLib3MFBeamSet_GetBallReferencesPtr) GetProcAddress(hLibrary, "lib3mf_beamset_getballreferences");
		#else // _WIN32
		pWrapperTable->m_BeamSet_GetBallReferences = (PLib3MFBeamSet_GetBallReferencesPtr) dlsym(hLibrary, "lib3mf_beamset_getballreferences");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BeamSet_GetBallReferences == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetCount = (PLib3MFBaseMaterialGroup_GetCountPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_getcount");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetCount = (PLib3MFBaseMaterialGroup_GetCountPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_GetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs = (PLib3MFBaseMaterialGroup_GetAllPropertyIDsPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_getallpropertyids");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs = (PLib3MFBaseMaterialGroup_GetAllPropertyIDsPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_getallpropertyids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_AddMaterial = (PLib3MFBaseMaterialGroup_AddMaterialPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_addmaterial");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_AddMaterial = (PLib3MFBaseMaterialGroup_AddMaterialPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_addmaterial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_AddMaterial == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_RemoveMaterial = (PLib3MFBaseMaterialGroup_RemoveMaterialPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_removematerial");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_RemoveMaterial = (PLib3MFBaseMaterialGroup_RemoveMaterialPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_removematerial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_RemoveMaterial == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetName = (PLib3MFBaseMaterialGroup_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_getname");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetName = (PLib3MFBaseMaterialGroup_GetNamePtr) dlsym(hLibrary, "lib3mf_basematerialgroup_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_SetName = (PLib3MFBaseMaterialGroup_SetNamePtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_setname");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_SetName = (PLib3MFBaseMaterialGroup_SetNamePtr) dlsym(hLibrary, "lib3mf_basematerialgroup_setname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_SetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_SetDisplayColor = (PLib3MFBaseMaterialGroup_SetDisplayColorPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_setdisplaycolor");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_SetDisplayColor = (PLib3MFBaseMaterialGroup_SetDisplayColorPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_setdisplaycolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_SetDisplayColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetDisplayColor = (PLib3MFBaseMaterialGroup_GetDisplayColorPtr) GetProcAddress(hLibrary, "lib3mf_basematerialgroup_getdisplaycolor");
		#else // _WIN32
		pWrapperTable->m_BaseMaterialGroup_GetDisplayColor = (PLib3MFBaseMaterialGroup_GetDisplayColorPtr) dlsym(hLibrary, "lib3mf_basematerialgroup_getdisplaycolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseMaterialGroup_GetDisplayColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_GetCount = (PLib3MFColorGroup_GetCountPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_getcount");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_GetCount = (PLib3MFColorGroup_GetCountPtr) dlsym(hLibrary, "lib3mf_colorgroup_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_GetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_GetAllPropertyIDs = (PLib3MFColorGroup_GetAllPropertyIDsPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_getallpropertyids");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_GetAllPropertyIDs = (PLib3MFColorGroup_GetAllPropertyIDsPtr) dlsym(hLibrary, "lib3mf_colorgroup_getallpropertyids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_GetAllPropertyIDs == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_AddColor = (PLib3MFColorGroup_AddColorPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_addcolor");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_AddColor = (PLib3MFColorGroup_AddColorPtr) dlsym(hLibrary, "lib3mf_colorgroup_addcolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_AddColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_RemoveColor = (PLib3MFColorGroup_RemoveColorPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_removecolor");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_RemoveColor = (PLib3MFColorGroup_RemoveColorPtr) dlsym(hLibrary, "lib3mf_colorgroup_removecolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_RemoveColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_SetColor = (PLib3MFColorGroup_SetColorPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_setcolor");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_SetColor = (PLib3MFColorGroup_SetColorPtr) dlsym(hLibrary, "lib3mf_colorgroup_setcolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_SetColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorGroup_GetColor = (PLib3MFColorGroup_GetColorPtr) GetProcAddress(hLibrary, "lib3mf_colorgroup_getcolor");
		#else // _WIN32
		pWrapperTable->m_ColorGroup_GetColor = (PLib3MFColorGroup_GetColorPtr) dlsym(hLibrary, "lib3mf_colorgroup_getcolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorGroup_GetColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_GetCount = (PLib3MFTexture2DGroup_GetCountPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_getcount");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_GetCount = (PLib3MFTexture2DGroup_GetCountPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_GetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs = (PLib3MFTexture2DGroup_GetAllPropertyIDsPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_getallpropertyids");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs = (PLib3MFTexture2DGroup_GetAllPropertyIDsPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_getallpropertyids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_AddTex2Coord = (PLib3MFTexture2DGroup_AddTex2CoordPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_addtex2coord");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_AddTex2Coord = (PLib3MFTexture2DGroup_AddTex2CoordPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_addtex2coord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_AddTex2Coord == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_GetTex2Coord = (PLib3MFTexture2DGroup_GetTex2CoordPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_gettex2coord");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_GetTex2Coord = (PLib3MFTexture2DGroup_GetTex2CoordPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_gettex2coord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_GetTex2Coord == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_RemoveTex2Coord = (PLib3MFTexture2DGroup_RemoveTex2CoordPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_removetex2coord");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_RemoveTex2Coord = (PLib3MFTexture2DGroup_RemoveTex2CoordPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_removetex2coord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_RemoveTex2Coord == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2DGroup_GetTexture2D = (PLib3MFTexture2DGroup_GetTexture2DPtr) GetProcAddress(hLibrary, "lib3mf_texture2dgroup_gettexture2d");
		#else // _WIN32
		pWrapperTable->m_Texture2DGroup_GetTexture2D = (PLib3MFTexture2DGroup_GetTexture2DPtr) dlsym(hLibrary, "lib3mf_texture2dgroup_gettexture2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2DGroup_GetTexture2D == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_GetCount = (PLib3MFCompositeMaterials_GetCountPtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_getcount");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_GetCount = (PLib3MFCompositeMaterials_GetCountPtr) dlsym(hLibrary, "lib3mf_compositematerials_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_GetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs = (PLib3MFCompositeMaterials_GetAllPropertyIDsPtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_getallpropertyids");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs = (PLib3MFCompositeMaterials_GetAllPropertyIDsPtr) dlsym(hLibrary, "lib3mf_compositematerials_getallpropertyids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup = (PLib3MFCompositeMaterials_GetBaseMaterialGroupPtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_getbasematerialgroup");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup = (PLib3MFCompositeMaterials_GetBaseMaterialGroupPtr) dlsym(hLibrary, "lib3mf_compositematerials_getbasematerialgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_AddComposite = (PLib3MFCompositeMaterials_AddCompositePtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_addcomposite");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_AddComposite = (PLib3MFCompositeMaterials_AddCompositePtr) dlsym(hLibrary, "lib3mf_compositematerials_addcomposite");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_AddComposite == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_RemoveComposite = (PLib3MFCompositeMaterials_RemoveCompositePtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_removecomposite");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_RemoveComposite = (PLib3MFCompositeMaterials_RemoveCompositePtr) dlsym(hLibrary, "lib3mf_compositematerials_removecomposite");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_RemoveComposite == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CompositeMaterials_GetComposite = (PLib3MFCompositeMaterials_GetCompositePtr) GetProcAddress(hLibrary, "lib3mf_compositematerials_getcomposite");
		#else // _WIN32
		pWrapperTable->m_CompositeMaterials_GetComposite = (PLib3MFCompositeMaterials_GetCompositePtr) dlsym(hLibrary, "lib3mf_compositematerials_getcomposite");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CompositeMaterials_GetComposite == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetCount = (PLib3MFMultiPropertyGroup_GetCountPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_getcount");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetCount = (PLib3MFMultiPropertyGroup_GetCountPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_GetCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs = (PLib3MFMultiPropertyGroup_GetAllPropertyIDsPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_getallpropertyids");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs = (PLib3MFMultiPropertyGroup_GetAllPropertyIDsPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_getallpropertyids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_AddMultiProperty = (PLib3MFMultiPropertyGroup_AddMultiPropertyPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_addmultiproperty");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_AddMultiProperty = (PLib3MFMultiPropertyGroup_AddMultiPropertyPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_addmultiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_AddMultiProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_SetMultiProperty = (PLib3MFMultiPropertyGroup_SetMultiPropertyPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_setmultiproperty");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_SetMultiProperty = (PLib3MFMultiPropertyGroup_SetMultiPropertyPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_setmultiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_SetMultiProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetMultiProperty = (PLib3MFMultiPropertyGroup_GetMultiPropertyPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_getmultiproperty");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetMultiProperty = (PLib3MFMultiPropertyGroup_GetMultiPropertyPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_getmultiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_GetMultiProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty = (PLib3MFMultiPropertyGroup_RemoveMultiPropertyPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_removemultiproperty");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty = (PLib3MFMultiPropertyGroup_RemoveMultiPropertyPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_removemultiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetLayerCount = (PLib3MFMultiPropertyGroup_GetLayerCountPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_getlayercount");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetLayerCount = (PLib3MFMultiPropertyGroup_GetLayerCountPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_GetLayerCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_AddLayer = (PLib3MFMultiPropertyGroup_AddLayerPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_addlayer");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_AddLayer = (PLib3MFMultiPropertyGroup_AddLayerPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_addlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_AddLayer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetLayer = (PLib3MFMultiPropertyGroup_GetLayerPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_getlayer");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_GetLayer = (PLib3MFMultiPropertyGroup_GetLayerPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_getlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_GetLayer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MultiPropertyGroup_RemoveLayer = (PLib3MFMultiPropertyGroup_RemoveLayerPtr) GetProcAddress(hLibrary, "lib3mf_multipropertygroup_removelayer");
		#else // _WIN32
		pWrapperTable->m_MultiPropertyGroup_RemoveLayer = (PLib3MFMultiPropertyGroup_RemoveLayerPtr) dlsym(hLibrary, "lib3mf_multipropertygroup_removelayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MultiPropertyGroup_RemoveLayer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_GetPath = (PLib3MFAttachment_GetPathPtr) GetProcAddress(hLibrary, "lib3mf_attachment_getpath");
		#else // _WIN32
		pWrapperTable->m_Attachment_GetPath = (PLib3MFAttachment_GetPathPtr) dlsym(hLibrary, "lib3mf_attachment_getpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_GetPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_SetPath = (PLib3MFAttachment_SetPathPtr) GetProcAddress(hLibrary, "lib3mf_attachment_setpath");
		#else // _WIN32
		pWrapperTable->m_Attachment_SetPath = (PLib3MFAttachment_SetPathPtr) dlsym(hLibrary, "lib3mf_attachment_setpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_SetPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_PackagePart = (PLib3MFAttachment_PackagePartPtr) GetProcAddress(hLibrary, "lib3mf_attachment_packagepart");
		#else // _WIN32
		pWrapperTable->m_Attachment_PackagePart = (PLib3MFAttachment_PackagePartPtr) dlsym(hLibrary, "lib3mf_attachment_packagepart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_PackagePart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_GetRelationShipType = (PLib3MFAttachment_GetRelationShipTypePtr) GetProcAddress(hLibrary, "lib3mf_attachment_getrelationshiptype");
		#else // _WIN32
		pWrapperTable->m_Attachment_GetRelationShipType = (PLib3MFAttachment_GetRelationShipTypePtr) dlsym(hLibrary, "lib3mf_attachment_getrelationshiptype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_GetRelationShipType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_SetRelationShipType = (PLib3MFAttachment_SetRelationShipTypePtr) GetProcAddress(hLibrary, "lib3mf_attachment_setrelationshiptype");
		#else // _WIN32
		pWrapperTable->m_Attachment_SetRelationShipType = (PLib3MFAttachment_SetRelationShipTypePtr) dlsym(hLibrary, "lib3mf_attachment_setrelationshiptype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_SetRelationShipType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_WriteToFile = (PLib3MFAttachment_WriteToFilePtr) GetProcAddress(hLibrary, "lib3mf_attachment_writetofile");
		#else // _WIN32
		pWrapperTable->m_Attachment_WriteToFile = (PLib3MFAttachment_WriteToFilePtr) dlsym(hLibrary, "lib3mf_attachment_writetofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_WriteToFile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_ReadFromFile = (PLib3MFAttachment_ReadFromFilePtr) GetProcAddress(hLibrary, "lib3mf_attachment_readfromfile");
		#else // _WIN32
		pWrapperTable->m_Attachment_ReadFromFile = (PLib3MFAttachment_ReadFromFilePtr) dlsym(hLibrary, "lib3mf_attachment_readfromfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_ReadFromFile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_ReadFromCallback = (PLib3MFAttachment_ReadFromCallbackPtr) GetProcAddress(hLibrary, "lib3mf_attachment_readfromcallback");
		#else // _WIN32
		pWrapperTable->m_Attachment_ReadFromCallback = (PLib3MFAttachment_ReadFromCallbackPtr) dlsym(hLibrary, "lib3mf_attachment_readfromcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_ReadFromCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_GetStreamSize = (PLib3MFAttachment_GetStreamSizePtr) GetProcAddress(hLibrary, "lib3mf_attachment_getstreamsize");
		#else // _WIN32
		pWrapperTable->m_Attachment_GetStreamSize = (PLib3MFAttachment_GetStreamSizePtr) dlsym(hLibrary, "lib3mf_attachment_getstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_GetStreamSize == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_WriteToBuffer = (PLib3MFAttachment_WriteToBufferPtr) GetProcAddress(hLibrary, "lib3mf_attachment_writetobuffer");
		#else // _WIN32
		pWrapperTable->m_Attachment_WriteToBuffer = (PLib3MFAttachment_WriteToBufferPtr) dlsym(hLibrary, "lib3mf_attachment_writetobuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_WriteToBuffer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Attachment_ReadFromBuffer = (PLib3MFAttachment_ReadFromBufferPtr) GetProcAddress(hLibrary, "lib3mf_attachment_readfrombuffer");
		#else // _WIN32
		pWrapperTable->m_Attachment_ReadFromBuffer = (PLib3MFAttachment_ReadFromBufferPtr) dlsym(hLibrary, "lib3mf_attachment_readfrombuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Attachment_ReadFromBuffer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_GetAttachment = (PLib3MFTexture2D_GetAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_getattachment");
		#else // _WIN32
		pWrapperTable->m_Texture2D_GetAttachment = (PLib3MFTexture2D_GetAttachmentPtr) dlsym(hLibrary, "lib3mf_texture2d_getattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_GetAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_SetAttachment = (PLib3MFTexture2D_SetAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_setattachment");
		#else // _WIN32
		pWrapperTable->m_Texture2D_SetAttachment = (PLib3MFTexture2D_SetAttachmentPtr) dlsym(hLibrary, "lib3mf_texture2d_setattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_SetAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_GetContentType = (PLib3MFTexture2D_GetContentTypePtr) GetProcAddress(hLibrary, "lib3mf_texture2d_getcontenttype");
		#else // _WIN32
		pWrapperTable->m_Texture2D_GetContentType = (PLib3MFTexture2D_GetContentTypePtr) dlsym(hLibrary, "lib3mf_texture2d_getcontenttype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_GetContentType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_SetContentType = (PLib3MFTexture2D_SetContentTypePtr) GetProcAddress(hLibrary, "lib3mf_texture2d_setcontenttype");
		#else // _WIN32
		pWrapperTable->m_Texture2D_SetContentType = (PLib3MFTexture2D_SetContentTypePtr) dlsym(hLibrary, "lib3mf_texture2d_setcontenttype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_SetContentType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_GetTileStyleUV = (PLib3MFTexture2D_GetTileStyleUVPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_gettilestyleuv");
		#else // _WIN32
		pWrapperTable->m_Texture2D_GetTileStyleUV = (PLib3MFTexture2D_GetTileStyleUVPtr) dlsym(hLibrary, "lib3mf_texture2d_gettilestyleuv");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_GetTileStyleUV == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_SetTileStyleUV = (PLib3MFTexture2D_SetTileStyleUVPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_settilestyleuv");
		#else // _WIN32
		pWrapperTable->m_Texture2D_SetTileStyleUV = (PLib3MFTexture2D_SetTileStyleUVPtr) dlsym(hLibrary, "lib3mf_texture2d_settilestyleuv");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_SetTileStyleUV == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_GetFilter = (PLib3MFTexture2D_GetFilterPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_getfilter");
		#else // _WIN32
		pWrapperTable->m_Texture2D_GetFilter = (PLib3MFTexture2D_GetFilterPtr) dlsym(hLibrary, "lib3mf_texture2d_getfilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_GetFilter == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Texture2D_SetFilter = (PLib3MFTexture2D_SetFilterPtr) GetProcAddress(hLibrary, "lib3mf_texture2d_setfilter");
		#else // _WIN32
		pWrapperTable->m_Texture2D_SetFilter = (PLib3MFTexture2D_SetFilterPtr) dlsym(hLibrary, "lib3mf_texture2d_setfilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Texture2D_SetFilter == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetObjectResource = (PLib3MFBuildItem_GetObjectResourcePtr) GetProcAddress(hLibrary, "lib3mf_builditem_getobjectresource");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetObjectResource = (PLib3MFBuildItem_GetObjectResourcePtr) dlsym(hLibrary, "lib3mf_builditem_getobjectresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetObjectResource == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetUUID = (PLib3MFBuildItem_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetUUID = (PLib3MFBuildItem_GetUUIDPtr) dlsym(hLibrary, "lib3mf_builditem_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_SetUUID = (PLib3MFBuildItem_SetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_builditem_setuuid");
		#else // _WIN32
		pWrapperTable->m_BuildItem_SetUUID = (PLib3MFBuildItem_SetUUIDPtr) dlsym(hLibrary, "lib3mf_builditem_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_SetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetObjectResourceID = (PLib3MFBuildItem_GetObjectResourceIDPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getobjectresourceid");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetObjectResourceID = (PLib3MFBuildItem_GetObjectResourceIDPtr) dlsym(hLibrary, "lib3mf_builditem_getobjectresourceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetObjectResourceID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_HasObjectTransform = (PLib3MFBuildItem_HasObjectTransformPtr) GetProcAddress(hLibrary, "lib3mf_builditem_hasobjecttransform");
		#else // _WIN32
		pWrapperTable->m_BuildItem_HasObjectTransform = (PLib3MFBuildItem_HasObjectTransformPtr) dlsym(hLibrary, "lib3mf_builditem_hasobjecttransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_HasObjectTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetObjectTransform = (PLib3MFBuildItem_GetObjectTransformPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getobjecttransform");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetObjectTransform = (PLib3MFBuildItem_GetObjectTransformPtr) dlsym(hLibrary, "lib3mf_builditem_getobjecttransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetObjectTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_SetObjectTransform = (PLib3MFBuildItem_SetObjectTransformPtr) GetProcAddress(hLibrary, "lib3mf_builditem_setobjecttransform");
		#else // _WIN32
		pWrapperTable->m_BuildItem_SetObjectTransform = (PLib3MFBuildItem_SetObjectTransformPtr) dlsym(hLibrary, "lib3mf_builditem_setobjecttransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_SetObjectTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetPartNumber = (PLib3MFBuildItem_GetPartNumberPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getpartnumber");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetPartNumber = (PLib3MFBuildItem_GetPartNumberPtr) dlsym(hLibrary, "lib3mf_builditem_getpartnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetPartNumber == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_SetPartNumber = (PLib3MFBuildItem_SetPartNumberPtr) GetProcAddress(hLibrary, "lib3mf_builditem_setpartnumber");
		#else // _WIN32
		pWrapperTable->m_BuildItem_SetPartNumber = (PLib3MFBuildItem_SetPartNumberPtr) dlsym(hLibrary, "lib3mf_builditem_setpartnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_SetPartNumber == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetMetaDataGroup = (PLib3MFBuildItem_GetMetaDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getmetadatagroup");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetMetaDataGroup = (PLib3MFBuildItem_GetMetaDataGroupPtr) dlsym(hLibrary, "lib3mf_builditem_getmetadatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetMetaDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItem_GetOutbox = (PLib3MFBuildItem_GetOutboxPtr) GetProcAddress(hLibrary, "lib3mf_builditem_getoutbox");
		#else // _WIN32
		pWrapperTable->m_BuildItem_GetOutbox = (PLib3MFBuildItem_GetOutboxPtr) dlsym(hLibrary, "lib3mf_builditem_getoutbox");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItem_GetOutbox == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItemIterator_MoveNext = (PLib3MFBuildItemIterator_MoveNextPtr) GetProcAddress(hLibrary, "lib3mf_builditemiterator_movenext");
		#else // _WIN32
		pWrapperTable->m_BuildItemIterator_MoveNext = (PLib3MFBuildItemIterator_MoveNextPtr) dlsym(hLibrary, "lib3mf_builditemiterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItemIterator_MoveNext == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItemIterator_MovePrevious = (PLib3MFBuildItemIterator_MovePreviousPtr) GetProcAddress(hLibrary, "lib3mf_builditemiterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_BuildItemIterator_MovePrevious = (PLib3MFBuildItemIterator_MovePreviousPtr) dlsym(hLibrary, "lib3mf_builditemiterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItemIterator_MovePrevious == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItemIterator_GetCurrent = (PLib3MFBuildItemIterator_GetCurrentPtr) GetProcAddress(hLibrary, "lib3mf_builditemiterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_BuildItemIterator_GetCurrent = (PLib3MFBuildItemIterator_GetCurrentPtr) dlsym(hLibrary, "lib3mf_builditemiterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItemIterator_GetCurrent == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItemIterator_Clone = (PLib3MFBuildItemIterator_ClonePtr) GetProcAddress(hLibrary, "lib3mf_builditemiterator_clone");
		#else // _WIN32
		pWrapperTable->m_BuildItemIterator_Clone = (PLib3MFBuildItemIterator_ClonePtr) dlsym(hLibrary, "lib3mf_builditemiterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItemIterator_Clone == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildItemIterator_Count = (PLib3MFBuildItemIterator_CountPtr) GetProcAddress(hLibrary, "lib3mf_builditemiterator_count");
		#else // _WIN32
		pWrapperTable->m_BuildItemIterator_Count = (PLib3MFBuildItemIterator_CountPtr) dlsym(hLibrary, "lib3mf_builditemiterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildItemIterator_Count == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_SetVertices = (PLib3MFSlice_SetVerticesPtr) GetProcAddress(hLibrary, "lib3mf_slice_setvertices");
		#else // _WIN32
		pWrapperTable->m_Slice_SetVertices = (PLib3MFSlice_SetVerticesPtr) dlsym(hLibrary, "lib3mf_slice_setvertices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_SetVertices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetVertices = (PLib3MFSlice_GetVerticesPtr) GetProcAddress(hLibrary, "lib3mf_slice_getvertices");
		#else // _WIN32
		pWrapperTable->m_Slice_GetVertices = (PLib3MFSlice_GetVerticesPtr) dlsym(hLibrary, "lib3mf_slice_getvertices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetVertices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetVertexCount = (PLib3MFSlice_GetVertexCountPtr) GetProcAddress(hLibrary, "lib3mf_slice_getvertexcount");
		#else // _WIN32
		pWrapperTable->m_Slice_GetVertexCount = (PLib3MFSlice_GetVertexCountPtr) dlsym(hLibrary, "lib3mf_slice_getvertexcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetVertexCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_AddPolygon = (PLib3MFSlice_AddPolygonPtr) GetProcAddress(hLibrary, "lib3mf_slice_addpolygon");
		#else // _WIN32
		pWrapperTable->m_Slice_AddPolygon = (PLib3MFSlice_AddPolygonPtr) dlsym(hLibrary, "lib3mf_slice_addpolygon");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_AddPolygon == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetPolygonCount = (PLib3MFSlice_GetPolygonCountPtr) GetProcAddress(hLibrary, "lib3mf_slice_getpolygoncount");
		#else // _WIN32
		pWrapperTable->m_Slice_GetPolygonCount = (PLib3MFSlice_GetPolygonCountPtr) dlsym(hLibrary, "lib3mf_slice_getpolygoncount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetPolygonCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_SetPolygonIndices = (PLib3MFSlice_SetPolygonIndicesPtr) GetProcAddress(hLibrary, "lib3mf_slice_setpolygonindices");
		#else // _WIN32
		pWrapperTable->m_Slice_SetPolygonIndices = (PLib3MFSlice_SetPolygonIndicesPtr) dlsym(hLibrary, "lib3mf_slice_setpolygonindices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_SetPolygonIndices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetPolygonIndices = (PLib3MFSlice_GetPolygonIndicesPtr) GetProcAddress(hLibrary, "lib3mf_slice_getpolygonindices");
		#else // _WIN32
		pWrapperTable->m_Slice_GetPolygonIndices = (PLib3MFSlice_GetPolygonIndicesPtr) dlsym(hLibrary, "lib3mf_slice_getpolygonindices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetPolygonIndices == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetPolygonIndexCount = (PLib3MFSlice_GetPolygonIndexCountPtr) GetProcAddress(hLibrary, "lib3mf_slice_getpolygonindexcount");
		#else // _WIN32
		pWrapperTable->m_Slice_GetPolygonIndexCount = (PLib3MFSlice_GetPolygonIndexCountPtr) dlsym(hLibrary, "lib3mf_slice_getpolygonindexcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetPolygonIndexCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Slice_GetZTop = (PLib3MFSlice_GetZTopPtr) GetProcAddress(hLibrary, "lib3mf_slice_getztop");
		#else // _WIN32
		pWrapperTable->m_Slice_GetZTop = (PLib3MFSlice_GetZTopPtr) dlsym(hLibrary, "lib3mf_slice_getztop");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Slice_GetZTop == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetUUID = (PLib3MFToolpathProfile_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetUUID = (PLib3MFToolpathProfile_GetUUIDPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetName = (PLib3MFToolpathProfile_GetNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getname");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetName = (PLib3MFToolpathProfile_GetNamePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterCount = (PLib3MFToolpathProfile_GetParameterCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparametercount");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterCount = (PLib3MFToolpathProfile_GetParameterCountPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparametercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterName = (PLib3MFToolpathProfile_GetParameterNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparametername");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterName = (PLib3MFToolpathProfile_GetParameterNamePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparametername");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterNameSpace = (PLib3MFToolpathProfile_GetParameterNameSpacePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameternamespace");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterNameSpace = (PLib3MFToolpathProfile_GetParameterNameSpacePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameternamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterNameSpace == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_HasParameterValue = (PLib3MFToolpathProfile_HasParameterValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_hasparametervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_HasParameterValue = (PLib3MFToolpathProfile_HasParameterValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_hasparametervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_HasParameterValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterValue = (PLib3MFToolpathProfile_GetParameterValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparametervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterValue = (PLib3MFToolpathProfile_GetParameterValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparametervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterValueDef = (PLib3MFToolpathProfile_GetParameterValueDefPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparametervaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterValueDef = (PLib3MFToolpathProfile_GetParameterValueDefPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparametervaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterValueDef == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue = (PLib3MFToolpathProfile_GetParameterDoubleValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterdoublevalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue = (PLib3MFToolpathProfile_GetParameterDoubleValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef = (PLib3MFToolpathProfile_GetParameterDoubleValueDefPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterdoublevaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef = (PLib3MFToolpathProfile_GetParameterDoubleValueDefPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterdoublevaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue = (PLib3MFToolpathProfile_GetParameterIntegerValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterintegervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue = (PLib3MFToolpathProfile_GetParameterIntegerValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef = (PLib3MFToolpathProfile_GetParameterIntegerValueDefPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterintegervaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef = (PLib3MFToolpathProfile_GetParameterIntegerValueDefPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterintegervaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValue = (PLib3MFToolpathProfile_GetParameterBoolValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterboolvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValue = (PLib3MFToolpathProfile_GetParameterBoolValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterBoolValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef = (PLib3MFToolpathProfile_GetParameterBoolValueDefPtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_getparameterboolvaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef = (PLib3MFToolpathProfile_GetParameterBoolValueDefPtr) dlsym(hLibrary, "lib3mf_toolpathprofile_getparameterboolvaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_SetName = (PLib3MFToolpathProfile_SetNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_setname");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_SetName = (PLib3MFToolpathProfile_SetNamePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_setname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_SetName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterValue = (PLib3MFToolpathProfile_SetParameterValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_setparametervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterValue = (PLib3MFToolpathProfile_SetParameterValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_setparametervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_SetParameterValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue = (PLib3MFToolpathProfile_SetParameterDoubleValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_setparameterdoublevalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue = (PLib3MFToolpathProfile_SetParameterDoubleValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_setparameterdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue = (PLib3MFToolpathProfile_SetParameterIntegerValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_setparameterintegervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue = (PLib3MFToolpathProfile_SetParameterIntegerValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_setparameterintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterBoolValue = (PLib3MFToolpathProfile_SetParameterBoolValuePtr) GetProcAddress(hLibrary, "lib3mf_toolpathprofile_setparameterboolvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathProfile_SetParameterBoolValue = (PLib3MFToolpathProfile_SetParameterBoolValuePtr) dlsym(hLibrary, "lib3mf_toolpathprofile_setparameterboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathProfile_SetParameterBoolValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID = (PLib3MFToolpathLayerReader_GetLayerDataUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getlayerdatauuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID = (PLib3MFToolpathLayerReader_GetLayerDataUUIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getlayerdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentCount = (PLib3MFToolpathLayerReader_GetSegmentCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentCount = (PLib3MFToolpathLayerReader_GetSegmentCountPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo = (PLib3MFToolpathLayerReader_GetSegmentInfoPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentinfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo = (PLib3MFToolpathLayerReader_GetSegmentInfoPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile = (PLib3MFToolpathLayerReader_GetSegmentProfilePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentprofile");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile = (PLib3MFToolpathLayerReader_GetSegmentProfilePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentprofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID = (PLib3MFToolpathLayerReader_GetSegmentProfileUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentprofileuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID = (PLib3MFToolpathLayerReader_GetSegmentProfileUUIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentprofileuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPart = (PLib3MFToolpathLayerReader_GetSegmentPartPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpart");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPart = (PLib3MFToolpathLayerReader_GetSegmentPartPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentPart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID = (PLib3MFToolpathLayerReader_GetSegmentPartUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpartuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID = (PLib3MFToolpathLayerReader_GetSegmentPartUUIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpartuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData = (PLib3MFToolpathLayerReader_GetSegmentPointDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpointdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData = (PLib3MFToolpathLayerReader_GetSegmentPointDataPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentpointdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName = (PLib3MFToolpathLayerReader_FindAttributeInfoByNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_findattributeinfobyname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName = (PLib3MFToolpathLayerReader_FindAttributeInfoByNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_findattributeinfobyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName = (PLib3MFToolpathLayerReader_FindAttributeIDByNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_findattributeidbyname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName = (PLib3MFToolpathLayerReader_FindAttributeIDByNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_findattributeidbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName = (PLib3MFToolpathLayerReader_FindAttributeValueByNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_findattributevaluebyname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName = (PLib3MFToolpathLayerReader_FindAttributeValueByNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_findattributevaluebyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID = (PLib3MFToolpathLayerReader_GetSegmentIntegerAttributeByIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentintegerattributebyid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID = (PLib3MFToolpathLayerReader_GetSegmentIntegerAttributeByIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentintegerattributebyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName = (PLib3MFToolpathLayerReader_GetSegmentIntegerAttributeByNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentintegerattributebyname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName = (PLib3MFToolpathLayerReader_GetSegmentIntegerAttributeByNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentintegerattributebyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID = (PLib3MFToolpathLayerReader_GetSegmentDoubleAttributeByIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentdoubleattributebyid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID = (PLib3MFToolpathLayerReader_GetSegmentDoubleAttributeByIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentdoubleattributebyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName = (PLib3MFToolpathLayerReader_GetSegmentDoubleAttributeByNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getsegmentdoubleattributebyname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName = (PLib3MFToolpathLayerReader_GetSegmentDoubleAttributeByNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getsegmentdoubleattributebyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount = (PLib3MFToolpathLayerReader_GetCustomDataCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getcustomdatacount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount = (PLib3MFToolpathLayerReader_GetCustomDataCountPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getcustomdatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomData = (PLib3MFToolpathLayerReader_GetCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getcustomdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomData = (PLib3MFToolpathLayerReader_GetCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getcustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataName = (PLib3MFToolpathLayerReader_GetCustomDataNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerreader_getcustomdataname");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerReader_GetCustomDataName = (PLib3MFToolpathLayerReader_GetCustomDataNamePtr) dlsym(hLibrary, "lib3mf_toolpathlayerreader_getcustomdataname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerReader_GetCustomDataName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID = (PLib3MFToolpathLayerData_GetLayerDataUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_getlayerdatauuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID = (PLib3MFToolpathLayerData_GetLayerDataUUIDPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_getlayerdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_RegisterProfile = (PLib3MFToolpathLayerData_RegisterProfilePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_registerprofile");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_RegisterProfile = (PLib3MFToolpathLayerData_RegisterProfilePtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_registerprofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_RegisterProfile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_RegisterBuildItem = (PLib3MFToolpathLayerData_RegisterBuildItemPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_registerbuilditem");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_RegisterBuildItem = (PLib3MFToolpathLayerData_RegisterBuildItemPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_registerbuilditem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_RegisterBuildItem == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute = (PLib3MFToolpathLayerData_SetSegmentAttributePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_setsegmentattribute");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute = (PLib3MFToolpathLayerData_SetSegmentAttributePtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_setsegmentattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes = (PLib3MFToolpathLayerData_ClearSegmentAttributesPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_clearsegmentattributes");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes = (PLib3MFToolpathLayerData_ClearSegmentAttributesPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_clearsegmentattributes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_WriteHatchData = (PLib3MFToolpathLayerData_WriteHatchDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_writehatchdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_WriteHatchData = (PLib3MFToolpathLayerData_WriteHatchDataPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_writehatchdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_WriteHatchData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_WriteLoop = (PLib3MFToolpathLayerData_WriteLoopPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_writeloop");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_WriteLoop = (PLib3MFToolpathLayerData_WriteLoopPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_writeloop");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_WriteLoop == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_WritePolyline = (PLib3MFToolpathLayerData_WritePolylinePtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_writepolyline");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_WritePolyline = (PLib3MFToolpathLayerData_WritePolylinePtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_writepolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_WritePolyline == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_AddCustomData = (PLib3MFToolpathLayerData_AddCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_addcustomdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_AddCustomData = (PLib3MFToolpathLayerData_AddCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_addcustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_AddCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayerData_Finish = (PLib3MFToolpathLayerData_FinishPtr) GetProcAddress(hLibrary, "lib3mf_toolpathlayerdata_finish");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayerData_Finish = (PLib3MFToolpathLayerData_FinishPtr) dlsym(hLibrary, "lib3mf_toolpathlayerdata_finish");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayerData_Finish == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetUnits = (PLib3MFToolpath_GetUnitsPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getunits");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetUnits = (PLib3MFToolpath_GetUnitsPtr) dlsym(hLibrary, "lib3mf_toolpath_getunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetUnits == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetLayerCount = (PLib3MFToolpath_GetLayerCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getlayercount");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetLayerCount = (PLib3MFToolpath_GetLayerCountPtr) dlsym(hLibrary, "lib3mf_toolpath_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetLayerCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetProfileCount = (PLib3MFToolpath_GetProfileCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getprofilecount");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetProfileCount = (PLib3MFToolpath_GetProfileCountPtr) dlsym(hLibrary, "lib3mf_toolpath_getprofilecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetProfileCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_AddLayer = (PLib3MFToolpath_AddLayerPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_addlayer");
		#else // _WIN32
		pWrapperTable->m_Toolpath_AddLayer = (PLib3MFToolpath_AddLayerPtr) dlsym(hLibrary, "lib3mf_toolpath_addlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_AddLayer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetLayerAttachment = (PLib3MFToolpath_GetLayerAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getlayerattachment");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetLayerAttachment = (PLib3MFToolpath_GetLayerAttachmentPtr) dlsym(hLibrary, "lib3mf_toolpath_getlayerattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetLayerAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_ReadLayerData = (PLib3MFToolpath_ReadLayerDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_readlayerdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_ReadLayerData = (PLib3MFToolpath_ReadLayerDataPtr) dlsym(hLibrary, "lib3mf_toolpath_readlayerdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_ReadLayerData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetLayerPath = (PLib3MFToolpath_GetLayerPathPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getlayerpath");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetLayerPath = (PLib3MFToolpath_GetLayerPathPtr) dlsym(hLibrary, "lib3mf_toolpath_getlayerpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetLayerPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetLayerZMax = (PLib3MFToolpath_GetLayerZMaxPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getlayerzmax");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetLayerZMax = (PLib3MFToolpath_GetLayerZMaxPtr) dlsym(hLibrary, "lib3mf_toolpath_getlayerzmax");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetLayerZMax == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetLayerZ = (PLib3MFToolpath_GetLayerZPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getlayerz");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetLayerZ = (PLib3MFToolpath_GetLayerZPtr) dlsym(hLibrary, "lib3mf_toolpath_getlayerz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetLayerZ == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_AddProfile = (PLib3MFToolpath_AddProfilePtr) GetProcAddress(hLibrary, "lib3mf_toolpath_addprofile");
		#else // _WIN32
		pWrapperTable->m_Toolpath_AddProfile = (PLib3MFToolpath_AddProfilePtr) dlsym(hLibrary, "lib3mf_toolpath_addprofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_AddProfile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetProfile = (PLib3MFToolpath_GetProfilePtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getprofile");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetProfile = (PLib3MFToolpath_GetProfilePtr) dlsym(hLibrary, "lib3mf_toolpath_getprofile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetProfile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetProfileUUID = (PLib3MFToolpath_GetProfileUUIDPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getprofileuuid");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetProfileUUID = (PLib3MFToolpath_GetProfileUUIDPtr) dlsym(hLibrary, "lib3mf_toolpath_getprofileuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetProfileUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetCustomDataCount = (PLib3MFToolpath_GetCustomDataCountPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getcustomdatacount");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetCustomDataCount = (PLib3MFToolpath_GetCustomDataCountPtr) dlsym(hLibrary, "lib3mf_toolpath_getcustomdatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetCustomDataCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetCustomData = (PLib3MFToolpath_GetCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getcustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetCustomData = (PLib3MFToolpath_GetCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_getcustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_GetCustomDataName = (PLib3MFToolpath_GetCustomDataNamePtr) GetProcAddress(hLibrary, "lib3mf_toolpath_getcustomdataname");
		#else // _WIN32
		pWrapperTable->m_Toolpath_GetCustomDataName = (PLib3MFToolpath_GetCustomDataNamePtr) dlsym(hLibrary, "lib3mf_toolpath_getcustomdataname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_GetCustomDataName == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_HasUniqueCustomData = (PLib3MFToolpath_HasUniqueCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_hasuniquecustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_HasUniqueCustomData = (PLib3MFToolpath_HasUniqueCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_hasuniquecustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_HasUniqueCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_FindUniqueCustomData = (PLib3MFToolpath_FindUniqueCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_finduniquecustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_FindUniqueCustomData = (PLib3MFToolpath_FindUniqueCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_finduniquecustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_FindUniqueCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_AddCustomData = (PLib3MFToolpath_AddCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_addcustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_AddCustomData = (PLib3MFToolpath_AddCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_addcustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_AddCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_ClearCustomData = (PLib3MFToolpath_ClearCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_clearcustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_ClearCustomData = (PLib3MFToolpath_ClearCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_clearcustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_ClearCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_DeleteCustomData = (PLib3MFToolpath_DeleteCustomDataPtr) GetProcAddress(hLibrary, "lib3mf_toolpath_deletecustomdata");
		#else // _WIN32
		pWrapperTable->m_Toolpath_DeleteCustomData = (PLib3MFToolpath_DeleteCustomDataPtr) dlsym(hLibrary, "lib3mf_toolpath_deletecustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_DeleteCustomData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute = (PLib3MFToolpath_RegisterCustomIntegerAttributePtr) GetProcAddress(hLibrary, "lib3mf_toolpath_registercustomintegerattribute");
		#else // _WIN32
		pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute = (PLib3MFToolpath_RegisterCustomIntegerAttributePtr) dlsym(hLibrary, "lib3mf_toolpath_registercustomintegerattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute = (PLib3MFToolpath_RegisterCustomDoubleAttributePtr) GetProcAddress(hLibrary, "lib3mf_toolpath_registercustomdoubleattribute");
		#else // _WIN32
		pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute = (PLib3MFToolpath_RegisterCustomDoubleAttributePtr) dlsym(hLibrary, "lib3mf_toolpath_registercustomdoubleattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathIterator_GetCurrentToolpath = (PLib3MFToolpathIterator_GetCurrentToolpathPtr) GetProcAddress(hLibrary, "lib3mf_toolpathiterator_getcurrenttoolpath");
		#else // _WIN32
		pWrapperTable->m_ToolpathIterator_GetCurrentToolpath = (PLib3MFToolpathIterator_GetCurrentToolpathPtr) dlsym(hLibrary, "lib3mf_toolpathiterator_getcurrenttoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathIterator_GetCurrentToolpath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLib3MFSliceStack_GetBottomZPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getbottomz");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLib3MFSliceStack_GetBottomZPtr) dlsym(hLibrary, "lib3mf_slicestack_getbottomz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetBottomZ == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetSliceCount = (PLib3MFSliceStack_GetSliceCountPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getslicecount");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetSliceCount = (PLib3MFSliceStack_GetSliceCountPtr) dlsym(hLibrary, "lib3mf_slicestack_getslicecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetSliceCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetSlice = (PLib3MFSliceStack_GetSlicePtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getslice");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetSlice = (PLib3MFSliceStack_GetSlicePtr) dlsym(hLibrary, "lib3mf_slicestack_getslice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetSlice == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_AddSlice = (PLib3MFSliceStack_AddSlicePtr) GetProcAddress(hLibrary, "lib3mf_slicestack_addslice");
		#else // _WIN32
		pWrapperTable->m_SliceStack_AddSlice = (PLib3MFSliceStack_AddSlicePtr) dlsym(hLibrary, "lib3mf_slicestack_addslice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_AddSlice == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetSliceRefCount = (PLib3MFSliceStack_GetSliceRefCountPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getslicerefcount");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetSliceRefCount = (PLib3MFSliceStack_GetSliceRefCountPtr) dlsym(hLibrary, "lib3mf_slicestack_getslicerefcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetSliceRefCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_AddSliceStackReference = (PLib3MFSliceStack_AddSliceStackReferencePtr) GetProcAddress(hLibrary, "lib3mf_slicestack_addslicestackreference");
		#else // _WIN32
		pWrapperTable->m_SliceStack_AddSliceStackReference = (PLib3MFSliceStack_AddSliceStackReferencePtr) dlsym(hLibrary, "lib3mf_slicestack_addslicestackreference");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_AddSliceStackReference == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetSliceStackReference = (PLib3MFSliceStack_GetSliceStackReferencePtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getslicestackreference");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetSliceStackReference = (PLib3MFSliceStack_GetSliceStackReferencePtr) dlsym(hLibrary, "lib3mf_slicestack_getslicestackreference");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetSliceStackReference == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_CollapseSliceReferences = (PLib3MFSliceStack_CollapseSliceReferencesPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_collapseslicereferences");
		#else // _WIN32
		pWrapperTable->m_SliceStack_CollapseSliceReferences = (PLib3MFSliceStack_CollapseSliceReferencesPtr) dlsym(hLibrary, "lib3mf_slicestack_collapseslicereferences");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_CollapseSliceReferences == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_SetOwnPath = (PLib3MFSliceStack_SetOwnPathPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_setownpath");
		#else // _WIN32
		pWrapperTable->m_SliceStack_SetOwnPath = (PLib3MFSliceStack_SetOwnPathPtr) dlsym(hLibrary, "lib3mf_slicestack_setownpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_SetOwnPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetOwnPath = (PLib3MFSliceStack_GetOwnPathPtr) GetProcAddress(hLibrary, "lib3mf_slicestack_getownpath");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetOwnPath = (PLib3MFSliceStack_GetOwnPathPtr) dlsym(hLibrary, "lib3mf_slicestack_getownpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetOwnPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Consumer_GetConsumerID = (PLib3MFConsumer_GetConsumerIDPtr) GetProcAddress(hLibrary, "lib3mf_consumer_getconsumerid");
		#else // _WIN32
		pWrapperTable->m_Consumer_GetConsumerID = (PLib3MFConsumer_GetConsumerIDPtr) dlsym(hLibrary, "lib3mf_consumer_getconsumerid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Consumer_GetConsumerID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Consumer_GetKeyID = (PLib3MFConsumer_GetKeyIDPtr) GetProcAddress(hLibrary, "lib3mf_consumer_getkeyid");
		#else // _WIN32
		pWrapperTable->m_Consumer_GetKeyID = (PLib3MFConsumer_GetKeyIDPtr) dlsym(hLibrary, "lib3mf_consumer_getkeyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Consumer_GetKeyID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Consumer_GetKeyValue = (PLib3MFConsumer_GetKeyValuePtr) GetProcAddress(hLibrary, "lib3mf_consumer_getkeyvalue");
		#else // _WIN32
		pWrapperTable->m_Consumer_GetKeyValue = (PLib3MFConsumer_GetKeyValuePtr) dlsym(hLibrary, "lib3mf_consumer_getkeyvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Consumer_GetKeyValue == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AccessRight_GetConsumer = (PLib3MFAccessRight_GetConsumerPtr) GetProcAddress(hLibrary, "lib3mf_accessright_getconsumer");
		#else // _WIN32
		pWrapperTable->m_AccessRight_GetConsumer = (PLib3MFAccessRight_GetConsumerPtr) dlsym(hLibrary, "lib3mf_accessright_getconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AccessRight_GetConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AccessRight_GetWrappingAlgorithm = (PLib3MFAccessRight_GetWrappingAlgorithmPtr) GetProcAddress(hLibrary, "lib3mf_accessright_getwrappingalgorithm");
		#else // _WIN32
		pWrapperTable->m_AccessRight_GetWrappingAlgorithm = (PLib3MFAccessRight_GetWrappingAlgorithmPtr) dlsym(hLibrary, "lib3mf_accessright_getwrappingalgorithm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AccessRight_GetWrappingAlgorithm == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AccessRight_GetMgfAlgorithm = (PLib3MFAccessRight_GetMgfAlgorithmPtr) GetProcAddress(hLibrary, "lib3mf_accessright_getmgfalgorithm");
		#else // _WIN32
		pWrapperTable->m_AccessRight_GetMgfAlgorithm = (PLib3MFAccessRight_GetMgfAlgorithmPtr) dlsym(hLibrary, "lib3mf_accessright_getmgfalgorithm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AccessRight_GetMgfAlgorithm == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AccessRight_GetDigestMethod = (PLib3MFAccessRight_GetDigestMethodPtr) GetProcAddress(hLibrary, "lib3mf_accessright_getdigestmethod");
		#else // _WIN32
		pWrapperTable->m_AccessRight_GetDigestMethod = (PLib3MFAccessRight_GetDigestMethodPtr) dlsym(hLibrary, "lib3mf_accessright_getdigestmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AccessRight_GetDigestMethod == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm = (PLib3MFContentEncryptionParams_GetEncryptionAlgorithmPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getencryptionalgorithm");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm = (PLib3MFContentEncryptionParams_GetEncryptionAlgorithmPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getencryptionalgorithm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetKey = (PLib3MFContentEncryptionParams_GetKeyPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getkey");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetKey = (PLib3MFContentEncryptionParams_GetKeyPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getkey");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetKey == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetInitializationVector = (PLib3MFContentEncryptionParams_GetInitializationVectorPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getinitializationvector");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetInitializationVector = (PLib3MFContentEncryptionParams_GetInitializationVectorPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getinitializationvector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetInitializationVector == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag = (PLib3MFContentEncryptionParams_GetAuthenticationTagPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getauthenticationtag");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag = (PLib3MFContentEncryptionParams_GetAuthenticationTagPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getauthenticationtag");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag = (PLib3MFContentEncryptionParams_SetAuthenticationTagPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_setauthenticationtag");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag = (PLib3MFContentEncryptionParams_SetAuthenticationTagPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_setauthenticationtag");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData = (PLib3MFContentEncryptionParams_GetAdditionalAuthenticationDataPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getadditionalauthenticationdata");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData = (PLib3MFContentEncryptionParams_GetAdditionalAuthenticationDataPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getadditionalauthenticationdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetDescriptor = (PLib3MFContentEncryptionParams_GetDescriptorPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getdescriptor");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetDescriptor = (PLib3MFContentEncryptionParams_GetDescriptorPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getdescriptor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetDescriptor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetKeyUUID = (PLib3MFContentEncryptionParams_GetKeyUUIDPtr) GetProcAddress(hLibrary, "lib3mf_contentencryptionparams_getkeyuuid");
		#else // _WIN32
		pWrapperTable->m_ContentEncryptionParams_GetKeyUUID = (PLib3MFContentEncryptionParams_GetKeyUUIDPtr) dlsym(hLibrary, "lib3mf_contentencryptionparams_getkeyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ContentEncryptionParams_GetKeyUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceData_GetPath = (PLib3MFResourceData_GetPathPtr) GetProcAddress(hLibrary, "lib3mf_resourcedata_getpath");
		#else // _WIN32
		pWrapperTable->m_ResourceData_GetPath = (PLib3MFResourceData_GetPathPtr) dlsym(hLibrary, "lib3mf_resourcedata_getpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceData_GetPath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceData_GetEncryptionAlgorithm = (PLib3MFResourceData_GetEncryptionAlgorithmPtr) GetProcAddress(hLibrary, "lib3mf_resourcedata_getencryptionalgorithm");
		#else // _WIN32
		pWrapperTable->m_ResourceData_GetEncryptionAlgorithm = (PLib3MFResourceData_GetEncryptionAlgorithmPtr) dlsym(hLibrary, "lib3mf_resourcedata_getencryptionalgorithm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceData_GetEncryptionAlgorithm == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceData_GetCompression = (PLib3MFResourceData_GetCompressionPtr) GetProcAddress(hLibrary, "lib3mf_resourcedata_getcompression");
		#else // _WIN32
		pWrapperTable->m_ResourceData_GetCompression = (PLib3MFResourceData_GetCompressionPtr) dlsym(hLibrary, "lib3mf_resourcedata_getcompression");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceData_GetCompression == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData = (PLib3MFResourceData_GetAdditionalAuthenticationDataPtr) GetProcAddress(hLibrary, "lib3mf_resourcedata_getadditionalauthenticationdata");
		#else // _WIN32
		pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData = (PLib3MFResourceData_GetAdditionalAuthenticationDataPtr) dlsym(hLibrary, "lib3mf_resourcedata_getadditionalauthenticationdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceDataGroup_GetKeyUUID = (PLib3MFResourceDataGroup_GetKeyUUIDPtr) GetProcAddress(hLibrary, "lib3mf_resourcedatagroup_getkeyuuid");
		#else // _WIN32
		pWrapperTable->m_ResourceDataGroup_GetKeyUUID = (PLib3MFResourceDataGroup_GetKeyUUIDPtr) dlsym(hLibrary, "lib3mf_resourcedatagroup_getkeyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceDataGroup_GetKeyUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceDataGroup_AddAccessRight = (PLib3MFResourceDataGroup_AddAccessRightPtr) GetProcAddress(hLibrary, "lib3mf_resourcedatagroup_addaccessright");
		#else // _WIN32
		pWrapperTable->m_ResourceDataGroup_AddAccessRight = (PLib3MFResourceDataGroup_AddAccessRightPtr) dlsym(hLibrary, "lib3mf_resourcedatagroup_addaccessright");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceDataGroup_AddAccessRight == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer = (PLib3MFResourceDataGroup_FindAccessRightByConsumerPtr) GetProcAddress(hLibrary, "lib3mf_resourcedatagroup_findaccessrightbyconsumer");
		#else // _WIN32
		pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer = (PLib3MFResourceDataGroup_FindAccessRightByConsumerPtr) dlsym(hLibrary, "lib3mf_resourcedatagroup_findaccessrightbyconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ResourceDataGroup_RemoveAccessRight = (PLib3MFResourceDataGroup_RemoveAccessRightPtr) GetProcAddress(hLibrary, "lib3mf_resourcedatagroup_removeaccessright");
		#else // _WIN32
		pWrapperTable->m_ResourceDataGroup_RemoveAccessRight = (PLib3MFResourceDataGroup_RemoveAccessRightPtr) dlsym(hLibrary, "lib3mf_resourcedatagroup_removeaccessright");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ResourceDataGroup_RemoveAccessRight == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_AddConsumer = (PLib3MFKeyStore_AddConsumerPtr) GetProcAddress(hLibrary, "lib3mf_keystore_addconsumer");
		#else // _WIN32
		pWrapperTable->m_KeyStore_AddConsumer = (PLib3MFKeyStore_AddConsumerPtr) dlsym(hLibrary, "lib3mf_keystore_addconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_AddConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetConsumerCount = (PLib3MFKeyStore_GetConsumerCountPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getconsumercount");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetConsumerCount = (PLib3MFKeyStore_GetConsumerCountPtr) dlsym(hLibrary, "lib3mf_keystore_getconsumercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetConsumerCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetConsumer = (PLib3MFKeyStore_GetConsumerPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getconsumer");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetConsumer = (PLib3MFKeyStore_GetConsumerPtr) dlsym(hLibrary, "lib3mf_keystore_getconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_RemoveConsumer = (PLib3MFKeyStore_RemoveConsumerPtr) GetProcAddress(hLibrary, "lib3mf_keystore_removeconsumer");
		#else // _WIN32
		pWrapperTable->m_KeyStore_RemoveConsumer = (PLib3MFKeyStore_RemoveConsumerPtr) dlsym(hLibrary, "lib3mf_keystore_removeconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_RemoveConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_FindConsumer = (PLib3MFKeyStore_FindConsumerPtr) GetProcAddress(hLibrary, "lib3mf_keystore_findconsumer");
		#else // _WIN32
		pWrapperTable->m_KeyStore_FindConsumer = (PLib3MFKeyStore_FindConsumerPtr) dlsym(hLibrary, "lib3mf_keystore_findconsumer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_FindConsumer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataGroupCount = (PLib3MFKeyStore_GetResourceDataGroupCountPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getresourcedatagroupcount");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataGroupCount = (PLib3MFKeyStore_GetResourceDataGroupCountPtr) dlsym(hLibrary, "lib3mf_keystore_getresourcedatagroupcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetResourceDataGroupCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_AddResourceDataGroup = (PLib3MFKeyStore_AddResourceDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_keystore_addresourcedatagroup");
		#else // _WIN32
		pWrapperTable->m_KeyStore_AddResourceDataGroup = (PLib3MFKeyStore_AddResourceDataGroupPtr) dlsym(hLibrary, "lib3mf_keystore_addresourcedatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_AddResourceDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataGroup = (PLib3MFKeyStore_GetResourceDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getresourcedatagroup");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataGroup = (PLib3MFKeyStore_GetResourceDataGroupPtr) dlsym(hLibrary, "lib3mf_keystore_getresourcedatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetResourceDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_RemoveResourceDataGroup = (PLib3MFKeyStore_RemoveResourceDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_keystore_removeresourcedatagroup");
		#else // _WIN32
		pWrapperTable->m_KeyStore_RemoveResourceDataGroup = (PLib3MFKeyStore_RemoveResourceDataGroupPtr) dlsym(hLibrary, "lib3mf_keystore_removeresourcedatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_RemoveResourceDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_FindResourceDataGroup = (PLib3MFKeyStore_FindResourceDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_keystore_findresourcedatagroup");
		#else // _WIN32
		pWrapperTable->m_KeyStore_FindResourceDataGroup = (PLib3MFKeyStore_FindResourceDataGroupPtr) dlsym(hLibrary, "lib3mf_keystore_findresourcedatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_FindResourceDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_AddResourceData = (PLib3MFKeyStore_AddResourceDataPtr) GetProcAddress(hLibrary, "lib3mf_keystore_addresourcedata");
		#else // _WIN32
		pWrapperTable->m_KeyStore_AddResourceData = (PLib3MFKeyStore_AddResourceDataPtr) dlsym(hLibrary, "lib3mf_keystore_addresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_AddResourceData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_RemoveResourceData = (PLib3MFKeyStore_RemoveResourceDataPtr) GetProcAddress(hLibrary, "lib3mf_keystore_removeresourcedata");
		#else // _WIN32
		pWrapperTable->m_KeyStore_RemoveResourceData = (PLib3MFKeyStore_RemoveResourceDataPtr) dlsym(hLibrary, "lib3mf_keystore_removeresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_RemoveResourceData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_FindResourceData = (PLib3MFKeyStore_FindResourceDataPtr) GetProcAddress(hLibrary, "lib3mf_keystore_findresourcedata");
		#else // _WIN32
		pWrapperTable->m_KeyStore_FindResourceData = (PLib3MFKeyStore_FindResourceDataPtr) dlsym(hLibrary, "lib3mf_keystore_findresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_FindResourceData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataCount = (PLib3MFKeyStore_GetResourceDataCountPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getresourcedatacount");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetResourceDataCount = (PLib3MFKeyStore_GetResourceDataCountPtr) dlsym(hLibrary, "lib3mf_keystore_getresourcedatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetResourceDataCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetResourceData = (PLib3MFKeyStore_GetResourceDataPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getresourcedata");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetResourceData = (PLib3MFKeyStore_GetResourceDataPtr) dlsym(hLibrary, "lib3mf_keystore_getresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetResourceData == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_GetUUID = (PLib3MFKeyStore_GetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_keystore_getuuid");
		#else // _WIN32
		pWrapperTable->m_KeyStore_GetUUID = (PLib3MFKeyStore_GetUUIDPtr) dlsym(hLibrary, "lib3mf_keystore_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_GetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_KeyStore_SetUUID = (PLib3MFKeyStore_SetUUIDPtr) GetProcAddress(hLibrary, "lib3mf_keystore_setuuid");
		#else // _WIN32
		pWrapperTable->m_KeyStore_SetUUID = (PLib3MFKeyStore_SetUUIDPtr) dlsym(hLibrary, "lib3mf_keystore_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_KeyStore_SetUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_RootModelPart = (PLib3MFModel_RootModelPartPtr) GetProcAddress(hLibrary, "lib3mf_model_rootmodelpart");
		#else // _WIN32
		pWrapperTable->m_Model_RootModelPart = (PLib3MFModel_RootModelPartPtr) dlsym(hLibrary, "lib3mf_model_rootmodelpart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_RootModelPart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_FindOrCreatePackagePart = (PLib3MFModel_FindOrCreatePackagePartPtr) GetProcAddress(hLibrary, "lib3mf_model_findorcreatepackagepart");
		#else // _WIN32
		pWrapperTable->m_Model_FindOrCreatePackagePart = (PLib3MFModel_FindOrCreatePackagePartPtr) dlsym(hLibrary, "lib3mf_model_findorcreatepackagepart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_FindOrCreatePackagePart == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_SetUnit = (PLib3MFModel_SetUnitPtr) GetProcAddress(hLibrary, "lib3mf_model_setunit");
		#else // _WIN32
		pWrapperTable->m_Model_SetUnit = (PLib3MFModel_SetUnitPtr) dlsym(hLibrary, "lib3mf_model_setunit");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_SetUnit == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetUnit = (PLib3MFModel_GetUnitPtr) GetProcAddress(hLibrary, "lib3mf_model_getunit");
		#else // _WIN32
		pWrapperTable->m_Model_GetUnit = (PLib3MFModel_GetUnitPtr) dlsym(hLibrary, "lib3mf_model_getunit");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetUnit == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetLanguage = (PLib3MFModel_GetLanguagePtr) GetProcAddress(hLibrary, "lib3mf_model_getlanguage");
		#else // _WIN32
		pWrapperTable->m_Model_GetLanguage = (PLib3MFModel_GetLanguagePtr) dlsym(hLibrary, "lib3mf_model_getlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetLanguage == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_SetLanguage = (PLib3MFModel_SetLanguagePtr) GetProcAddress(hLibrary, "lib3mf_model_setlanguage");
		#else // _WIN32
		pWrapperTable->m_Model_SetLanguage = (PLib3MFModel_SetLanguagePtr) dlsym(hLibrary, "lib3mf_model_setlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_SetLanguage == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_QueryWriter = (PLib3MFModel_QueryWriterPtr) GetProcAddress(hLibrary, "lib3mf_model_querywriter");
		#else // _WIN32
		pWrapperTable->m_Model_QueryWriter = (PLib3MFModel_QueryWriterPtr) dlsym(hLibrary, "lib3mf_model_querywriter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_QueryWriter == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_QueryReader = (PLib3MFModel_QueryReaderPtr) GetProcAddress(hLibrary, "lib3mf_model_queryreader");
		#else // _WIN32
		pWrapperTable->m_Model_QueryReader = (PLib3MFModel_QueryReaderPtr) dlsym(hLibrary, "lib3mf_model_queryreader");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_QueryReader == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetResourceByID = (PLib3MFModel_GetResourceByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getresourcebyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetResourceByID = (PLib3MFModel_GetResourceByIDPtr) dlsym(hLibrary, "lib3mf_model_getresourcebyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetResourceByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetTexture2DByID = (PLib3MFModel_GetTexture2DByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_gettexture2dbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetTexture2DByID = (PLib3MFModel_GetTexture2DByIDPtr) dlsym(hLibrary, "lib3mf_model_gettexture2dbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetTexture2DByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetPropertyTypeByID = (PLib3MFModel_GetPropertyTypeByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getpropertytypebyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetPropertyTypeByID = (PLib3MFModel_GetPropertyTypeByIDPtr) dlsym(hLibrary, "lib3mf_model_getpropertytypebyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetPropertyTypeByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetBaseMaterialGroupByID = (PLib3MFModel_GetBaseMaterialGroupByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getbasematerialgroupbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetBaseMaterialGroupByID = (PLib3MFModel_GetBaseMaterialGroupByIDPtr) dlsym(hLibrary, "lib3mf_model_getbasematerialgroupbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetBaseMaterialGroupByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetTexture2DGroupByID = (PLib3MFModel_GetTexture2DGroupByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_gettexture2dgroupbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetTexture2DGroupByID = (PLib3MFModel_GetTexture2DGroupByIDPtr) dlsym(hLibrary, "lib3mf_model_gettexture2dgroupbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetTexture2DGroupByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetCompositeMaterialsByID = (PLib3MFModel_GetCompositeMaterialsByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getcompositematerialsbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetCompositeMaterialsByID = (PLib3MFModel_GetCompositeMaterialsByIDPtr) dlsym(hLibrary, "lib3mf_model_getcompositematerialsbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetCompositeMaterialsByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetMultiPropertyGroupByID = (PLib3MFModel_GetMultiPropertyGroupByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getmultipropertygroupbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetMultiPropertyGroupByID = (PLib3MFModel_GetMultiPropertyGroupByIDPtr) dlsym(hLibrary, "lib3mf_model_getmultipropertygroupbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetMultiPropertyGroupByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetMeshObjectByID = (PLib3MFModel_GetMeshObjectByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getmeshobjectbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetMeshObjectByID = (PLib3MFModel_GetMeshObjectByIDPtr) dlsym(hLibrary, "lib3mf_model_getmeshobjectbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetMeshObjectByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetComponentsObjectByID = (PLib3MFModel_GetComponentsObjectByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getcomponentsobjectbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetComponentsObjectByID = (PLib3MFModel_GetComponentsObjectByIDPtr) dlsym(hLibrary, "lib3mf_model_getcomponentsobjectbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetComponentsObjectByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetColorGroupByID = (PLib3MFModel_GetColorGroupByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getcolorgroupbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetColorGroupByID = (PLib3MFModel_GetColorGroupByIDPtr) dlsym(hLibrary, "lib3mf_model_getcolorgroupbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetColorGroupByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetSliceStackByID = (PLib3MFModel_GetSliceStackByIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getslicestackbyid");
		#else // _WIN32
		pWrapperTable->m_Model_GetSliceStackByID = (PLib3MFModel_GetSliceStackByIDPtr) dlsym(hLibrary, "lib3mf_model_getslicestackbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetSliceStackByID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetBuildUUID = (PLib3MFModel_GetBuildUUIDPtr) GetProcAddress(hLibrary, "lib3mf_model_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_Model_GetBuildUUID = (PLib3MFModel_GetBuildUUIDPtr) dlsym(hLibrary, "lib3mf_model_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetBuildUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_SetBuildUUID = (PLib3MFModel_SetBuildUUIDPtr) GetProcAddress(hLibrary, "lib3mf_model_setbuilduuid");
		#else // _WIN32
		pWrapperTable->m_Model_SetBuildUUID = (PLib3MFModel_SetBuildUUIDPtr) dlsym(hLibrary, "lib3mf_model_setbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_SetBuildUUID == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetBuildItems = (PLib3MFModel_GetBuildItemsPtr) GetProcAddress(hLibrary, "lib3mf_model_getbuilditems");
		#else // _WIN32
		pWrapperTable->m_Model_GetBuildItems = (PLib3MFModel_GetBuildItemsPtr) dlsym(hLibrary, "lib3mf_model_getbuilditems");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetBuildItems == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetOutbox = (PLib3MFModel_GetOutboxPtr) GetProcAddress(hLibrary, "lib3mf_model_getoutbox");
		#else // _WIN32
		pWrapperTable->m_Model_GetOutbox = (PLib3MFModel_GetOutboxPtr) dlsym(hLibrary, "lib3mf_model_getoutbox");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetOutbox == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetResources = (PLib3MFModel_GetResourcesPtr) GetProcAddress(hLibrary, "lib3mf_model_getresources");
		#else // _WIN32
		pWrapperTable->m_Model_GetResources = (PLib3MFModel_GetResourcesPtr) dlsym(hLibrary, "lib3mf_model_getresources");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetResources == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetObjects = (PLib3MFModel_GetObjectsPtr) GetProcAddress(hLibrary, "lib3mf_model_getobjects");
		#else // _WIN32
		pWrapperTable->m_Model_GetObjects = (PLib3MFModel_GetObjectsPtr) dlsym(hLibrary, "lib3mf_model_getobjects");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetObjects == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetMeshObjects = (PLib3MFModel_GetMeshObjectsPtr) GetProcAddress(hLibrary, "lib3mf_model_getmeshobjects");
		#else // _WIN32
		pWrapperTable->m_Model_GetMeshObjects = (PLib3MFModel_GetMeshObjectsPtr) dlsym(hLibrary, "lib3mf_model_getmeshobjects");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetMeshObjects == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetComponentsObjects = (PLib3MFModel_GetComponentsObjectsPtr) GetProcAddress(hLibrary, "lib3mf_model_getcomponentsobjects");
		#else // _WIN32
		pWrapperTable->m_Model_GetComponentsObjects = (PLib3MFModel_GetComponentsObjectsPtr) dlsym(hLibrary, "lib3mf_model_getcomponentsobjects");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetComponentsObjects == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetTexture2Ds = (PLib3MFModel_GetTexture2DsPtr) GetProcAddress(hLibrary, "lib3mf_model_gettexture2ds");
		#else // _WIN32
		pWrapperTable->m_Model_GetTexture2Ds = (PLib3MFModel_GetTexture2DsPtr) dlsym(hLibrary, "lib3mf_model_gettexture2ds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetTexture2Ds == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetBaseMaterialGroups = (PLib3MFModel_GetBaseMaterialGroupsPtr) GetProcAddress(hLibrary, "lib3mf_model_getbasematerialgroups");
		#else // _WIN32
		pWrapperTable->m_Model_GetBaseMaterialGroups = (PLib3MFModel_GetBaseMaterialGroupsPtr) dlsym(hLibrary, "lib3mf_model_getbasematerialgroups");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetBaseMaterialGroups == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetColorGroups = (PLib3MFModel_GetColorGroupsPtr) GetProcAddress(hLibrary, "lib3mf_model_getcolorgroups");
		#else // _WIN32
		pWrapperTable->m_Model_GetColorGroups = (PLib3MFModel_GetColorGroupsPtr) dlsym(hLibrary, "lib3mf_model_getcolorgroups");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetColorGroups == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetTexture2DGroups = (PLib3MFModel_GetTexture2DGroupsPtr) GetProcAddress(hLibrary, "lib3mf_model_gettexture2dgroups");
		#else // _WIN32
		pWrapperTable->m_Model_GetTexture2DGroups = (PLib3MFModel_GetTexture2DGroupsPtr) dlsym(hLibrary, "lib3mf_model_gettexture2dgroups");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetTexture2DGroups == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetCompositeMaterials = (PLib3MFModel_GetCompositeMaterialsPtr) GetProcAddress(hLibrary, "lib3mf_model_getcompositematerials");
		#else // _WIN32
		pWrapperTable->m_Model_GetCompositeMaterials = (PLib3MFModel_GetCompositeMaterialsPtr) dlsym(hLibrary, "lib3mf_model_getcompositematerials");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetCompositeMaterials == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetMultiPropertyGroups = (PLib3MFModel_GetMultiPropertyGroupsPtr) GetProcAddress(hLibrary, "lib3mf_model_getmultipropertygroups");
		#else // _WIN32
		pWrapperTable->m_Model_GetMultiPropertyGroups = (PLib3MFModel_GetMultiPropertyGroupsPtr) dlsym(hLibrary, "lib3mf_model_getmultipropertygroups");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetMultiPropertyGroups == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetToolpaths = (PLib3MFModel_GetToolpathsPtr) GetProcAddress(hLibrary, "lib3mf_model_gettoolpaths");
		#else // _WIN32
		pWrapperTable->m_Model_GetToolpaths = (PLib3MFModel_GetToolpathsPtr) dlsym(hLibrary, "lib3mf_model_gettoolpaths");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetToolpaths == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetSliceStacks = (PLib3MFModel_GetSliceStacksPtr) GetProcAddress(hLibrary, "lib3mf_model_getslicestacks");
		#else // _WIN32
		pWrapperTable->m_Model_GetSliceStacks = (PLib3MFModel_GetSliceStacksPtr) dlsym(hLibrary, "lib3mf_model_getslicestacks");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetSliceStacks == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_MergeToModel = (PLib3MFModel_MergeToModelPtr) GetProcAddress(hLibrary, "lib3mf_model_mergetomodel");
		#else // _WIN32
		pWrapperTable->m_Model_MergeToModel = (PLib3MFModel_MergeToModelPtr) dlsym(hLibrary, "lib3mf_model_mergetomodel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_MergeToModel == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddMeshObject = (PLib3MFModel_AddMeshObjectPtr) GetProcAddress(hLibrary, "lib3mf_model_addmeshobject");
		#else // _WIN32
		pWrapperTable->m_Model_AddMeshObject = (PLib3MFModel_AddMeshObjectPtr) dlsym(hLibrary, "lib3mf_model_addmeshobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddMeshObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddComponentsObject = (PLib3MFModel_AddComponentsObjectPtr) GetProcAddress(hLibrary, "lib3mf_model_addcomponentsobject");
		#else // _WIN32
		pWrapperTable->m_Model_AddComponentsObject = (PLib3MFModel_AddComponentsObjectPtr) dlsym(hLibrary, "lib3mf_model_addcomponentsobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddComponentsObject == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddSliceStack = (PLib3MFModel_AddSliceStackPtr) GetProcAddress(hLibrary, "lib3mf_model_addslicestack");
		#else // _WIN32
		pWrapperTable->m_Model_AddSliceStack = (PLib3MFModel_AddSliceStackPtr) dlsym(hLibrary, "lib3mf_model_addslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddSliceStack == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddTexture2DFromAttachment = (PLib3MFModel_AddTexture2DFromAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_addtexture2dfromattachment");
		#else // _WIN32
		pWrapperTable->m_Model_AddTexture2DFromAttachment = (PLib3MFModel_AddTexture2DFromAttachmentPtr) dlsym(hLibrary, "lib3mf_model_addtexture2dfromattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddTexture2DFromAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddBaseMaterialGroup = (PLib3MFModel_AddBaseMaterialGroupPtr) GetProcAddress(hLibrary, "lib3mf_model_addbasematerialgroup");
		#else // _WIN32
		pWrapperTable->m_Model_AddBaseMaterialGroup = (PLib3MFModel_AddBaseMaterialGroupPtr) dlsym(hLibrary, "lib3mf_model_addbasematerialgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddBaseMaterialGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddColorGroup = (PLib3MFModel_AddColorGroupPtr) GetProcAddress(hLibrary, "lib3mf_model_addcolorgroup");
		#else // _WIN32
		pWrapperTable->m_Model_AddColorGroup = (PLib3MFModel_AddColorGroupPtr) dlsym(hLibrary, "lib3mf_model_addcolorgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddColorGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddTexture2DGroup = (PLib3MFModel_AddTexture2DGroupPtr) GetProcAddress(hLibrary, "lib3mf_model_addtexture2dgroup");
		#else // _WIN32
		pWrapperTable->m_Model_AddTexture2DGroup = (PLib3MFModel_AddTexture2DGroupPtr) dlsym(hLibrary, "lib3mf_model_addtexture2dgroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddTexture2DGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddCompositeMaterials = (PLib3MFModel_AddCompositeMaterialsPtr) GetProcAddress(hLibrary, "lib3mf_model_addcompositematerials");
		#else // _WIN32
		pWrapperTable->m_Model_AddCompositeMaterials = (PLib3MFModel_AddCompositeMaterialsPtr) dlsym(hLibrary, "lib3mf_model_addcompositematerials");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddCompositeMaterials == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddMultiPropertyGroup = (PLib3MFModel_AddMultiPropertyGroupPtr) GetProcAddress(hLibrary, "lib3mf_model_addmultipropertygroup");
		#else // _WIN32
		pWrapperTable->m_Model_AddMultiPropertyGroup = (PLib3MFModel_AddMultiPropertyGroupPtr) dlsym(hLibrary, "lib3mf_model_addmultipropertygroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddMultiPropertyGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddBuildItem = (PLib3MFModel_AddBuildItemPtr) GetProcAddress(hLibrary, "lib3mf_model_addbuilditem");
		#else // _WIN32
		pWrapperTable->m_Model_AddBuildItem = (PLib3MFModel_AddBuildItemPtr) dlsym(hLibrary, "lib3mf_model_addbuilditem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddBuildItem == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_RemoveBuildItem = (PLib3MFModel_RemoveBuildItemPtr) GetProcAddress(hLibrary, "lib3mf_model_removebuilditem");
		#else // _WIN32
		pWrapperTable->m_Model_RemoveBuildItem = (PLib3MFModel_RemoveBuildItemPtr) dlsym(hLibrary, "lib3mf_model_removebuilditem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_RemoveBuildItem == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddToolpath = (PLib3MFModel_AddToolpathPtr) GetProcAddress(hLibrary, "lib3mf_model_addtoolpath");
		#else // _WIN32
		pWrapperTable->m_Model_AddToolpath = (PLib3MFModel_AddToolpathPtr) dlsym(hLibrary, "lib3mf_model_addtoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddToolpath == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetMetaDataGroup = (PLib3MFModel_GetMetaDataGroupPtr) GetProcAddress(hLibrary, "lib3mf_model_getmetadatagroup");
		#else // _WIN32
		pWrapperTable->m_Model_GetMetaDataGroup = (PLib3MFModel_GetMetaDataGroupPtr) dlsym(hLibrary, "lib3mf_model_getmetadatagroup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetMetaDataGroup == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddAttachment = (PLib3MFModel_AddAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_addattachment");
		#else // _WIN32
		pWrapperTable->m_Model_AddAttachment = (PLib3MFModel_AddAttachmentPtr) dlsym(hLibrary, "lib3mf_model_addattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_RemoveAttachment = (PLib3MFModel_RemoveAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_removeattachment");
		#else // _WIN32
		pWrapperTable->m_Model_RemoveAttachment = (PLib3MFModel_RemoveAttachmentPtr) dlsym(hLibrary, "lib3mf_model_removeattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_RemoveAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetAttachment = (PLib3MFModel_GetAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_getattachment");
		#else // _WIN32
		pWrapperTable->m_Model_GetAttachment = (PLib3MFModel_GetAttachmentPtr) dlsym(hLibrary, "lib3mf_model_getattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_FindAttachment = (PLib3MFModel_FindAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_findattachment");
		#else // _WIN32
		pWrapperTable->m_Model_FindAttachment = (PLib3MFModel_FindAttachmentPtr) dlsym(hLibrary, "lib3mf_model_findattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_FindAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetAttachmentCount = (PLib3MFModel_GetAttachmentCountPtr) GetProcAddress(hLibrary, "lib3mf_model_getattachmentcount");
		#else // _WIN32
		pWrapperTable->m_Model_GetAttachmentCount = (PLib3MFModel_GetAttachmentCountPtr) dlsym(hLibrary, "lib3mf_model_getattachmentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetAttachmentCount == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_HasPackageThumbnailAttachment = (PLib3MFModel_HasPackageThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_haspackagethumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Model_HasPackageThumbnailAttachment = (PLib3MFModel_HasPackageThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_model_haspackagethumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_HasPackageThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_CreatePackageThumbnailAttachment = (PLib3MFModel_CreatePackageThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_createpackagethumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Model_CreatePackageThumbnailAttachment = (PLib3MFModel_CreatePackageThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_model_createpackagethumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_CreatePackageThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetPackageThumbnailAttachment = (PLib3MFModel_GetPackageThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_getpackagethumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Model_GetPackageThumbnailAttachment = (PLib3MFModel_GetPackageThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_model_getpackagethumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetPackageThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_RemovePackageThumbnailAttachment = (PLib3MFModel_RemovePackageThumbnailAttachmentPtr) GetProcAddress(hLibrary, "lib3mf_model_removepackagethumbnailattachment");
		#else // _WIN32
		pWrapperTable->m_Model_RemovePackageThumbnailAttachment = (PLib3MFModel_RemovePackageThumbnailAttachmentPtr) dlsym(hLibrary, "lib3mf_model_removepackagethumbnailattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_RemovePackageThumbnailAttachment == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_AddCustomContentType = (PLib3MFModel_AddCustomContentTypePtr) GetProcAddress(hLibrary, "lib3mf_model_addcustomcontenttype");
		#else // _WIN32
		pWrapperTable->m_Model_AddCustomContentType = (PLib3MFModel_AddCustomContentTypePtr) dlsym(hLibrary, "lib3mf_model_addcustomcontenttype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_AddCustomContentType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_RemoveCustomContentType = (PLib3MFModel_RemoveCustomContentTypePtr) GetProcAddress(hLibrary, "lib3mf_model_removecustomcontenttype");
		#else // _WIN32
		pWrapperTable->m_Model_RemoveCustomContentType = (PLib3MFModel_RemoveCustomContentTypePtr) dlsym(hLibrary, "lib3mf_model_removecustomcontenttype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_RemoveCustomContentType == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_SetRandomNumberCallback = (PLib3MFModel_SetRandomNumberCallbackPtr) GetProcAddress(hLibrary, "lib3mf_model_setrandomnumbercallback");
		#else // _WIN32
		pWrapperTable->m_Model_SetRandomNumberCallback = (PLib3MFModel_SetRandomNumberCallbackPtr) dlsym(hLibrary, "lib3mf_model_setrandomnumbercallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_SetRandomNumberCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_GetKeyStore = (PLib3MFModel_GetKeyStorePtr) GetProcAddress(hLibrary, "lib3mf_model_getkeystore");
		#else // _WIN32
		pWrapperTable->m_Model_GetKeyStore = (PLib3MFModel_GetKeyStorePtr) dlsym(hLibrary, "lib3mf_model_getkeystore");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_GetKeyStore == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromFile = (PLib3MFModel_CreatePersistentSourceFromFilePtr) GetProcAddress(hLibrary, "lib3mf_model_createpersistentsourcefromfile");
		#else // _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromFile = (PLib3MFModel_CreatePersistentSourceFromFilePtr) dlsym(hLibrary, "lib3mf_model_createpersistentsourcefromfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_CreatePersistentSourceFromFile == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromBuffer = (PLib3MFModel_CreatePersistentSourceFromBufferPtr) GetProcAddress(hLibrary, "lib3mf_model_createpersistentsourcefrombuffer");
		#else // _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromBuffer = (PLib3MFModel_CreatePersistentSourceFromBufferPtr) dlsym(hLibrary, "lib3mf_model_createpersistentsourcefrombuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_CreatePersistentSourceFromBuffer == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromCallback = (PLib3MFModel_CreatePersistentSourceFromCallbackPtr) GetProcAddress(hLibrary, "lib3mf_model_createpersistentsourcefromcallback");
		#else // _WIN32
		pWrapperTable->m_Model_CreatePersistentSourceFromCallback = (PLib3MFModel_CreatePersistentSourceFromCallbackPtr) dlsym(hLibrary, "lib3mf_model_createpersistentsourcefromcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Model_CreatePersistentSourceFromCallback == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLibraryVersion = (PLib3MFGetLibraryVersionPtr) GetProcAddress(hLibrary, "lib3mf_getlibraryversion");
		#else // _WIN32
		pWrapperTable->m_GetLibraryVersion = (PLib3MFGetLibraryVersionPtr) dlsym(hLibrary, "lib3mf_getlibraryversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLibraryVersion == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetPrereleaseInformation = (PLib3MFGetPrereleaseInformationPtr) GetProcAddress(hLibrary, "lib3mf_getprereleaseinformation");
		#else // _WIN32
		pWrapperTable->m_GetPrereleaseInformation = (PLib3MFGetPrereleaseInformationPtr) dlsym(hLibrary, "lib3mf_getprereleaseinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetPrereleaseInformation == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetBuildInformation = (PLib3MFGetBuildInformationPtr) GetProcAddress(hLibrary, "lib3mf_getbuildinformation");
		#else // _WIN32
		pWrapperTable->m_GetBuildInformation = (PLib3MFGetBuildInformationPtr) dlsym(hLibrary, "lib3mf_getbuildinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetBuildInformation == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSpecificationVersion = (PLib3MFGetSpecificationVersionPtr) GetProcAddress(hLibrary, "lib3mf_getspecificationversion");
		#else // _WIN32
		pWrapperTable->m_GetSpecificationVersion = (PLib3MFGetSpecificationVersionPtr) dlsym(hLibrary, "lib3mf_getspecificationversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSpecificationVersion == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateModel = (PLib3MFCreateModelPtr) GetProcAddress(hLibrary, "lib3mf_createmodel");
		#else // _WIN32
		pWrapperTable->m_CreateModel = (PLib3MFCreateModelPtr) dlsym(hLibrary, "lib3mf_createmodel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateModel == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Release = (PLib3MFReleasePtr) GetProcAddress(hLibrary, "lib3mf_release");
		#else // _WIN32
		pWrapperTable->m_Release = (PLib3MFReleasePtr) dlsym(hLibrary, "lib3mf_release");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Release == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Acquire = (PLib3MFAcquirePtr) GetProcAddress(hLibrary, "lib3mf_acquire");
		#else // _WIN32
		pWrapperTable->m_Acquire = (PLib3MFAcquirePtr) dlsym(hLibrary, "lib3mf_acquire");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Acquire == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SetJournal = (PLib3MFSetJournalPtr) GetProcAddress(hLibrary, "lib3mf_setjournal");
		#else // _WIN32
		pWrapperTable->m_SetJournal = (PLib3MFSetJournalPtr) dlsym(hLibrary, "lib3mf_setjournal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SetJournal == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLib3MFGetLastErrorPtr) GetProcAddress(hLibrary, "lib3mf_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLib3MFGetLastErrorPtr) dlsym(hLibrary, "lib3mf_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLib3MFGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "lib3mf_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLib3MFGetSymbolLookupMethodPtr) dlsym(hLibrary, "lib3mf_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RetrieveProgressMessage = (PLib3MFRetrieveProgressMessagePtr) GetProcAddress(hLibrary, "lib3mf_retrieveprogressmessage");
		#else // _WIN32
		pWrapperTable->m_RetrieveProgressMessage = (PLib3MFRetrieveProgressMessagePtr) dlsym(hLibrary, "lib3mf_retrieveprogressmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RetrieveProgressMessage == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RGBAToColor = (PLib3MFRGBAToColorPtr) GetProcAddress(hLibrary, "lib3mf_rgbatocolor");
		#else // _WIN32
		pWrapperTable->m_RGBAToColor = (PLib3MFRGBAToColorPtr) dlsym(hLibrary, "lib3mf_rgbatocolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RGBAToColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_FloatRGBAToColor = (PLib3MFFloatRGBAToColorPtr) GetProcAddress(hLibrary, "lib3mf_floatrgbatocolor");
		#else // _WIN32
		pWrapperTable->m_FloatRGBAToColor = (PLib3MFFloatRGBAToColorPtr) dlsym(hLibrary, "lib3mf_floatrgbatocolor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_FloatRGBAToColor == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorToRGBA = (PLib3MFColorToRGBAPtr) GetProcAddress(hLibrary, "lib3mf_colortorgba");
		#else // _WIN32
		pWrapperTable->m_ColorToRGBA = (PLib3MFColorToRGBAPtr) dlsym(hLibrary, "lib3mf_colortorgba");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorToRGBA == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ColorToFloatRGBA = (PLib3MFColorToFloatRGBAPtr) GetProcAddress(hLibrary, "lib3mf_colortofloatrgba");
		#else // _WIN32
		pWrapperTable->m_ColorToFloatRGBA = (PLib3MFColorToFloatRGBAPtr) dlsym(hLibrary, "lib3mf_colortofloatrgba");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ColorToFloatRGBA == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetIdentityTransform = (PLib3MFGetIdentityTransformPtr) GetProcAddress(hLibrary, "lib3mf_getidentitytransform");
		#else // _WIN32
		pWrapperTable->m_GetIdentityTransform = (PLib3MFGetIdentityTransformPtr) dlsym(hLibrary, "lib3mf_getidentitytransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetIdentityTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetUniformScaleTransform = (PLib3MFGetUniformScaleTransformPtr) GetProcAddress(hLibrary, "lib3mf_getuniformscaletransform");
		#else // _WIN32
		pWrapperTable->m_GetUniformScaleTransform = (PLib3MFGetUniformScaleTransformPtr) dlsym(hLibrary, "lib3mf_getuniformscaletransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetUniformScaleTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetScaleTransform = (PLib3MFGetScaleTransformPtr) GetProcAddress(hLibrary, "lib3mf_getscaletransform");
		#else // _WIN32
		pWrapperTable->m_GetScaleTransform = (PLib3MFGetScaleTransformPtr) dlsym(hLibrary, "lib3mf_getscaletransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetScaleTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetTranslationTransform = (PLib3MFGetTranslationTransformPtr) GetProcAddress(hLibrary, "lib3mf_gettranslationtransform");
		#else // _WIN32
		pWrapperTable->m_GetTranslationTransform = (PLib3MFGetTranslationTransformPtr) dlsym(hLibrary, "lib3mf_gettranslationtransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetTranslationTransform == nullptr)
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIB3MF_SUCCESS;
	}

	inline Lib3MFResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLib3MFDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIB3MF_ERROR_INVALIDPARAM;
		
		typedef Lib3MFResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		Lib3MFResult eLookupError = LIB3MF_SUCCESS;
		eLookupError = (*pLookup)("lib3mf_base_classtypeid", (void**)&(pWrapperTable->m_Base_ClassTypeId));
		if ( (eLookupError != 0) || (pWrapperTable->m_Base_ClassTypeId == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_getbinarypath", (void**)&(pWrapperTable->m_BinaryStream_GetBinaryPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_GetBinaryPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_getindexpath", (void**)&(pWrapperTable->m_BinaryStream_GetIndexPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_GetIndexPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_getuuid", (void**)&(pWrapperTable->m_BinaryStream_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_disablediscretizedarraycompression", (void**)&(pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_DisableDiscretizedArrayCompression == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_enablediscretizedarraycompression", (void**)&(pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_EnableDiscretizedArrayCompression == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_enablelzma", (void**)&(pWrapperTable->m_BinaryStream_EnableLZMA));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_EnableLZMA == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_binarystream_disablelzma", (void**)&(pWrapperTable->m_BinaryStream_DisableLZMA));
		if ( (eLookupError != 0) || (pWrapperTable->m_BinaryStream_DisableLZMA == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_writetofile", (void**)&(pWrapperTable->m_Writer_WriteToFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_WriteToFile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_getstreamsize", (void**)&(pWrapperTable->m_Writer_GetStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_GetStreamSize == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_writetobuffer", (void**)&(pWrapperTable->m_Writer_WriteToBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_WriteToBuffer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_writetocallback", (void**)&(pWrapperTable->m_Writer_WriteToCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_WriteToCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_setprogresscallback", (void**)&(pWrapperTable->m_Writer_SetProgressCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_SetProgressCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_getdecimalprecision", (void**)&(pWrapperTable->m_Writer_GetDecimalPrecision));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_GetDecimalPrecision == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_setdecimalprecision", (void**)&(pWrapperTable->m_Writer_SetDecimalPrecision));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_SetDecimalPrecision == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_setstrictmodeactive", (void**)&(pWrapperTable->m_Writer_SetStrictModeActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_SetStrictModeActive == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_getstrictmodeactive", (void**)&(pWrapperTable->m_Writer_GetStrictModeActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_GetStrictModeActive == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_getwarning", (void**)&(pWrapperTable->m_Writer_GetWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_GetWarning == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_getwarningcount", (void**)&(pWrapperTable->m_Writer_GetWarningCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_GetWarningCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_addkeywrappingcallback", (void**)&(pWrapperTable->m_Writer_AddKeyWrappingCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_AddKeyWrappingCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_setcontentencryptioncallback", (void**)&(pWrapperTable->m_Writer_SetContentEncryptionCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_SetContentEncryptionCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_createbinarystream", (void**)&(pWrapperTable->m_Writer_CreateBinaryStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_CreateBinaryStream == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_assignbinarystream", (void**)&(pWrapperTable->m_Writer_AssignBinaryStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_AssignBinaryStream == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_writer_registercustomnamespace", (void**)&(pWrapperTable->m_Writer_RegisterCustomNamespace));
		if ( (eLookupError != 0) || (pWrapperTable->m_Writer_RegisterCustomNamespace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_persistentreadersource_getsourcetype", (void**)&(pWrapperTable->m_PersistentReaderSource_GetSourceType));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistentReaderSource_GetSourceType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_persistentreadersource_invalidatesourcedata", (void**)&(pWrapperTable->m_PersistentReaderSource_InvalidateSourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistentReaderSource_InvalidateSourceData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_persistentreadersource_sourcedataisvalid", (void**)&(pWrapperTable->m_PersistentReaderSource_SourceDataIsValid));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistentReaderSource_SourceDataIsValid == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_readfrompersistentsource", (void**)&(pWrapperTable->m_Reader_ReadFromPersistentSource));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_ReadFromPersistentSource == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_readfromfile", (void**)&(pWrapperTable->m_Reader_ReadFromFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_ReadFromFile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_readfrombuffer", (void**)&(pWrapperTable->m_Reader_ReadFromBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_ReadFromBuffer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_readfromcallback", (void**)&(pWrapperTable->m_Reader_ReadFromCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_ReadFromCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_setprogresscallback", (void**)&(pWrapperTable->m_Reader_SetProgressCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_SetProgressCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_addrelationtoread", (void**)&(pWrapperTable->m_Reader_AddRelationToRead));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_AddRelationToRead == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_removerelationtoread", (void**)&(pWrapperTable->m_Reader_RemoveRelationToRead));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_RemoveRelationToRead == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_setstrictmodeactive", (void**)&(pWrapperTable->m_Reader_SetStrictModeActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_SetStrictModeActive == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_getstrictmodeactive", (void**)&(pWrapperTable->m_Reader_GetStrictModeActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_GetStrictModeActive == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_getwarning", (void**)&(pWrapperTable->m_Reader_GetWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_GetWarning == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_getwarningcount", (void**)&(pWrapperTable->m_Reader_GetWarningCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_GetWarningCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_addkeywrappingcallback", (void**)&(pWrapperTable->m_Reader_AddKeyWrappingCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_AddKeyWrappingCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_reader_setcontentencryptioncallback", (void**)&(pWrapperTable->m_Reader_SetContentEncryptionCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Reader_SetContentEncryptionCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_packagepart_getpath", (void**)&(pWrapperTable->m_PackagePart_GetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_PackagePart_GetPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_packagepart_setpath", (void**)&(pWrapperTable->m_PackagePart_SetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_PackagePart_SetPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resource_getresourceid", (void**)&(pWrapperTable->m_Resource_GetResourceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Resource_GetResourceID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resource_getuniqueresourceid", (void**)&(pWrapperTable->m_Resource_GetUniqueResourceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Resource_GetUniqueResourceID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resource_packagepart", (void**)&(pWrapperTable->m_Resource_PackagePart));
		if ( (eLookupError != 0) || (pWrapperTable->m_Resource_PackagePart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resource_setpackagepart", (void**)&(pWrapperTable->m_Resource_SetPackagePart));
		if ( (eLookupError != 0) || (pWrapperTable->m_Resource_SetPackagePart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resource_getmodelresourceid", (void**)&(pWrapperTable->m_Resource_GetModelResourceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Resource_GetModelResourceID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourceiterator_movenext", (void**)&(pWrapperTable->m_ResourceIterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceIterator_MoveNext == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourceiterator_moveprevious", (void**)&(pWrapperTable->m_ResourceIterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceIterator_MovePrevious == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourceiterator_getcurrent", (void**)&(pWrapperTable->m_ResourceIterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceIterator_GetCurrent == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourceiterator_clone", (void**)&(pWrapperTable->m_ResourceIterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceIterator_Clone == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourceiterator_count", (void**)&(pWrapperTable->m_ResourceIterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceIterator_Count == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_getname", (void**)&(pWrapperTable->m_CustomXMLAttribute_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_getvalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_GetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_GetValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_isvalidinteger", (void**)&(pWrapperTable->m_CustomXMLAttribute_IsValidInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_IsValidInteger == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_getintegervalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_GetIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_GetIntegerValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_isvaliddouble", (void**)&(pWrapperTable->m_CustomXMLAttribute_IsValidDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_IsValidDouble == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_getdoublevalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_GetDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_GetDoubleValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_isvalidbool", (void**)&(pWrapperTable->m_CustomXMLAttribute_IsValidBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_IsValidBool == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_getboolvalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_GetBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_GetBoolValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_setvalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_SetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_SetValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_setintegervalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_SetIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_SetIntegerValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_setdoublevalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_SetDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_SetDoubleValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_setboolvalue", (void**)&(pWrapperTable->m_CustomXMLAttribute_SetBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_SetBoolValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlattribute_remove", (void**)&(pWrapperTable->m_CustomXMLAttribute_Remove));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLAttribute_Remove == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getname", (void**)&(pWrapperTable->m_CustomXMLNode_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getnamespace", (void**)&(pWrapperTable->m_CustomXMLNode_GetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetNameSpace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getattributecount", (void**)&(pWrapperTable->m_CustomXMLNode_GetAttributeCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetAttributeCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getattribute", (void**)&(pWrapperTable->m_CustomXMLNode_GetAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_hasattribute", (void**)&(pWrapperTable->m_CustomXMLNode_HasAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_HasAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_findattribute", (void**)&(pWrapperTable->m_CustomXMLNode_FindAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_FindAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_removeattribute", (void**)&(pWrapperTable->m_CustomXMLNode_RemoveAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_RemoveAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_removeattributebyindex", (void**)&(pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_RemoveAttributeByIndex == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_addattribute", (void**)&(pWrapperTable->m_CustomXMLNode_AddAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_AddAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_addintegerattribute", (void**)&(pWrapperTable->m_CustomXMLNode_AddIntegerAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_AddIntegerAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_adddoubleattribute", (void**)&(pWrapperTable->m_CustomXMLNode_AddDoubleAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_AddDoubleAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_addboolattribute", (void**)&(pWrapperTable->m_CustomXMLNode_AddBoolAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_AddBoolAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getchildren", (void**)&(pWrapperTable->m_CustomXMLNode_GetChildren));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetChildren == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_countchildrenbyname", (void**)&(pWrapperTable->m_CustomXMLNode_CountChildrenByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_CountChildrenByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_getchildrenbyname", (void**)&(pWrapperTable->m_CustomXMLNode_GetChildrenByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_GetChildrenByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_haschild", (void**)&(pWrapperTable->m_CustomXMLNode_HasChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_HasChild == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_hasuniquechild", (void**)&(pWrapperTable->m_CustomXMLNode_HasUniqueChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_HasUniqueChild == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_findchild", (void**)&(pWrapperTable->m_CustomXMLNode_FindChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_FindChild == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_addchild", (void**)&(pWrapperTable->m_CustomXMLNode_AddChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_AddChild == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_removechild", (void**)&(pWrapperTable->m_CustomXMLNode_RemoveChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_RemoveChild == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_removechildrenwithname", (void**)&(pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_RemoveChildrenWithName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnode_remove", (void**)&(pWrapperTable->m_CustomXMLNode_Remove));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNode_Remove == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_getnodecount", (void**)&(pWrapperTable->m_CustomXMLNodes_GetNodeCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_GetNodeCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_getnode", (void**)&(pWrapperTable->m_CustomXMLNodes_GetNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_GetNode == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_countnodesbyname", (void**)&(pWrapperTable->m_CustomXMLNodes_CountNodesByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_CountNodesByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_getnodesbyname", (void**)&(pWrapperTable->m_CustomXMLNodes_GetNodesByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_GetNodesByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_hasnode", (void**)&(pWrapperTable->m_CustomXMLNodes_HasNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_HasNode == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_hasuniquenode", (void**)&(pWrapperTable->m_CustomXMLNodes_HasUniqueNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_HasUniqueNode == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customxmlnodes_findnode", (void**)&(pWrapperTable->m_CustomXMLNodes_FindNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomXMLNodes_FindNode == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customdomtree_getnamespace", (void**)&(pWrapperTable->m_CustomDOMTree_GetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDOMTree_GetNameSpace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customdomtree_getrootnode", (void**)&(pWrapperTable->m_CustomDOMTree_GetRootNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDOMTree_GetRootNode == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_customdomtree_savetostring", (void**)&(pWrapperTable->m_CustomDOMTree_SaveToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDOMTree_SaveToString == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestackiterator_getcurrentslicestack", (void**)&(pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStackIterator_GetCurrentSliceStack == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_objectiterator_getcurrentobject", (void**)&(pWrapperTable->m_ObjectIterator_GetCurrentObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_ObjectIterator_GetCurrentObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobjectiterator_getcurrentmeshobject", (void**)&(pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObjectIterator_GetCurrentMeshObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_componentsobjectiterator_getcurrentcomponentsobject", (void**)&(pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_ComponentsObjectIterator_GetCurrentComponentsObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2diterator_getcurrenttexture2d", (void**)&(pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DIterator_GetCurrentTexture2D == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup", (void**)&(pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroupiterator_getcurrentcolorgroup", (void**)&(pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroupIterator_GetCurrentColorGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup", (void**)&(pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroupIterator_GetCurrentTexture2DGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerialsiterator_getcurrentcompositematerials", (void**)&(pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterialsIterator_GetCurrentCompositeMaterials == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup", (void**)&(pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_getnamespace", (void**)&(pWrapperTable->m_MetaData_GetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetNameSpace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_setnamespace", (void**)&(pWrapperTable->m_MetaData_SetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_SetNameSpace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_getname", (void**)&(pWrapperTable->m_MetaData_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_setname", (void**)&(pWrapperTable->m_MetaData_SetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_SetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_getkey", (void**)&(pWrapperTable->m_MetaData_GetKey));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetKey == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_getmustpreserve", (void**)&(pWrapperTable->m_MetaData_GetMustPreserve));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetMustPreserve == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_setmustpreserve", (void**)&(pWrapperTable->m_MetaData_SetMustPreserve));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_SetMustPreserve == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_gettype", (void**)&(pWrapperTable->m_MetaData_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_settype", (void**)&(pWrapperTable->m_MetaData_SetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_SetType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_getvalue", (void**)&(pWrapperTable->m_MetaData_GetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_GetValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadata_setvalue", (void**)&(pWrapperTable->m_MetaData_SetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaData_SetValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_getmetadatacount", (void**)&(pWrapperTable->m_MetaDataGroup_GetMetaDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_GetMetaDataCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_getmetadata", (void**)&(pWrapperTable->m_MetaDataGroup_GetMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_GetMetaData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_getmetadatabykey", (void**)&(pWrapperTable->m_MetaDataGroup_GetMetaDataByKey));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_GetMetaDataByKey == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_removemetadatabyindex", (void**)&(pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_RemoveMetaDataByIndex == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_removemetadata", (void**)&(pWrapperTable->m_MetaDataGroup_RemoveMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_RemoveMetaData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_metadatagroup_addmetadata", (void**)&(pWrapperTable->m_MetaDataGroup_AddMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_MetaDataGroup_AddMetaData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_gettype", (void**)&(pWrapperTable->m_Object_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_settype", (void**)&(pWrapperTable->m_Object_SetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getname", (void**)&(pWrapperTable->m_Object_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_setname", (void**)&(pWrapperTable->m_Object_SetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getpartnumber", (void**)&(pWrapperTable->m_Object_GetPartNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetPartNumber == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_setpartnumber", (void**)&(pWrapperTable->m_Object_SetPartNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetPartNumber == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_ismeshobject", (void**)&(pWrapperTable->m_Object_IsMeshObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_IsMeshObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_iscomponentsobject", (void**)&(pWrapperTable->m_Object_IsComponentsObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_IsComponentsObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_isvalid", (void**)&(pWrapperTable->m_Object_IsValid));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_IsValid == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_setattachmentasthumbnail", (void**)&(pWrapperTable->m_Object_SetAttachmentAsThumbnail));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetAttachmentAsThumbnail == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getthumbnailattachment", (void**)&(pWrapperTable->m_Object_GetThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_clearthumbnailattachment", (void**)&(pWrapperTable->m_Object_ClearThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_ClearThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getoutbox", (void**)&(pWrapperTable->m_Object_GetOutbox));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetOutbox == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getuuid", (void**)&(pWrapperTable->m_Object_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_setuuid", (void**)&(pWrapperTable->m_Object_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getmetadatagroup", (void**)&(pWrapperTable->m_Object_GetMetaDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetMetaDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_setslicesmeshresolution", (void**)&(pWrapperTable->m_Object_SetSlicesMeshResolution));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_SetSlicesMeshResolution == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getslicesmeshresolution", (void**)&(pWrapperTable->m_Object_GetSlicesMeshResolution));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetSlicesMeshResolution == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_hasslices", (void**)&(pWrapperTable->m_Object_HasSlices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_HasSlices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_clearslicestack", (void**)&(pWrapperTable->m_Object_ClearSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_ClearSliceStack == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_getslicestack", (void**)&(pWrapperTable->m_Object_GetSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_GetSliceStack == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_object_assignslicestack", (void**)&(pWrapperTable->m_Object_AssignSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Object_AssignSliceStack == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_getvertexcount", (void**)&(pWrapperTable->m_MeshObject_GetVertexCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertexCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_gettrianglecount", (void**)&(pWrapperTable->m_MeshObject_GetTriangleCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangleCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_getvertex", (void**)&(pWrapperTable->m_MeshObject_GetVertex));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertex == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_setvertex", (void**)&(pWrapperTable->m_MeshObject_SetVertex));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetVertex == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_addvertex", (void**)&(pWrapperTable->m_MeshObject_AddVertex));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_AddVertex == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_getvertices", (void**)&(pWrapperTable->m_MeshObject_GetVertices));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_gettriangle", (void**)&(pWrapperTable->m_MeshObject_GetTriangle));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangle == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_settriangle", (void**)&(pWrapperTable->m_MeshObject_SetTriangle));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetTriangle == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_addtriangle", (void**)&(pWrapperTable->m_MeshObject_AddTriangle));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_AddTriangle == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_gettriangleindices", (void**)&(pWrapperTable->m_MeshObject_GetTriangleIndices));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangleIndices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_setobjectlevelproperty", (void**)&(pWrapperTable->m_MeshObject_SetObjectLevelProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetObjectLevelProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_getobjectlevelproperty", (void**)&(pWrapperTable->m_MeshObject_GetObjectLevelProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetObjectLevelProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_settriangleproperties", (void**)&(pWrapperTable->m_MeshObject_SetTriangleProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetTriangleProperties == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_gettriangleproperties", (void**)&(pWrapperTable->m_MeshObject_GetTriangleProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangleProperties == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_setalltriangleproperties", (void**)&(pWrapperTable->m_MeshObject_SetAllTriangleProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetAllTriangleProperties == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_getalltriangleproperties", (void**)&(pWrapperTable->m_MeshObject_GetAllTriangleProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetAllTriangleProperties == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_clearallproperties", (void**)&(pWrapperTable->m_MeshObject_ClearAllProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_ClearAllProperties == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_setgeometry", (void**)&(pWrapperTable->m_MeshObject_SetGeometry));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_SetGeometry == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_ismanifoldandoriented", (void**)&(pWrapperTable->m_MeshObject_IsManifoldAndOriented));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_IsManifoldAndOriented == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_meshobject_beamlattice", (void**)&(pWrapperTable->m_MeshObject_BeamLattice));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_BeamLattice == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getminlength", (void**)&(pWrapperTable->m_BeamLattice_GetMinLength));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetMinLength == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setminlength", (void**)&(pWrapperTable->m_BeamLattice_SetMinLength));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetMinLength == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getclipping", (void**)&(pWrapperTable->m_BeamLattice_GetClipping));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetClipping == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setclipping", (void**)&(pWrapperTable->m_BeamLattice_SetClipping));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetClipping == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getrepresentation", (void**)&(pWrapperTable->m_BeamLattice_GetRepresentation));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetRepresentation == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setrepresentation", (void**)&(pWrapperTable->m_BeamLattice_SetRepresentation));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetRepresentation == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getballoptions", (void**)&(pWrapperTable->m_BeamLattice_GetBallOptions));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBallOptions == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setballoptions", (void**)&(pWrapperTable->m_BeamLattice_SetBallOptions));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetBallOptions == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getbeamcount", (void**)&(pWrapperTable->m_BeamLattice_GetBeamCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBeamCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getbeam", (void**)&(pWrapperTable->m_BeamLattice_GetBeam));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBeam == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_addbeam", (void**)&(pWrapperTable->m_BeamLattice_AddBeam));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_AddBeam == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setbeam", (void**)&(pWrapperTable->m_BeamLattice_SetBeam));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetBeam == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setbeams", (void**)&(pWrapperTable->m_BeamLattice_SetBeams));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetBeams == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getbeams", (void**)&(pWrapperTable->m_BeamLattice_GetBeams));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBeams == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getballcount", (void**)&(pWrapperTable->m_BeamLattice_GetBallCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBallCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getball", (void**)&(pWrapperTable->m_BeamLattice_GetBall));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBall == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_addball", (void**)&(pWrapperTable->m_BeamLattice_AddBall));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_AddBall == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setball", (void**)&(pWrapperTable->m_BeamLattice_SetBall));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetBall == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_setballs", (void**)&(pWrapperTable->m_BeamLattice_SetBalls));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_SetBalls == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getballs", (void**)&(pWrapperTable->m_BeamLattice_GetBalls));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBalls == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getbeamsetcount", (void**)&(pWrapperTable->m_BeamLattice_GetBeamSetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBeamSetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_addbeamset", (void**)&(pWrapperTable->m_BeamLattice_AddBeamSet));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_AddBeamSet == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamlattice_getbeamset", (void**)&(pWrapperTable->m_BeamLattice_GetBeamSet));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamLattice_GetBeamSet == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_getobjectresource", (void**)&(pWrapperTable->m_Component_GetObjectResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_GetObjectResource == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_getobjectresourceid", (void**)&(pWrapperTable->m_Component_GetObjectResourceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_GetObjectResourceID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_getuuid", (void**)&(pWrapperTable->m_Component_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_setuuid", (void**)&(pWrapperTable->m_Component_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_SetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_hastransform", (void**)&(pWrapperTable->m_Component_HasTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_HasTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_gettransform", (void**)&(pWrapperTable->m_Component_GetTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_GetTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_component_settransform", (void**)&(pWrapperTable->m_Component_SetTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_Component_SetTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_componentsobject_addcomponent", (void**)&(pWrapperTable->m_ComponentsObject_AddComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ComponentsObject_AddComponent == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_componentsobject_getcomponent", (void**)&(pWrapperTable->m_ComponentsObject_GetComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ComponentsObject_GetComponent == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_componentsobject_getcomponentcount", (void**)&(pWrapperTable->m_ComponentsObject_GetComponentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ComponentsObject_GetComponentCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_setname", (void**)&(pWrapperTable->m_BeamSet_SetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_SetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getname", (void**)&(pWrapperTable->m_BeamSet_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_setidentifier", (void**)&(pWrapperTable->m_BeamSet_SetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_SetIdentifier == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getidentifier", (void**)&(pWrapperTable->m_BeamSet_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetIdentifier == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getreferencecount", (void**)&(pWrapperTable->m_BeamSet_GetReferenceCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetReferenceCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_setreferences", (void**)&(pWrapperTable->m_BeamSet_SetReferences));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_SetReferences == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getreferences", (void**)&(pWrapperTable->m_BeamSet_GetReferences));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetReferences == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getballreferencecount", (void**)&(pWrapperTable->m_BeamSet_GetBallReferenceCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetBallReferenceCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_setballreferences", (void**)&(pWrapperTable->m_BeamSet_SetBallReferences));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_SetBallReferences == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_beamset_getballreferences", (void**)&(pWrapperTable->m_BeamSet_GetBallReferences));
		if ( (eLookupError != 0) || (pWrapperTable->m_BeamSet_GetBallReferences == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_getcount", (void**)&(pWrapperTable->m_BaseMaterialGroup_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_GetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_getallpropertyids", (void**)&(pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_GetAllPropertyIDs == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_addmaterial", (void**)&(pWrapperTable->m_BaseMaterialGroup_AddMaterial));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_AddMaterial == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_removematerial", (void**)&(pWrapperTable->m_BaseMaterialGroup_RemoveMaterial));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_RemoveMaterial == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_getname", (void**)&(pWrapperTable->m_BaseMaterialGroup_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_setname", (void**)&(pWrapperTable->m_BaseMaterialGroup_SetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_SetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_setdisplaycolor", (void**)&(pWrapperTable->m_BaseMaterialGroup_SetDisplayColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_SetDisplayColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_basematerialgroup_getdisplaycolor", (void**)&(pWrapperTable->m_BaseMaterialGroup_GetDisplayColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseMaterialGroup_GetDisplayColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_getcount", (void**)&(pWrapperTable->m_ColorGroup_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_GetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_getallpropertyids", (void**)&(pWrapperTable->m_ColorGroup_GetAllPropertyIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_GetAllPropertyIDs == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_addcolor", (void**)&(pWrapperTable->m_ColorGroup_AddColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_AddColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_removecolor", (void**)&(pWrapperTable->m_ColorGroup_RemoveColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_RemoveColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_setcolor", (void**)&(pWrapperTable->m_ColorGroup_SetColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_SetColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colorgroup_getcolor", (void**)&(pWrapperTable->m_ColorGroup_GetColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorGroup_GetColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_getcount", (void**)&(pWrapperTable->m_Texture2DGroup_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_GetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_getallpropertyids", (void**)&(pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_GetAllPropertyIDs == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_addtex2coord", (void**)&(pWrapperTable->m_Texture2DGroup_AddTex2Coord));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_AddTex2Coord == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_gettex2coord", (void**)&(pWrapperTable->m_Texture2DGroup_GetTex2Coord));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_GetTex2Coord == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_removetex2coord", (void**)&(pWrapperTable->m_Texture2DGroup_RemoveTex2Coord));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_RemoveTex2Coord == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2dgroup_gettexture2d", (void**)&(pWrapperTable->m_Texture2DGroup_GetTexture2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2DGroup_GetTexture2D == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_getcount", (void**)&(pWrapperTable->m_CompositeMaterials_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_GetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_getallpropertyids", (void**)&(pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_GetAllPropertyIDs == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_getbasematerialgroup", (void**)&(pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_GetBaseMaterialGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_addcomposite", (void**)&(pWrapperTable->m_CompositeMaterials_AddComposite));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_AddComposite == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_removecomposite", (void**)&(pWrapperTable->m_CompositeMaterials_RemoveComposite));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_RemoveComposite == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_compositematerials_getcomposite", (void**)&(pWrapperTable->m_CompositeMaterials_GetComposite));
		if ( (eLookupError != 0) || (pWrapperTable->m_CompositeMaterials_GetComposite == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_getcount", (void**)&(pWrapperTable->m_MultiPropertyGroup_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_GetCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_getallpropertyids", (void**)&(pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_GetAllPropertyIDs == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_addmultiproperty", (void**)&(pWrapperTable->m_MultiPropertyGroup_AddMultiProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_AddMultiProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_setmultiproperty", (void**)&(pWrapperTable->m_MultiPropertyGroup_SetMultiProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_SetMultiProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_getmultiproperty", (void**)&(pWrapperTable->m_MultiPropertyGroup_GetMultiProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_GetMultiProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_removemultiproperty", (void**)&(pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_RemoveMultiProperty == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_getlayercount", (void**)&(pWrapperTable->m_MultiPropertyGroup_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_GetLayerCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_addlayer", (void**)&(pWrapperTable->m_MultiPropertyGroup_AddLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_AddLayer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_getlayer", (void**)&(pWrapperTable->m_MultiPropertyGroup_GetLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_GetLayer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_multipropertygroup_removelayer", (void**)&(pWrapperTable->m_MultiPropertyGroup_RemoveLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_MultiPropertyGroup_RemoveLayer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_getpath", (void**)&(pWrapperTable->m_Attachment_GetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_GetPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_setpath", (void**)&(pWrapperTable->m_Attachment_SetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_SetPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_packagepart", (void**)&(pWrapperTable->m_Attachment_PackagePart));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_PackagePart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_getrelationshiptype", (void**)&(pWrapperTable->m_Attachment_GetRelationShipType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_GetRelationShipType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_setrelationshiptype", (void**)&(pWrapperTable->m_Attachment_SetRelationShipType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_SetRelationShipType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_writetofile", (void**)&(pWrapperTable->m_Attachment_WriteToFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_WriteToFile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_readfromfile", (void**)&(pWrapperTable->m_Attachment_ReadFromFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_ReadFromFile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_readfromcallback", (void**)&(pWrapperTable->m_Attachment_ReadFromCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_ReadFromCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_getstreamsize", (void**)&(pWrapperTable->m_Attachment_GetStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_GetStreamSize == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_writetobuffer", (void**)&(pWrapperTable->m_Attachment_WriteToBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_WriteToBuffer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_attachment_readfrombuffer", (void**)&(pWrapperTable->m_Attachment_ReadFromBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Attachment_ReadFromBuffer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_getattachment", (void**)&(pWrapperTable->m_Texture2D_GetAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_GetAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_setattachment", (void**)&(pWrapperTable->m_Texture2D_SetAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_SetAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_getcontenttype", (void**)&(pWrapperTable->m_Texture2D_GetContentType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_GetContentType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_setcontenttype", (void**)&(pWrapperTable->m_Texture2D_SetContentType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_SetContentType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_gettilestyleuv", (void**)&(pWrapperTable->m_Texture2D_GetTileStyleUV));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_GetTileStyleUV == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_settilestyleuv", (void**)&(pWrapperTable->m_Texture2D_SetTileStyleUV));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_SetTileStyleUV == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_getfilter", (void**)&(pWrapperTable->m_Texture2D_GetFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_GetFilter == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_texture2d_setfilter", (void**)&(pWrapperTable->m_Texture2D_SetFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Texture2D_SetFilter == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getobjectresource", (void**)&(pWrapperTable->m_BuildItem_GetObjectResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetObjectResource == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getuuid", (void**)&(pWrapperTable->m_BuildItem_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_setuuid", (void**)&(pWrapperTable->m_BuildItem_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_SetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getobjectresourceid", (void**)&(pWrapperTable->m_BuildItem_GetObjectResourceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetObjectResourceID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_hasobjecttransform", (void**)&(pWrapperTable->m_BuildItem_HasObjectTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_HasObjectTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getobjecttransform", (void**)&(pWrapperTable->m_BuildItem_GetObjectTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetObjectTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_setobjecttransform", (void**)&(pWrapperTable->m_BuildItem_SetObjectTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_SetObjectTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getpartnumber", (void**)&(pWrapperTable->m_BuildItem_GetPartNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetPartNumber == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_setpartnumber", (void**)&(pWrapperTable->m_BuildItem_SetPartNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_SetPartNumber == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getmetadatagroup", (void**)&(pWrapperTable->m_BuildItem_GetMetaDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetMetaDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditem_getoutbox", (void**)&(pWrapperTable->m_BuildItem_GetOutbox));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItem_GetOutbox == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditemiterator_movenext", (void**)&(pWrapperTable->m_BuildItemIterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItemIterator_MoveNext == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditemiterator_moveprevious", (void**)&(pWrapperTable->m_BuildItemIterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItemIterator_MovePrevious == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditemiterator_getcurrent", (void**)&(pWrapperTable->m_BuildItemIterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItemIterator_GetCurrent == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditemiterator_clone", (void**)&(pWrapperTable->m_BuildItemIterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItemIterator_Clone == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_builditemiterator_count", (void**)&(pWrapperTable->m_BuildItemIterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildItemIterator_Count == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_setvertices", (void**)&(pWrapperTable->m_Slice_SetVertices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_SetVertices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getvertices", (void**)&(pWrapperTable->m_Slice_GetVertices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetVertices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getvertexcount", (void**)&(pWrapperTable->m_Slice_GetVertexCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetVertexCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_addpolygon", (void**)&(pWrapperTable->m_Slice_AddPolygon));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_AddPolygon == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getpolygoncount", (void**)&(pWrapperTable->m_Slice_GetPolygonCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetPolygonCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_setpolygonindices", (void**)&(pWrapperTable->m_Slice_SetPolygonIndices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_SetPolygonIndices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getpolygonindices", (void**)&(pWrapperTable->m_Slice_GetPolygonIndices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetPolygonIndices == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getpolygonindexcount", (void**)&(pWrapperTable->m_Slice_GetPolygonIndexCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetPolygonIndexCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slice_getztop", (void**)&(pWrapperTable->m_Slice_GetZTop));
		if ( (eLookupError != 0) || (pWrapperTable->m_Slice_GetZTop == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getuuid", (void**)&(pWrapperTable->m_ToolpathProfile_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getname", (void**)&(pWrapperTable->m_ToolpathProfile_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparametercount", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparametername", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameternamespace", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterNameSpace == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_hasparametervalue", (void**)&(pWrapperTable->m_ToolpathProfile_HasParameterValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_HasParameterValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparametervalue", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparametervaluedef", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterValueDef == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterdoublevalue", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterDoubleValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterdoublevaluedef", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterDoubleValueDef == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterintegervalue", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterIntegerValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterintegervaluedef", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterIntegerValueDef == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterboolvalue", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterBoolValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_getparameterboolvaluedef", (void**)&(pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_GetParameterBoolValueDef == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_setname", (void**)&(pWrapperTable->m_ToolpathProfile_SetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_SetName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_setparametervalue", (void**)&(pWrapperTable->m_ToolpathProfile_SetParameterValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_SetParameterValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_setparameterdoublevalue", (void**)&(pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_SetParameterDoubleValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_setparameterintegervalue", (void**)&(pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_SetParameterIntegerValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathprofile_setparameterboolvalue", (void**)&(pWrapperTable->m_ToolpathProfile_SetParameterBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathProfile_SetParameterBoolValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getlayerdatauuid", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetLayerDataUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentcount", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentinfo", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentInfo == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentprofile", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentProfile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentprofileuuid", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentProfileUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentpart", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentPart));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentPart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentpartuuid", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentPartUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentpointdata", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentPointData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_findattributeinfobyname", (void**)&(pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_FindAttributeInfoByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_findattributeidbyname", (void**)&(pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_FindAttributeIDByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_findattributevaluebyname", (void**)&(pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_FindAttributeValueByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentintegerattributebyid", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentintegerattributebyname", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentIntegerAttributeByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentdoubleattributebyid", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getsegmentdoubleattributebyname", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetSegmentDoubleAttributeByName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getcustomdatacount", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetCustomDataCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getcustomdata", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerreader_getcustomdataname", (void**)&(pWrapperTable->m_ToolpathLayerReader_GetCustomDataName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerReader_GetCustomDataName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_getlayerdatauuid", (void**)&(pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_GetLayerDataUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_registerprofile", (void**)&(pWrapperTable->m_ToolpathLayerData_RegisterProfile));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_RegisterProfile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_registerbuilditem", (void**)&(pWrapperTable->m_ToolpathLayerData_RegisterBuildItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_RegisterBuildItem == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_setsegmentattribute", (void**)&(pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_SetSegmentAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_clearsegmentattributes", (void**)&(pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_ClearSegmentAttributes == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_writehatchdata", (void**)&(pWrapperTable->m_ToolpathLayerData_WriteHatchData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_WriteHatchData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_writeloop", (void**)&(pWrapperTable->m_ToolpathLayerData_WriteLoop));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_WriteLoop == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_writepolyline", (void**)&(pWrapperTable->m_ToolpathLayerData_WritePolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_WritePolyline == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_addcustomdata", (void**)&(pWrapperTable->m_ToolpathLayerData_AddCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_AddCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathlayerdata_finish", (void**)&(pWrapperTable->m_ToolpathLayerData_Finish));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayerData_Finish == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getunits", (void**)&(pWrapperTable->m_Toolpath_GetUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetUnits == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getlayercount", (void**)&(pWrapperTable->m_Toolpath_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetLayerCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getprofilecount", (void**)&(pWrapperTable->m_Toolpath_GetProfileCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetProfileCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_addlayer", (void**)&(pWrapperTable->m_Toolpath_AddLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_AddLayer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getlayerattachment", (void**)&(pWrapperTable->m_Toolpath_GetLayerAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetLayerAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_readlayerdata", (void**)&(pWrapperTable->m_Toolpath_ReadLayerData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_ReadLayerData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getlayerpath", (void**)&(pWrapperTable->m_Toolpath_GetLayerPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetLayerPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getlayerzmax", (void**)&(pWrapperTable->m_Toolpath_GetLayerZMax));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetLayerZMax == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getlayerz", (void**)&(pWrapperTable->m_Toolpath_GetLayerZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetLayerZ == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_addprofile", (void**)&(pWrapperTable->m_Toolpath_AddProfile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_AddProfile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getprofile", (void**)&(pWrapperTable->m_Toolpath_GetProfile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetProfile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getprofileuuid", (void**)&(pWrapperTable->m_Toolpath_GetProfileUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetProfileUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getcustomdatacount", (void**)&(pWrapperTable->m_Toolpath_GetCustomDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetCustomDataCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getcustomdata", (void**)&(pWrapperTable->m_Toolpath_GetCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_getcustomdataname", (void**)&(pWrapperTable->m_Toolpath_GetCustomDataName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_GetCustomDataName == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_hasuniquecustomdata", (void**)&(pWrapperTable->m_Toolpath_HasUniqueCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_HasUniqueCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_finduniquecustomdata", (void**)&(pWrapperTable->m_Toolpath_FindUniqueCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_FindUniqueCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_addcustomdata", (void**)&(pWrapperTable->m_Toolpath_AddCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_AddCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_clearcustomdata", (void**)&(pWrapperTable->m_Toolpath_ClearCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_ClearCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_deletecustomdata", (void**)&(pWrapperTable->m_Toolpath_DeleteCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_DeleteCustomData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_registercustomintegerattribute", (void**)&(pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_RegisterCustomIntegerAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpath_registercustomdoubleattribute", (void**)&(pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_Toolpath_RegisterCustomDoubleAttribute == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_toolpathiterator_getcurrenttoolpath", (void**)&(pWrapperTable->m_ToolpathIterator_GetCurrentToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathIterator_GetCurrentToolpath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getbottomz", (void**)&(pWrapperTable->m_SliceStack_GetBottomZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetBottomZ == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getslicecount", (void**)&(pWrapperTable->m_SliceStack_GetSliceCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetSliceCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getslice", (void**)&(pWrapperTable->m_SliceStack_GetSlice));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetSlice == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_addslice", (void**)&(pWrapperTable->m_SliceStack_AddSlice));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_AddSlice == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getslicerefcount", (void**)&(pWrapperTable->m_SliceStack_GetSliceRefCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetSliceRefCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_addslicestackreference", (void**)&(pWrapperTable->m_SliceStack_AddSliceStackReference));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_AddSliceStackReference == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getslicestackreference", (void**)&(pWrapperTable->m_SliceStack_GetSliceStackReference));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetSliceStackReference == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_collapseslicereferences", (void**)&(pWrapperTable->m_SliceStack_CollapseSliceReferences));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_CollapseSliceReferences == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_setownpath", (void**)&(pWrapperTable->m_SliceStack_SetOwnPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_SetOwnPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_slicestack_getownpath", (void**)&(pWrapperTable->m_SliceStack_GetOwnPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetOwnPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_consumer_getconsumerid", (void**)&(pWrapperTable->m_Consumer_GetConsumerID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Consumer_GetConsumerID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_consumer_getkeyid", (void**)&(pWrapperTable->m_Consumer_GetKeyID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Consumer_GetKeyID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_consumer_getkeyvalue", (void**)&(pWrapperTable->m_Consumer_GetKeyValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_Consumer_GetKeyValue == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_accessright_getconsumer", (void**)&(pWrapperTable->m_AccessRight_GetConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_AccessRight_GetConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_accessright_getwrappingalgorithm", (void**)&(pWrapperTable->m_AccessRight_GetWrappingAlgorithm));
		if ( (eLookupError != 0) || (pWrapperTable->m_AccessRight_GetWrappingAlgorithm == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_accessright_getmgfalgorithm", (void**)&(pWrapperTable->m_AccessRight_GetMgfAlgorithm));
		if ( (eLookupError != 0) || (pWrapperTable->m_AccessRight_GetMgfAlgorithm == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_accessright_getdigestmethod", (void**)&(pWrapperTable->m_AccessRight_GetDigestMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_AccessRight_GetDigestMethod == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getencryptionalgorithm", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetEncryptionAlgorithm == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getkey", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetKey));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetKey == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getinitializationvector", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetInitializationVector));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetInitializationVector == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getauthenticationtag", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetAuthenticationTag == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_setauthenticationtag", (void**)&(pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_SetAuthenticationTag == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getadditionalauthenticationdata", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetAdditionalAuthenticationData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getdescriptor", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetDescriptor));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetDescriptor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_contentencryptionparams_getkeyuuid", (void**)&(pWrapperTable->m_ContentEncryptionParams_GetKeyUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ContentEncryptionParams_GetKeyUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedata_getpath", (void**)&(pWrapperTable->m_ResourceData_GetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceData_GetPath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedata_getencryptionalgorithm", (void**)&(pWrapperTable->m_ResourceData_GetEncryptionAlgorithm));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceData_GetEncryptionAlgorithm == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedata_getcompression", (void**)&(pWrapperTable->m_ResourceData_GetCompression));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceData_GetCompression == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedata_getadditionalauthenticationdata", (void**)&(pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceData_GetAdditionalAuthenticationData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedatagroup_getkeyuuid", (void**)&(pWrapperTable->m_ResourceDataGroup_GetKeyUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceDataGroup_GetKeyUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedatagroup_addaccessright", (void**)&(pWrapperTable->m_ResourceDataGroup_AddAccessRight));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceDataGroup_AddAccessRight == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedatagroup_findaccessrightbyconsumer", (void**)&(pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceDataGroup_FindAccessRightByConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_resourcedatagroup_removeaccessright", (void**)&(pWrapperTable->m_ResourceDataGroup_RemoveAccessRight));
		if ( (eLookupError != 0) || (pWrapperTable->m_ResourceDataGroup_RemoveAccessRight == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_addconsumer", (void**)&(pWrapperTable->m_KeyStore_AddConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_AddConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getconsumercount", (void**)&(pWrapperTable->m_KeyStore_GetConsumerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetConsumerCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getconsumer", (void**)&(pWrapperTable->m_KeyStore_GetConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_removeconsumer", (void**)&(pWrapperTable->m_KeyStore_RemoveConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_RemoveConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_findconsumer", (void**)&(pWrapperTable->m_KeyStore_FindConsumer));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_FindConsumer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getresourcedatagroupcount", (void**)&(pWrapperTable->m_KeyStore_GetResourceDataGroupCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetResourceDataGroupCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_addresourcedatagroup", (void**)&(pWrapperTable->m_KeyStore_AddResourceDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_AddResourceDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getresourcedatagroup", (void**)&(pWrapperTable->m_KeyStore_GetResourceDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetResourceDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_removeresourcedatagroup", (void**)&(pWrapperTable->m_KeyStore_RemoveResourceDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_RemoveResourceDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_findresourcedatagroup", (void**)&(pWrapperTable->m_KeyStore_FindResourceDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_FindResourceDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_addresourcedata", (void**)&(pWrapperTable->m_KeyStore_AddResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_AddResourceData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_removeresourcedata", (void**)&(pWrapperTable->m_KeyStore_RemoveResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_RemoveResourceData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_findresourcedata", (void**)&(pWrapperTable->m_KeyStore_FindResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_FindResourceData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getresourcedatacount", (void**)&(pWrapperTable->m_KeyStore_GetResourceDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetResourceDataCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getresourcedata", (void**)&(pWrapperTable->m_KeyStore_GetResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetResourceData == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_getuuid", (void**)&(pWrapperTable->m_KeyStore_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_GetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_keystore_setuuid", (void**)&(pWrapperTable->m_KeyStore_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_KeyStore_SetUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_rootmodelpart", (void**)&(pWrapperTable->m_Model_RootModelPart));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_RootModelPart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_findorcreatepackagepart", (void**)&(pWrapperTable->m_Model_FindOrCreatePackagePart));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_FindOrCreatePackagePart == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_setunit", (void**)&(pWrapperTable->m_Model_SetUnit));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_SetUnit == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getunit", (void**)&(pWrapperTable->m_Model_GetUnit));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetUnit == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getlanguage", (void**)&(pWrapperTable->m_Model_GetLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetLanguage == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_setlanguage", (void**)&(pWrapperTable->m_Model_SetLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_SetLanguage == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_querywriter", (void**)&(pWrapperTable->m_Model_QueryWriter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_QueryWriter == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_queryreader", (void**)&(pWrapperTable->m_Model_QueryReader));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_QueryReader == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getresourcebyid", (void**)&(pWrapperTable->m_Model_GetResourceByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetResourceByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_gettexture2dbyid", (void**)&(pWrapperTable->m_Model_GetTexture2DByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetTexture2DByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getpropertytypebyid", (void**)&(pWrapperTable->m_Model_GetPropertyTypeByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetPropertyTypeByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getbasematerialgroupbyid", (void**)&(pWrapperTable->m_Model_GetBaseMaterialGroupByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetBaseMaterialGroupByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_gettexture2dgroupbyid", (void**)&(pWrapperTable->m_Model_GetTexture2DGroupByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetTexture2DGroupByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcompositematerialsbyid", (void**)&(pWrapperTable->m_Model_GetCompositeMaterialsByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetCompositeMaterialsByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getmultipropertygroupbyid", (void**)&(pWrapperTable->m_Model_GetMultiPropertyGroupByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetMultiPropertyGroupByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getmeshobjectbyid", (void**)&(pWrapperTable->m_Model_GetMeshObjectByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetMeshObjectByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcomponentsobjectbyid", (void**)&(pWrapperTable->m_Model_GetComponentsObjectByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetComponentsObjectByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcolorgroupbyid", (void**)&(pWrapperTable->m_Model_GetColorGroupByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetColorGroupByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getslicestackbyid", (void**)&(pWrapperTable->m_Model_GetSliceStackByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetSliceStackByID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getbuilduuid", (void**)&(pWrapperTable->m_Model_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetBuildUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_setbuilduuid", (void**)&(pWrapperTable->m_Model_SetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_SetBuildUUID == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getbuilditems", (void**)&(pWrapperTable->m_Model_GetBuildItems));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetBuildItems == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getoutbox", (void**)&(pWrapperTable->m_Model_GetOutbox));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetOutbox == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getresources", (void**)&(pWrapperTable->m_Model_GetResources));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetResources == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getobjects", (void**)&(pWrapperTable->m_Model_GetObjects));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetObjects == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getmeshobjects", (void**)&(pWrapperTable->m_Model_GetMeshObjects));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetMeshObjects == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcomponentsobjects", (void**)&(pWrapperTable->m_Model_GetComponentsObjects));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetComponentsObjects == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_gettexture2ds", (void**)&(pWrapperTable->m_Model_GetTexture2Ds));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetTexture2Ds == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getbasematerialgroups", (void**)&(pWrapperTable->m_Model_GetBaseMaterialGroups));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetBaseMaterialGroups == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcolorgroups", (void**)&(pWrapperTable->m_Model_GetColorGroups));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetColorGroups == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_gettexture2dgroups", (void**)&(pWrapperTable->m_Model_GetTexture2DGroups));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetTexture2DGroups == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getcompositematerials", (void**)&(pWrapperTable->m_Model_GetCompositeMaterials));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetCompositeMaterials == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getmultipropertygroups", (void**)&(pWrapperTable->m_Model_GetMultiPropertyGroups));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetMultiPropertyGroups == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_gettoolpaths", (void**)&(pWrapperTable->m_Model_GetToolpaths));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetToolpaths == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getslicestacks", (void**)&(pWrapperTable->m_Model_GetSliceStacks));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetSliceStacks == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_mergetomodel", (void**)&(pWrapperTable->m_Model_MergeToModel));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_MergeToModel == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addmeshobject", (void**)&(pWrapperTable->m_Model_AddMeshObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddMeshObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addcomponentsobject", (void**)&(pWrapperTable->m_Model_AddComponentsObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddComponentsObject == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addslicestack", (void**)&(pWrapperTable->m_Model_AddSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddSliceStack == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addtexture2dfromattachment", (void**)&(pWrapperTable->m_Model_AddTexture2DFromAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddTexture2DFromAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addbasematerialgroup", (void**)&(pWrapperTable->m_Model_AddBaseMaterialGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddBaseMaterialGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addcolorgroup", (void**)&(pWrapperTable->m_Model_AddColorGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddColorGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addtexture2dgroup", (void**)&(pWrapperTable->m_Model_AddTexture2DGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddTexture2DGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addcompositematerials", (void**)&(pWrapperTable->m_Model_AddCompositeMaterials));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddCompositeMaterials == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addmultipropertygroup", (void**)&(pWrapperTable->m_Model_AddMultiPropertyGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddMultiPropertyGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addbuilditem", (void**)&(pWrapperTable->m_Model_AddBuildItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddBuildItem == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_removebuilditem", (void**)&(pWrapperTable->m_Model_RemoveBuildItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_RemoveBuildItem == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addtoolpath", (void**)&(pWrapperTable->m_Model_AddToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddToolpath == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getmetadatagroup", (void**)&(pWrapperTable->m_Model_GetMetaDataGroup));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetMetaDataGroup == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addattachment", (void**)&(pWrapperTable->m_Model_AddAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_removeattachment", (void**)&(pWrapperTable->m_Model_RemoveAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_RemoveAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getattachment", (void**)&(pWrapperTable->m_Model_GetAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_findattachment", (void**)&(pWrapperTable->m_Model_FindAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_FindAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getattachmentcount", (void**)&(pWrapperTable->m_Model_GetAttachmentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetAttachmentCount == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_haspackagethumbnailattachment", (void**)&(pWrapperTable->m_Model_HasPackageThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_HasPackageThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_createpackagethumbnailattachment", (void**)&(pWrapperTable->m_Model_CreatePackageThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_CreatePackageThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getpackagethumbnailattachment", (void**)&(pWrapperTable->m_Model_GetPackageThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetPackageThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_removepackagethumbnailattachment", (void**)&(pWrapperTable->m_Model_RemovePackageThumbnailAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_RemovePackageThumbnailAttachment == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_addcustomcontenttype", (void**)&(pWrapperTable->m_Model_AddCustomContentType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_AddCustomContentType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_removecustomcontenttype", (void**)&(pWrapperTable->m_Model_RemoveCustomContentType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_RemoveCustomContentType == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_setrandomnumbercallback", (void**)&(pWrapperTable->m_Model_SetRandomNumberCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_SetRandomNumberCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_getkeystore", (void**)&(pWrapperTable->m_Model_GetKeyStore));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_GetKeyStore == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_createpersistentsourcefromfile", (void**)&(pWrapperTable->m_Model_CreatePersistentSourceFromFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_CreatePersistentSourceFromFile == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_createpersistentsourcefrombuffer", (void**)&(pWrapperTable->m_Model_CreatePersistentSourceFromBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_CreatePersistentSourceFromBuffer == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_model_createpersistentsourcefromcallback", (void**)&(pWrapperTable->m_Model_CreatePersistentSourceFromCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Model_CreatePersistentSourceFromCallback == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getlibraryversion", (void**)&(pWrapperTable->m_GetLibraryVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLibraryVersion == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getprereleaseinformation", (void**)&(pWrapperTable->m_GetPrereleaseInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetPrereleaseInformation == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getbuildinformation", (void**)&(pWrapperTable->m_GetBuildInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetBuildInformation == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getspecificationversion", (void**)&(pWrapperTable->m_GetSpecificationVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSpecificationVersion == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_createmodel", (void**)&(pWrapperTable->m_CreateModel));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateModel == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_release", (void**)&(pWrapperTable->m_Release));
		if ( (eLookupError != 0) || (pWrapperTable->m_Release == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_acquire", (void**)&(pWrapperTable->m_Acquire));
		if ( (eLookupError != 0) || (pWrapperTable->m_Acquire == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_setjournal", (void**)&(pWrapperTable->m_SetJournal));
		if ( (eLookupError != 0) || (pWrapperTable->m_SetJournal == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_retrieveprogressmessage", (void**)&(pWrapperTable->m_RetrieveProgressMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_RetrieveProgressMessage == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_rgbatocolor", (void**)&(pWrapperTable->m_RGBAToColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_RGBAToColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_floatrgbatocolor", (void**)&(pWrapperTable->m_FloatRGBAToColor));
		if ( (eLookupError != 0) || (pWrapperTable->m_FloatRGBAToColor == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colortorgba", (void**)&(pWrapperTable->m_ColorToRGBA));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorToRGBA == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_colortofloatrgba", (void**)&(pWrapperTable->m_ColorToFloatRGBA));
		if ( (eLookupError != 0) || (pWrapperTable->m_ColorToFloatRGBA == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getidentitytransform", (void**)&(pWrapperTable->m_GetIdentityTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetIdentityTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getuniformscaletransform", (void**)&(pWrapperTable->m_GetUniformScaleTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetUniformScaleTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_getscaletransform", (void**)&(pWrapperTable->m_GetScaleTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetScaleTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("lib3mf_gettranslationtransform", (void**)&(pWrapperTable->m_GetTranslationTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetTranslationTransform == nullptr) )
			return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIB3MF_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	* CBase::ClassTypeId - Get Class Type Id
	* @return Class type as a 64 bits integer
	*/
	Lib3MF_uint64 CBase::ClassTypeId()
	{
		Lib3MF_uint64 resultClassTypeId = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Base_ClassTypeId(m_pHandle, &resultClassTypeId));
		
		return resultClassTypeId;
	}
	
	/**
	 * Method definitions for class CBinaryStream
	 */
	
	/**
	* CBinaryStream::GetBinaryPath - Retrieves an binary streams package path for the binary data.
	* @return binary streams package binary path.
	*/
	std::string CBinaryStream::GetBinaryPath()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetBinaryPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetBinaryPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CBinaryStream::GetIndexPath - Retrieves an binary streams package path for the index data.
	* @return binary streams package index path.
	*/
	std::string CBinaryStream::GetIndexPath()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetIndexPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetIndexPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CBinaryStream::GetUUID - Retrieves an binary streams uuid.
	* @return binary streams uuid
	*/
	std::string CBinaryStream::GetUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBinaryStream::DisableDiscretizedArrayCompression - Sets the float compression mode to raw. All subsequent writes will adhere to this mode.
	*/
	void CBinaryStream::DisableDiscretizedArrayCompression()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_DisableDiscretizedArrayCompression(m_pHandle));
	}
	
	/**
	* CBinaryStream::EnableDiscretizedArrayCompression - Sets the compression mode to a quantized array. All subsequent writes will adhere to this mode.
	* @param[in] dUnits - Unit factor to use for quantization.
	* @param[in] ePredictionType - Prediction type to use for arrays.
	*/
	void CBinaryStream::EnableDiscretizedArrayCompression(const Lib3MF_double dUnits, const eBinaryStreamPredictionType ePredictionType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_EnableDiscretizedArrayCompression(m_pHandle, dUnits, ePredictionType));
	}
	
	/**
	* CBinaryStream::EnableLZMA - Enables LZMA mode.
	* @param[in] nLZMALevel - LZMA Level (0-9)
	*/
	void CBinaryStream::EnableLZMA(const Lib3MF_uint32 nLZMALevel)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_EnableLZMA(m_pHandle, nLZMALevel));
	}
	
	/**
	* CBinaryStream::DisableLZMA - Disables LZMA mode.
	*/
	void CBinaryStream::DisableLZMA()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BinaryStream_DisableLZMA(m_pHandle));
	}
	
	/**
	 * Method definitions for class CWriter
	 */
	
	/**
	* CWriter::WriteToFile - Writes out the model as file. The file type is specified by the Model Writer class.
	* @param[in] sFilename - Filename to write into
	*/
	void CWriter::WriteToFile(const std::string & sFilename)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_WriteToFile(m_pHandle, sFilename.c_str()));
	}
	
	/**
	* CWriter::GetStreamSize - Retrieves the size of the full 3MF file stream.
	* @return the stream size
	*/
	Lib3MF_uint64 CWriter::GetStreamSize()
	{
		Lib3MF_uint64 resultStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetStreamSize(m_pHandle, &resultStreamSize));
		
		return resultStreamSize;
	}
	
	/**
	* CWriter::WriteToBuffer - Writes out the 3MF file into a memory buffer
	* @param[out] BufferBuffer - buffer to write into
	*/
	void CWriter::WriteToBuffer(std::vector<Lib3MF_uint8> & BufferBuffer)
	{
		Lib3MF_uint64 elementsNeededBuffer = 0;
		Lib3MF_uint64 elementsWrittenBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_WriteToBuffer(m_pHandle, 0, &elementsNeededBuffer, nullptr));
		BufferBuffer.resize((size_t) elementsNeededBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_WriteToBuffer(m_pHandle, elementsNeededBuffer, &elementsWrittenBuffer, BufferBuffer.data()));
	}
	
	/**
	* CWriter::WriteToCallback - Writes out the model and passes the data to a provided callback function. The file type is specified by the Model Writer class.
	* @param[in] pTheWriteCallback - Callback to call for writing a data chunk
	* @param[in] pTheSeekCallback - Callback to call for seeking in the stream
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CWriter::WriteToCallback(const WriteCallback pTheWriteCallback, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_WriteToCallback(m_pHandle, pTheWriteCallback, pTheSeekCallback, pUserData));
	}
	
	/**
	* CWriter::SetProgressCallback - Set the progress callback for calls to this writer
	* @param[in] pProgressCallback - pointer to the callback function.
	* @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback.
	*/
	void CWriter::SetProgressCallback(const ProgressCallback pProgressCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_SetProgressCallback(m_pHandle, pProgressCallback, pUserData));
	}
	
	/**
	* CWriter::GetDecimalPrecision - Returns the number of digits after the decimal point to be written in each vertex coordinate-value.
	* @return The number of digits to be written in each vertex coordinate-value after the decimal point.
	*/
	Lib3MF_uint32 CWriter::GetDecimalPrecision()
	{
		Lib3MF_uint32 resultDecimalPrecision = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetDecimalPrecision(m_pHandle, &resultDecimalPrecision));
		
		return resultDecimalPrecision;
	}
	
	/**
	* CWriter::SetDecimalPrecision - Sets the number of digits after the decimal point to be written in each vertex coordinate-value.
	* @param[in] nDecimalPrecision - The number of digits to be written in each vertex coordinate-value after the decimal point.
	*/
	void CWriter::SetDecimalPrecision(const Lib3MF_uint32 nDecimalPrecision)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_SetDecimalPrecision(m_pHandle, nDecimalPrecision));
	}
	
	/**
	* CWriter::SetStrictModeActive - Activates (deactivates) the strict mode of the reader.
	* @param[in] bStrictModeActive - flag whether strict mode is active or not.
	*/
	void CWriter::SetStrictModeActive(const bool bStrictModeActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_SetStrictModeActive(m_pHandle, bStrictModeActive));
	}
	
	/**
	* CWriter::GetStrictModeActive - Queries whether the strict mode of the reader is active or not
	* @return returns flag whether strict mode is active or not.
	*/
	bool CWriter::GetStrictModeActive()
	{
		bool resultStrictModeActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetStrictModeActive(m_pHandle, &resultStrictModeActive));
		
		return resultStrictModeActive;
	}
	
	/**
	* CWriter::GetWarning - Returns Warning and Error Information of the read process
	* @param[in] nIndex - Index of the Warning. Valid values are 0 to WarningCount - 1
	* @param[out] nErrorCode - filled with the error code of the warning
	* @return the message of the warning
	*/
	std::string CWriter::GetWarning(const Lib3MF_uint32 nIndex, Lib3MF_uint32 & nErrorCode)
	{
		Lib3MF_uint32 bytesNeededWarning = 0;
		Lib3MF_uint32 bytesWrittenWarning = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetWarning(m_pHandle, nIndex, &nErrorCode, 0, &bytesNeededWarning, nullptr));
		std::vector<char> bufferWarning(bytesNeededWarning);
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetWarning(m_pHandle, nIndex, &nErrorCode, bytesNeededWarning, &bytesWrittenWarning, &bufferWarning[0]));
		
		return std::string(&bufferWarning[0]);
	}
	
	/**
	* CWriter::GetWarningCount - Returns Warning and Error Count of the read process
	* @return filled with the count of the occurred warnings.
	*/
	Lib3MF_uint32 CWriter::GetWarningCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_GetWarningCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CWriter::AddKeyWrappingCallback - Registers a callback to deal with data key encryption/decryption from keystore
	* @param[in] sConsumerID - The ConsumerID to register for
	* @param[in] pTheCallback - The callback to be callede for wrapping and encryption key
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CWriter::AddKeyWrappingCallback(const std::string & sConsumerID, const KeyWrappingCallback pTheCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_AddKeyWrappingCallback(m_pHandle, sConsumerID.c_str(), pTheCallback, pUserData));
	}
	
	/**
	* CWriter::SetContentEncryptionCallback - Registers a callback to deal with encryption of content
	* @param[in] pTheCallback - The callback used to encrypt content
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CWriter::SetContentEncryptionCallback(const ContentEncryptionCallback pTheCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_SetContentEncryptionCallback(m_pHandle, pTheCallback, pUserData));
	}
	
	/**
	* CWriter::CreateBinaryStream - Creates a binary stream object. Only applicable for 3MF Writers.
	* @param[in] sIndexPath - Package path to write the index into
	* @param[in] sBinaryPath - Package path to write raw binary data into
	* @return Returns a package path.
	*/
	PBinaryStream CWriter::CreateBinaryStream(const std::string & sIndexPath, const std::string & sBinaryPath)
	{
		Lib3MFHandle hBinaryStream = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_CreateBinaryStream(m_pHandle, sIndexPath.c_str(), sBinaryPath.c_str(), &hBinaryStream));
		
		if (!hBinaryStream) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBinaryStream>(dynamic_cast<CBinaryStream*>(m_pWrapper->polymorphicFactory(hBinaryStream)));
	}
	
	/**
	* CWriter::AssignBinaryStream - Sets a binary stream for an object. Currently supported objects are Meshes and Toolpath layers.
	* @param[in] pInstance - Object instance to assign Binary stream to.
	* @param[in] pBinaryStream - Binary stream object to use for this layer.
	*/
	void CWriter::AssignBinaryStream(classParam<CBase> pInstance, classParam<CBinaryStream> pBinaryStream)
	{
		Lib3MFHandle hInstance = pInstance.GetHandle();
		Lib3MFHandle hBinaryStream = pBinaryStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_AssignBinaryStream(m_pHandle, hInstance, hBinaryStream));
	}
	
	/**
	* CWriter::RegisterCustomNamespace - Registers a custom 3MF Namespace. Fails if Prefix is already registered.
	* @param[in] sPrefix - Prefix to be used. MUST NOT be empty. MUST be alphanumeric, not starting with a number
	* @param[in] sNameSpace - Namespace to be used. MUST NOT be empty. MUST be alphanumeric, not starting with a number
	*/
	void CWriter::RegisterCustomNamespace(const std::string & sPrefix, const std::string & sNameSpace)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Writer_RegisterCustomNamespace(m_pHandle, sPrefix.c_str(), sNameSpace.c_str()));
	}
	
	/**
	 * Method definitions for class CPersistentReaderSource
	 */
	
	/**
	* CPersistentReaderSource::GetSourceType - Retrieves the type of source data.
	* @return Reader Source Type
	*/
	ePersistentReaderSourceType CPersistentReaderSource::GetSourceType()
	{
		ePersistentReaderSourceType resultSourceType = (ePersistentReaderSourceType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistentReaderSource_GetSourceType(m_pHandle, &resultSourceType));
		
		return resultSourceType;
	}
	
	/**
	* CPersistentReaderSource::InvalidateSourceData - Invalidates the reader source. Every subsequent read on this data will fail.
	*/
	void CPersistentReaderSource::InvalidateSourceData()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistentReaderSource_InvalidateSourceData(m_pHandle));
	}
	
	/**
	* CPersistentReaderSource::SourceDataIsValid - Checks if the source data is valid. Any read on an invalid source object will fail.
	* @return The source data is valid.
	*/
	bool CPersistentReaderSource::SourceDataIsValid()
	{
		bool resultDataIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistentReaderSource_SourceDataIsValid(m_pHandle, &resultDataIsValid));
		
		return resultDataIsValid;
	}
	
	/**
	 * Method definitions for class CReader
	 */
	
	/**
	* CReader::ReadFromPersistentSource - Reads a model from a persistent source object. The object will be referenced until the Model is destroyed or cleared.
	* @param[in] pSource - Source object to read from
	*/
	void CReader::ReadFromPersistentSource(classParam<CPersistentReaderSource> pSource)
	{
		Lib3MFHandle hSource = pSource.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_ReadFromPersistentSource(m_pHandle, hSource));
	}
	
	/**
	* CReader::ReadFromFile - Reads a model from a file. The file type is specified by the Model Reader class
	* @param[in] sFilename - Filename to read from
	*/
	void CReader::ReadFromFile(const std::string & sFilename)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_ReadFromFile(m_pHandle, sFilename.c_str()));
	}
	
	/**
	* CReader::ReadFromBuffer - Reads a model from a memory buffer.
	* @param[in] BufferBuffer - Buffer to read from
	*/
	void CReader::ReadFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_ReadFromBuffer(m_pHandle, (Lib3MF_uint64)BufferBuffer.size(), BufferBuffer.data()));
	}
	
	/**
	* CReader::ReadFromCallback - Reads a model and from the data provided by a callback function
	* @param[in] pTheReadCallback - Callback to call for reading a data chunk
	* @param[in] nStreamSize - number of bytes the callback returns
	* @param[in] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CReader::ReadFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_ReadFromCallback(m_pHandle, pTheReadCallback, nStreamSize, pTheSeekCallback, pUserData));
	}
	
	/**
	* CReader::SetProgressCallback - Set the progress callback for calls to this writer
	* @param[in] pProgressCallback - pointer to the callback function.
	* @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback.
	*/
	void CReader::SetProgressCallback(const ProgressCallback pProgressCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_SetProgressCallback(m_pHandle, pProgressCallback, pUserData));
	}
	
	/**
	* CReader::AddRelationToRead - Adds a relationship type which shall be read as attachment in memory while loading
	* @param[in] sRelationShipType - String of the relationship type
	*/
	void CReader::AddRelationToRead(const std::string & sRelationShipType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_AddRelationToRead(m_pHandle, sRelationShipType.c_str()));
	}
	
	/**
	* CReader::RemoveRelationToRead - Removes a relationship type which shall be read as attachment in memory while loading
	* @param[in] sRelationShipType - String of the relationship type
	*/
	void CReader::RemoveRelationToRead(const std::string & sRelationShipType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_RemoveRelationToRead(m_pHandle, sRelationShipType.c_str()));
	}
	
	/**
	* CReader::SetStrictModeActive - Activates (deactivates) the strict mode of the reader.
	* @param[in] bStrictModeActive - flag whether strict mode is active or not.
	*/
	void CReader::SetStrictModeActive(const bool bStrictModeActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_SetStrictModeActive(m_pHandle, bStrictModeActive));
	}
	
	/**
	* CReader::GetStrictModeActive - Queries whether the strict mode of the reader is active or not
	* @return returns flag whether strict mode is active or not.
	*/
	bool CReader::GetStrictModeActive()
	{
		bool resultStrictModeActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_GetStrictModeActive(m_pHandle, &resultStrictModeActive));
		
		return resultStrictModeActive;
	}
	
	/**
	* CReader::GetWarning - Returns Warning and Error Information of the read process
	* @param[in] nIndex - Index of the Warning. Valid values are 0 to WarningCount - 1
	* @param[out] nErrorCode - filled with the error code of the warning
	* @return the message of the warning
	*/
	std::string CReader::GetWarning(const Lib3MF_uint32 nIndex, Lib3MF_uint32 & nErrorCode)
	{
		Lib3MF_uint32 bytesNeededWarning = 0;
		Lib3MF_uint32 bytesWrittenWarning = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_GetWarning(m_pHandle, nIndex, &nErrorCode, 0, &bytesNeededWarning, nullptr));
		std::vector<char> bufferWarning(bytesNeededWarning);
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_GetWarning(m_pHandle, nIndex, &nErrorCode, bytesNeededWarning, &bytesWrittenWarning, &bufferWarning[0]));
		
		return std::string(&bufferWarning[0]);
	}
	
	/**
	* CReader::GetWarningCount - Returns Warning and Error Count of the read process
	* @return filled with the count of the occurred warnings.
	*/
	Lib3MF_uint32 CReader::GetWarningCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_GetWarningCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CReader::AddKeyWrappingCallback - Registers a callback to deal with key wrapping mechanism from keystore
	* @param[in] sConsumerID - The ConsumerID to register for
	* @param[in] pTheCallback - The callback used to decrypt data key
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CReader::AddKeyWrappingCallback(const std::string & sConsumerID, const KeyWrappingCallback pTheCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_AddKeyWrappingCallback(m_pHandle, sConsumerID.c_str(), pTheCallback, pUserData));
	}
	
	/**
	* CReader::SetContentEncryptionCallback - Registers a callback to deal with encryption of content
	* @param[in] pTheCallback - The callback used to encrypt content
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CReader::SetContentEncryptionCallback(const ContentEncryptionCallback pTheCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Reader_SetContentEncryptionCallback(m_pHandle, pTheCallback, pUserData));
	}
	
	/**
	 * Method definitions for class CPackagePart
	 */
	
	/**
	* CPackagePart::GetPath - Returns the absolute path of this PackagePart.
	* @return Returns the absolute path of this PackagePart
	*/
	std::string CPackagePart::GetPath()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PackagePart_GetPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_PackagePart_GetPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CPackagePart::SetPath - Sets the absolute path of this PackagePart.
	* @param[in] sPath - Sets the absolute path of this PackagePart.
	*/
	void CPackagePart::SetPath(const std::string & sPath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PackagePart_SetPath(m_pHandle, sPath.c_str()));
	}
	
	/**
	 * Method definitions for class CResource
	 */
	
	/**
	* CResource::GetResourceID - Retrieves the unique id of this resource within a package. This function will be removed in a later release in favor of GetUniqueResourceID
	* @return Retrieves the unique id of this resource within a package.
	*/
	Lib3MF_uint32 CResource::GetResourceID()
	{
		Lib3MF_uint32 resultUniqueResourceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Resource_GetResourceID(m_pHandle, &resultUniqueResourceID));
		
		return resultUniqueResourceID;
	}
	
	/**
	* CResource::GetUniqueResourceID - Retrieves the unique id of this resource within a package.
	* @return Retrieves the unique id of this resource within a package.
	*/
	Lib3MF_uint32 CResource::GetUniqueResourceID()
	{
		Lib3MF_uint32 resultUniqueResourceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Resource_GetUniqueResourceID(m_pHandle, &resultUniqueResourceID));
		
		return resultUniqueResourceID;
	}
	
	/**
	* CResource::PackagePart - Returns the PackagePart within which this resource resides
	* @return the PackagePart within which this resource resides.
	*/
	PPackagePart CResource::PackagePart()
	{
		Lib3MFHandle hPackagePart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Resource_PackagePart(m_pHandle, &hPackagePart));
		
		if (!hPackagePart) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPackagePart>(dynamic_cast<CPackagePart*>(m_pWrapper->polymorphicFactory(hPackagePart)));
	}
	
	/**
	* CResource::SetPackagePart - Sets the new PackagePart within which this resource resides
	* @param[in] pPackagePart - the new PackagePart within which this resource resides.
	*/
	void CResource::SetPackagePart(classParam<CPackagePart> pPackagePart)
	{
		Lib3MFHandle hPackagePart = pPackagePart.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Resource_SetPackagePart(m_pHandle, hPackagePart));
	}
	
	/**
	* CResource::GetModelResourceID - Retrieves the id of this resource within a model.
	* @return Retrieves the id of this resource within a model.
	*/
	Lib3MF_uint32 CResource::GetModelResourceID()
	{
		Lib3MF_uint32 resultModelResourceId = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Resource_GetModelResourceID(m_pHandle, &resultModelResourceId));
		
		return resultModelResourceId;
	}
	
	/**
	 * Method definitions for class CResourceIterator
	 */
	
	/**
	* CResourceIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CResourceIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceIterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CResourceIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CResourceIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceIterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CResourceIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PResource CResourceIterator::GetCurrent()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceIterator_GetCurrent(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResource>(dynamic_cast<CResource*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	* CResourceIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PResourceIterator CResourceIterator::Clone()
	{
		Lib3MFHandle hOutResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceIterator_Clone(m_pHandle, &hOutResourceIterator));
		
		if (!hOutResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceIterator>(dynamic_cast<CResourceIterator*>(m_pWrapper->polymorphicFactory(hOutResourceIterator)));
	}
	
	/**
	* CResourceIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of resoucres the iterator captures.
	*/
	Lib3MF_uint64 CResourceIterator::Count()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceIterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CCustomXMLAttribute
	 */
	
	/**
	* CCustomXMLAttribute::GetName - Retrieves name of the attribute.
	* @return returns the name of the attribute.
	*/
	std::string CCustomXMLAttribute::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CCustomXMLAttribute::GetValue - Retrieves value of the attribute as string.
	* @return returns the value of the attribute.
	*/
	std::string CCustomXMLAttribute::GetValue()
	{
		Lib3MF_uint32 bytesNeededValue = 0;
		Lib3MF_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetValue(m_pHandle, 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetValue(m_pHandle, bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CCustomXMLAttribute::IsValidInteger - Checks if the value is a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns if the value is a valid integer.
	*/
	bool CCustomXMLAttribute::IsValidInteger(const Lib3MF_int64 nMinValue, const Lib3MF_int64 nMaxValue)
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_IsValidInteger(m_pHandle, nMinValue, nMaxValue, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CCustomXMLAttribute::GetIntegerValue - Returns the value as integer. Fails if the value is not a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns the value.
	*/
	Lib3MF_int64 CCustomXMLAttribute::GetIntegerValue(const Lib3MF_int64 nMinValue, const Lib3MF_int64 nMaxValue)
	{
		Lib3MF_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetIntegerValue(m_pHandle, nMinValue, nMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CCustomXMLAttribute::IsValidDouble - Checks if the value is a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns if the value is a valid double.
	*/
	bool CCustomXMLAttribute::IsValidDouble(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue)
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_IsValidDouble(m_pHandle, dMinValue, dMaxValue, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CCustomXMLAttribute::GetDoubleValue - Returns the value as double. Fails if the value is not a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns the value .
	*/
	Lib3MF_double CCustomXMLAttribute::GetDoubleValue(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue)
	{
		Lib3MF_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetDoubleValue(m_pHandle, dMinValue, dMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CCustomXMLAttribute::IsValidBool - Checks if the value is a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns if the value is a valid bool.
	*/
	bool CCustomXMLAttribute::IsValidBool()
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_IsValidBool(m_pHandle, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CCustomXMLAttribute::GetBoolValue - Returns the value as bool. Fails if the value is not a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns the value .
	*/
	bool CCustomXMLAttribute::GetBoolValue(const Lib3MF_double dMinValue, const Lib3MF_double dMaxValue)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_GetBoolValue(m_pHandle, dMinValue, dMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CCustomXMLAttribute::SetValue - Sets the value of the attribute as string.
	* @param[in] sValue - new value of the attribute.
	*/
	void CCustomXMLAttribute::SetValue(const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_SetValue(m_pHandle, sValue.c_str()));
	}
	
	/**
	* CCustomXMLAttribute::SetIntegerValue - Sets the value of the attribute as integer.
	* @param[in] nValue - new value of the attribute.
	*/
	void CCustomXMLAttribute::SetIntegerValue(const Lib3MF_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_SetIntegerValue(m_pHandle, nValue));
	}
	
	/**
	* CCustomXMLAttribute::SetDoubleValue - Sets the value of the attribute as double.
	* @param[in] dValue - new value of the attribute.
	*/
	void CCustomXMLAttribute::SetDoubleValue(const Lib3MF_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_SetDoubleValue(m_pHandle, dValue));
	}
	
	/**
	* CCustomXMLAttribute::SetBoolValue - Sets the value of the attribute as bool.
	* @param[in] bValue - new value of the attribute.
	*/
	void CCustomXMLAttribute::SetBoolValue(const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_SetBoolValue(m_pHandle, bValue));
	}
	
	/**
	* CCustomXMLAttribute::Remove - Removes the attribute from its parent node. All subsequent calls to the class will fail.
	*/
	void CCustomXMLAttribute::Remove()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLAttribute_Remove(m_pHandle));
	}
	
	/**
	 * Method definitions for class CCustomXMLNode
	 */
	
	/**
	* CCustomXMLNode::GetName - Retrieves name of the node.
	* @return returns the name of the node.
	*/
	std::string CCustomXMLNode::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CCustomXMLNode::GetNameSpace - Retrieves namespace of the node.
	* @return returns the namespace of the node.
	*/
	std::string CCustomXMLNode::GetNameSpace()
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetNameSpace(m_pHandle, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetNameSpace(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CCustomXMLNode::GetAttributeCount - Returns number of attributes.
	* @return returns the number of attributes.
	*/
	Lib3MF_uint64 CCustomXMLNode::GetAttributeCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetAttributeCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CCustomXMLNode::GetAttribute - Returns attribute instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the attribute to return (0-based).
	* @return XML Document attribute.
	*/
	PCustomXMLAttribute CCustomXMLNode::GetAttribute(const Lib3MF_uint64 nIndex)
	{
		Lib3MFHandle hAttributeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetAttribute(m_pHandle, nIndex, &hAttributeInstance));
		
		if (!hAttributeInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLAttribute>(dynamic_cast<CCustomXMLAttribute*>(m_pWrapper->polymorphicFactory(hAttributeInstance)));
	}
	
	/**
	* CCustomXMLNode::HasAttribute - Returns if attribute of a specific name exists.
	* @param[in] sName - Name of the attribute.
	* @return Returns if the attribute exists.
	*/
	bool CCustomXMLNode::HasAttribute(const std::string & sName)
	{
		bool resultAttributeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_HasAttribute(m_pHandle, sName.c_str(), &resultAttributeExists));
		
		return resultAttributeExists;
	}
	
	/**
	* CCustomXMLNode::FindAttribute - Returns attribute instance of a specific name. 
	* @param[in] sName - Name of the attribute.
	* @param[in] bMustExist - If true, the call fails if attribute does not exist. If falls, the call will return null if the attribute does not exist.
	* @return XML Document attribute.
	*/
	PCustomXMLAttribute CCustomXMLNode::FindAttribute(const std::string & sName, const bool bMustExist)
	{
		Lib3MFHandle hAttributeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_FindAttribute(m_pHandle, sName.c_str(), bMustExist, &hAttributeInstance));
		
		if (hAttributeInstance) {
			return std::shared_ptr<CCustomXMLAttribute>(dynamic_cast<CCustomXMLAttribute*>(m_pWrapper->polymorphicFactory(hAttributeInstance)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CCustomXMLNode::RemoveAttribute - Removes the attribute with a specific name. Does nothing if attribute does not exist.
	* @param[in] sName - Name of the attribute.
	* @return Returns true if an attribute was removed.
	*/
	bool CCustomXMLNode::RemoveAttribute(const std::string & sName)
	{
		bool resultAttributeRemoved = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_RemoveAttribute(m_pHandle, sName.c_str(), &resultAttributeRemoved));
		
		return resultAttributeRemoved;
	}
	
	/**
	* CCustomXMLNode::RemoveAttributeByIndex - Removes the attribute with a specific index. Fails if index is invalid
	* @param[in] nIndex - Index of the attribute to remove (0-based).
	* @return Returns true if an attribute was removed.
	*/
	bool CCustomXMLNode::RemoveAttributeByIndex(const Lib3MF_uint64 nIndex)
	{
		bool resultAttributeRemoved = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_RemoveAttributeByIndex(m_pHandle, nIndex, &resultAttributeRemoved));
		
		return resultAttributeRemoved;
	}
	
	/**
	* CCustomXMLNode::AddAttribute - Adds an attribute with a specific name and string value. Fails if attribute already exists.
	* @param[in] sName - Name of the attribute.
	* @param[in] sValue - Value of the attribute.
	*/
	void CCustomXMLNode::AddAttribute(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_AddAttribute(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CCustomXMLNode::AddIntegerAttribute - Adds an attribute with a specific name and integer value. Fails if attribute already exists.
	* @param[in] sName - Name of the attribute.
	* @param[in] nValue - Value of the attribute.
	*/
	void CCustomXMLNode::AddIntegerAttribute(const std::string & sName, const Lib3MF_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_AddIntegerAttribute(m_pHandle, sName.c_str(), nValue));
	}
	
	/**
	* CCustomXMLNode::AddDoubleAttribute - Adds an attribute with a specific name and double value. Fails if attribute already exists.
	* @param[in] sName - Name of the attribute.
	* @param[in] dValue - Value of the attribute.
	*/
	void CCustomXMLNode::AddDoubleAttribute(const std::string & sName, const Lib3MF_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_AddDoubleAttribute(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CCustomXMLNode::AddBoolAttribute - Adds an attribute with a specific name and bool value. Fails if attribute already exists.
	* @param[in] sName - Name of the attribute.
	* @param[in] bValue - Value of the attribute.
	*/
	void CCustomXMLNode::AddBoolAttribute(const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_AddBoolAttribute(m_pHandle, sName.c_str(), bValue));
	}
	
	/**
	* CCustomXMLNode::GetChildren - Returns all the child nodes of the XML Node.
	* @return returns the list of child nodes.
	*/
	PCustomXMLNodes CCustomXMLNode::GetChildren()
	{
		Lib3MFHandle hChildNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetChildren(m_pHandle, &hChildNodes));
		
		if (!hChildNodes) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNodes>(dynamic_cast<CCustomXMLNodes*>(m_pWrapper->polymorphicFactory(hChildNodes)));
	}
	
	/**
	* CCustomXMLNode::CountChildrenByName - Returns how many children of the XML Node have a specific name.
	* @param[in] sName - Name of the node.
	* @return returns the number children with the specified name.
	*/
	Lib3MF_uint64 CCustomXMLNode::CountChildrenByName(const std::string & sName)
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_CountChildrenByName(m_pHandle, sName.c_str(), &resultCount));
		
		return resultCount;
	}
	
	/**
	* CCustomXMLNode::GetChildrenByName - Returns all the child nodes of the XML Node with a specific name.
	* @param[in] sName - Name of the child.
	* @return returns the list of child nodes.
	*/
	PCustomXMLNodes CCustomXMLNode::GetChildrenByName(const std::string & sName)
	{
		Lib3MFHandle hChildNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_GetChildrenByName(m_pHandle, sName.c_str(), &hChildNodes));
		
		if (!hChildNodes) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNodes>(dynamic_cast<CCustomXMLNodes*>(m_pWrapper->polymorphicFactory(hChildNodes)));
	}
	
	/**
	* CCustomXMLNode::HasChild - Returns if a child with a specific name exist.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists.
	*/
	bool CCustomXMLNode::HasChild(const std::string & sName)
	{
		bool resultChildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_HasChild(m_pHandle, sName.c_str(), &resultChildExists));
		
		return resultChildExists;
	}
	
	/**
	* CCustomXMLNode::HasUniqueChild - Returns if a child with a specific name exist once and only once.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists once and only once.
	*/
	bool CCustomXMLNode::HasUniqueChild(const std::string & sName)
	{
		bool resultChildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_HasUniqueChild(m_pHandle, sName.c_str(), &resultChildExists));
		
		return resultChildExists;
	}
	
	/**
	* CCustomXMLNode::FindChild - Returns child with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sName - Name of the child.
	* @param[in] bMustExist - If true, the call fails if child does not exist. If falls, the call will return null if the child does not exist.
	* @return returns child instance or null.
	*/
	PCustomXMLNode CCustomXMLNode::FindChild(const std::string & sName, const bool bMustExist)
	{
		Lib3MFHandle hChildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_FindChild(m_pHandle, sName.c_str(), bMustExist, &hChildInstance));
		
		if (hChildInstance) {
			return std::shared_ptr<CCustomXMLNode>(dynamic_cast<CCustomXMLNode*>(m_pWrapper->polymorphicFactory(hChildInstance)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CCustomXMLNode::AddChild - Adds a new child with a specific name.
	* @param[in] sName - Name of the child.
	* @return returns child instance.
	*/
	PCustomXMLNode CCustomXMLNode::AddChild(const std::string & sName)
	{
		Lib3MFHandle hChildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_AddChild(m_pHandle, sName.c_str(), &hChildInstance));
		
		if (!hChildInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNode>(dynamic_cast<CCustomXMLNode*>(m_pWrapper->polymorphicFactory(hChildInstance)));
	}
	
	/**
	* CCustomXMLNode::RemoveChild - Removes a specific child. All subsequent calls to the child will fail after the call.
	* @param[in] pChildInstance - child instance to remove. Fails if given instance is not a child of the node.
	*/
	void CCustomXMLNode::RemoveChild(classParam<CCustomXMLNode> pChildInstance)
	{
		Lib3MFHandle hChildInstance = pChildInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_RemoveChild(m_pHandle, hChildInstance));
	}
	
	/**
	* CCustomXMLNode::RemoveChildrenWithName - Removes all children with a specific name. Does nothing if no child with the name exists. All subsequent calls to the deleted children will fail after the call.
	* @param[in] sName - Name of the children.
	* @return Returns how many children have been deleted.
	*/
	Lib3MF_uint64 CCustomXMLNode::RemoveChildrenWithName(const std::string & sName)
	{
		Lib3MF_uint64 resultNumberOfDeletedChildren = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_RemoveChildrenWithName(m_pHandle, sName.c_str(), &resultNumberOfDeletedChildren));
		
		return resultNumberOfDeletedChildren;
	}
	
	/**
	* CCustomXMLNode::Remove - Removes the node from its parent. The root node of the document can not be removed. Any subsequent call to the node fails after this.
	*/
	void CCustomXMLNode::Remove()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNode_Remove(m_pHandle));
	}
	
	/**
	 * Method definitions for class CCustomXMLNodes
	 */
	
	/**
	* CCustomXMLNodes::GetNodeCount - Returns number of nodes.
	* @return returns the number of nodes in the list.
	*/
	Lib3MF_uint64 CCustomXMLNodes::GetNodeCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_GetNodeCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CCustomXMLNodes::GetNode - Returns node instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the node to return (0-based).
	* @return XML Node node.
	*/
	PCustomXMLNode CCustomXMLNodes::GetNode(const Lib3MF_uint64 nIndex)
	{
		Lib3MFHandle hNodeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_GetNode(m_pHandle, nIndex, &hNodeInstance));
		
		if (!hNodeInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNode>(dynamic_cast<CCustomXMLNode*>(m_pWrapper->polymorphicFactory(hNodeInstance)));
	}
	
	/**
	* CCustomXMLNodes::CountNodesByName - Returns how many nodes of the XML Node have a specific name.
	* @param[in] sName - Name of the node.
	* @return returns the number of nodes with the specified name.
	*/
	Lib3MF_uint64 CCustomXMLNodes::CountNodesByName(const std::string & sName)
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_CountNodesByName(m_pHandle, sName.c_str(), &resultCount));
		
		return resultCount;
	}
	
	/**
	* CCustomXMLNodes::GetNodesByName - Returns all the nodes nodes of the XML Node with a specific name.
	* @param[in] sName - Name of the node.
	* @return returns the list of node nodes.
	*/
	PCustomXMLNodes CCustomXMLNodes::GetNodesByName(const std::string & sName)
	{
		Lib3MFHandle hNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_GetNodesByName(m_pHandle, sName.c_str(), &hNodes));
		
		if (!hNodes) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNodes>(dynamic_cast<CCustomXMLNodes*>(m_pWrapper->polymorphicFactory(hNodes)));
	}
	
	/**
	* CCustomXMLNodes::HasNode - Returns if a node with a specific name exist.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists.
	*/
	bool CCustomXMLNodes::HasNode(const std::string & sName)
	{
		bool resultNodeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_HasNode(m_pHandle, sName.c_str(), &resultNodeExists));
		
		return resultNodeExists;
	}
	
	/**
	* CCustomXMLNodes::HasUniqueNode - Returns if a node with a specific name exist once and only once.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists once and only once.
	*/
	bool CCustomXMLNodes::HasUniqueNode(const std::string & sName)
	{
		bool resultNodeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_HasUniqueNode(m_pHandle, sName.c_str(), &resultNodeExists));
		
		return resultNodeExists;
	}
	
	/**
	* CCustomXMLNodes::FindNode - Returns node with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sName - Name of the node.
	* @param[in] bMustExist - If true, the call fails if node does not exist. If falls, the call will return null if the node does not exist.
	* @return returns node instance.
	*/
	PCustomXMLNode CCustomXMLNodes::FindNode(const std::string & sName, const bool bMustExist)
	{
		Lib3MFHandle hNodeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomXMLNodes_FindNode(m_pHandle, sName.c_str(), bMustExist, &hNodeInstance));
		
		if (hNodeInstance) {
			return std::shared_ptr<CCustomXMLNode>(dynamic_cast<CCustomXMLNode*>(m_pWrapper->polymorphicFactory(hNodeInstance)));
		} else {
			return nullptr;
		}
	}
	
	/**
	 * Method definitions for class CCustomDOMTree
	 */
	
	/**
	* CCustomDOMTree::GetNameSpace - Returns the namespace identifier for the DOM Tree.
	* @return returns the namespace of the DOM Tree.
	*/
	std::string CCustomDOMTree::GetNameSpace()
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDOMTree_GetNameSpace(m_pHandle, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDOMTree_GetNameSpace(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CCustomDOMTree::GetRootNode - Returns root node of the tree.
	* @return Root node of the document.
	*/
	PCustomXMLNode CCustomDOMTree::GetRootNode()
	{
		Lib3MFHandle hRootNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDOMTree_GetRootNode(m_pHandle, &hRootNode));
		
		if (!hRootNode) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomXMLNode>(dynamic_cast<CCustomXMLNode*>(m_pWrapper->polymorphicFactory(hRootNode)));
	}
	
	/**
	* CCustomDOMTree::SaveToString - Saves the XML tree into a string.
	* @return String with the XML Content.
	*/
	std::string CCustomDOMTree::SaveToString()
	{
		Lib3MF_uint32 bytesNeededXMLString = 0;
		Lib3MF_uint32 bytesWrittenXMLString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDOMTree_SaveToString(m_pHandle, 0, &bytesNeededXMLString, nullptr));
		std::vector<char> bufferXMLString(bytesNeededXMLString);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDOMTree_SaveToString(m_pHandle, bytesNeededXMLString, &bytesWrittenXMLString, &bufferXMLString[0]));
		
		return std::string(&bufferXMLString[0]);
	}
	
	/**
	 * Method definitions for class CSliceStackIterator
	 */
	
	/**
	* CSliceStackIterator::GetCurrentSliceStack - Returns the SliceStack the iterator points at.
	* @return returns the SliceStack instance.
	*/
	PSliceStack CSliceStackIterator::GetCurrentSliceStack()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStackIterator_GetCurrentSliceStack(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStack>(dynamic_cast<CSliceStack*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CObjectIterator
	 */
	
	/**
	* CObjectIterator::GetCurrentObject - Returns the Object the iterator points at.
	* @return returns the Object instance.
	*/
	PObject CObjectIterator::GetCurrentObject()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ObjectIterator_GetCurrentObject(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CObject>(dynamic_cast<CObject*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CMeshObjectIterator
	 */
	
	/**
	* CMeshObjectIterator::GetCurrentMeshObject - Returns the MeshObject the iterator points at.
	* @return returns the MeshObject instance.
	*/
	PMeshObject CMeshObjectIterator::GetCurrentMeshObject()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObjectIterator_GetCurrentMeshObject(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMeshObject>(dynamic_cast<CMeshObject*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CComponentsObjectIterator
	 */
	
	/**
	* CComponentsObjectIterator::GetCurrentComponentsObject - Returns the ComponentsObject the iterator points at.
	* @return returns the ComponentsObject instance.
	*/
	PComponentsObject CComponentsObjectIterator::GetCurrentComponentsObject()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ComponentsObjectIterator_GetCurrentComponentsObject(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponentsObject>(dynamic_cast<CComponentsObject*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CTexture2DIterator
	 */
	
	/**
	* CTexture2DIterator::GetCurrentTexture2D - Returns the Texture2D the iterator points at.
	* @return returns the Texture2D instance.
	*/
	PTexture2D CTexture2DIterator::GetCurrentTexture2D()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DIterator_GetCurrentTexture2D(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2D>(dynamic_cast<CTexture2D*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CBaseMaterialGroupIterator
	 */
	
	/**
	* CBaseMaterialGroupIterator::GetCurrentBaseMaterialGroup - Returns the MaterialGroup the iterator points at.
	* @return returns the BaseMaterialGroup instance.
	*/
	PBaseMaterialGroup CBaseMaterialGroupIterator::GetCurrentBaseMaterialGroup()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroupIterator_GetCurrentBaseMaterialGroup(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBaseMaterialGroup>(dynamic_cast<CBaseMaterialGroup*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CColorGroupIterator
	 */
	
	/**
	* CColorGroupIterator::GetCurrentColorGroup - Returns the ColorGroup the iterator points at.
	* @return returns the ColorGroup instance.
	*/
	PColorGroup CColorGroupIterator::GetCurrentColorGroup()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroupIterator_GetCurrentColorGroup(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CColorGroup>(dynamic_cast<CColorGroup*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CTexture2DGroupIterator
	 */
	
	/**
	* CTexture2DGroupIterator::GetCurrentTexture2DGroup - Returns the Texture2DGroup the iterator points at.
	* @return returns the Texture2DGroup instance.
	*/
	PTexture2DGroup CTexture2DGroupIterator::GetCurrentTexture2DGroup()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroupIterator_GetCurrentTexture2DGroup(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2DGroup>(dynamic_cast<CTexture2DGroup*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CCompositeMaterialsIterator
	 */
	
	/**
	* CCompositeMaterialsIterator::GetCurrentCompositeMaterials - Returns the CompositeMaterials the iterator points at.
	* @return returns the CompositeMaterials instance.
	*/
	PCompositeMaterials CCompositeMaterialsIterator::GetCurrentCompositeMaterials()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterialsIterator_GetCurrentCompositeMaterials(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCompositeMaterials>(dynamic_cast<CCompositeMaterials*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CMultiPropertyGroupIterator
	 */
	
	/**
	* CMultiPropertyGroupIterator::GetCurrentMultiPropertyGroup - Returns the MultiPropertyGroup the iterator points at.
	* @return returns the MultiPropertyGroup instance.
	*/
	PMultiPropertyGroup CMultiPropertyGroupIterator::GetCurrentMultiPropertyGroup()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroupIterator_GetCurrentMultiPropertyGroup(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMultiPropertyGroup>(dynamic_cast<CMultiPropertyGroup*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CMetaData
	 */
	
	/**
	* CMetaData::GetNameSpace - returns the namespace URL of the metadata
	* @return the namespace URL of the metadata
	*/
	std::string CMetaData::GetNameSpace()
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetNameSpace(m_pHandle, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetNameSpace(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CMetaData::SetNameSpace - sets a new namespace URL of the metadata
	* @param[in] sNameSpace - the new namespace URL of the metadata
	*/
	void CMetaData::SetNameSpace(const std::string & sNameSpace)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_SetNameSpace(m_pHandle, sNameSpace.c_str()));
	}
	
	/**
	* CMetaData::GetName - returns the name of a metadata
	* @return the name of the metadata
	*/
	std::string CMetaData::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CMetaData::SetName - sets a new name of a metadata
	* @param[in] sName - the new name of the metadata
	*/
	void CMetaData::SetName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_SetName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CMetaData::GetKey - returns the (namespace+name) of a metadata
	* @return the key (namespace+name) of the metadata
	*/
	std::string CMetaData::GetKey()
	{
		Lib3MF_uint32 bytesNeededKey = 0;
		Lib3MF_uint32 bytesWrittenKey = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetKey(m_pHandle, 0, &bytesNeededKey, nullptr));
		std::vector<char> bufferKey(bytesNeededKey);
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetKey(m_pHandle, bytesNeededKey, &bytesWrittenKey, &bufferKey[0]));
		
		return std::string(&bufferKey[0]);
	}
	
	/**
	* CMetaData::GetMustPreserve - returns, whether a metadata must be preserved
	* @return returns, whether a metadata must be preserved
	*/
	bool CMetaData::GetMustPreserve()
	{
		bool resultMustPreserve = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetMustPreserve(m_pHandle, &resultMustPreserve));
		
		return resultMustPreserve;
	}
	
	/**
	* CMetaData::SetMustPreserve - sets whether a metadata must be preserved
	* @param[in] bMustPreserve - a new value whether a metadata must be preserved
	*/
	void CMetaData::SetMustPreserve(const bool bMustPreserve)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_SetMustPreserve(m_pHandle, bMustPreserve));
	}
	
	/**
	* CMetaData::GetType - returns the type of a metadata
	* @return the type of the metadata
	*/
	std::string CMetaData::GetType()
	{
		Lib3MF_uint32 bytesNeededType = 0;
		Lib3MF_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CMetaData::SetType - sets a new type of a metadata. This must be a simple XML type
	* @param[in] sType - a new type of the metadata
	*/
	void CMetaData::SetType(const std::string & sType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_SetType(m_pHandle, sType.c_str()));
	}
	
	/**
	* CMetaData::GetValue - returns the value of the metadata
	* @return the value of the metadata
	*/
	std::string CMetaData::GetValue()
	{
		Lib3MF_uint32 bytesNeededValue = 0;
		Lib3MF_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetValue(m_pHandle, 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_GetValue(m_pHandle, bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CMetaData::SetValue - sets a new value of the metadata
	* @param[in] sValue - a new value of the metadata
	*/
	void CMetaData::SetValue(const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaData_SetValue(m_pHandle, sValue.c_str()));
	}
	
	/**
	 * Method definitions for class CMetaDataGroup
	 */
	
	/**
	* CMetaDataGroup::GetMetaDataCount - returns the number of metadata in this metadatagroup
	* @return returns the number metadata
	*/
	Lib3MF_uint32 CMetaDataGroup::GetMetaDataCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_GetMetaDataCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CMetaDataGroup::GetMetaData - returns a metadata value within this metadatagroup
	* @param[in] nIndex - Index of the Metadata.
	* @return an instance of the metadata
	*/
	PMetaData CMetaDataGroup::GetMetaData(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hMetaData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_GetMetaData(m_pHandle, nIndex, &hMetaData));
		
		if (!hMetaData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaData>(dynamic_cast<CMetaData*>(m_pWrapper->polymorphicFactory(hMetaData)));
	}
	
	/**
	* CMetaDataGroup::GetMetaDataByKey - returns a metadata value within this metadatagroup
	* @param[in] sNameSpace - the namespace of the metadata
	* @param[in] sName - the name of the Metadata
	* @return an instance of the metadata
	*/
	PMetaData CMetaDataGroup::GetMetaDataByKey(const std::string & sNameSpace, const std::string & sName)
	{
		Lib3MFHandle hMetaData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_GetMetaDataByKey(m_pHandle, sNameSpace.c_str(), sName.c_str(), &hMetaData));
		
		if (!hMetaData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaData>(dynamic_cast<CMetaData*>(m_pWrapper->polymorphicFactory(hMetaData)));
	}
	
	/**
	* CMetaDataGroup::RemoveMetaDataByIndex - removes metadata by index from the model.
	* @param[in] nIndex -  Index of the metadata to remove
	*/
	void CMetaDataGroup::RemoveMetaDataByIndex(const Lib3MF_uint32 nIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_RemoveMetaDataByIndex(m_pHandle, nIndex));
	}
	
	/**
	* CMetaDataGroup::RemoveMetaData - removes metadata from the model.
	* @param[in] pTheMetaData - The metadata to remove
	*/
	void CMetaDataGroup::RemoveMetaData(classParam<CMetaData> pTheMetaData)
	{
		Lib3MFHandle hTheMetaData = pTheMetaData.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_RemoveMetaData(m_pHandle, hTheMetaData));
	}
	
	/**
	* CMetaDataGroup::AddMetaData - adds a new metadata to this metadatagroup
	* @param[in] sNameSpace - the namespace of the metadata
	* @param[in] sName - the name of the metadata
	* @param[in] sValue - the value of the metadata
	* @param[in] sType - the type of the metadata
	* @param[in] bMustPreserve - shuold the metadata be preserved
	* @return a new instance of the metadata
	*/
	PMetaData CMetaDataGroup::AddMetaData(const std::string & sNameSpace, const std::string & sName, const std::string & sValue, const std::string & sType, const bool bMustPreserve)
	{
		Lib3MFHandle hMetaData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MetaDataGroup_AddMetaData(m_pHandle, sNameSpace.c_str(), sName.c_str(), sValue.c_str(), sType.c_str(), bMustPreserve, &hMetaData));
		
		if (!hMetaData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaData>(dynamic_cast<CMetaData*>(m_pWrapper->polymorphicFactory(hMetaData)));
	}
	
	/**
	 * Method definitions for class CObject
	 */
	
	/**
	* CObject::GetType - Retrieves an object's type
	* @return returns object type enum.
	*/
	eObjectType CObject::GetType()
	{
		eObjectType resultObjectType = (eObjectType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetType(m_pHandle, &resultObjectType));
		
		return resultObjectType;
	}
	
	/**
	* CObject::SetType - Sets an object's type
	* @param[in] eObjectType - object type enum.
	*/
	void CObject::SetType(const eObjectType eObjectType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetType(m_pHandle, eObjectType));
	}
	
	/**
	* CObject::GetName - Retrieves an object's name
	* @return returns object name.
	*/
	std::string CObject::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CObject::SetName - Sets an object's name string
	* @param[in] sName - new object name.
	*/
	void CObject::SetName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CObject::GetPartNumber - Retrieves an object's part number
	* @return returns object part number.
	*/
	std::string CObject::GetPartNumber()
	{
		Lib3MF_uint32 bytesNeededPartNumber = 0;
		Lib3MF_uint32 bytesWrittenPartNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetPartNumber(m_pHandle, 0, &bytesNeededPartNumber, nullptr));
		std::vector<char> bufferPartNumber(bytesNeededPartNumber);
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetPartNumber(m_pHandle, bytesNeededPartNumber, &bytesWrittenPartNumber, &bufferPartNumber[0]));
		
		return std::string(&bufferPartNumber[0]);
	}
	
	/**
	* CObject::SetPartNumber - Sets an objects partnumber string
	* @param[in] sPartNumber - new object part number.
	*/
	void CObject::SetPartNumber(const std::string & sPartNumber)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetPartNumber(m_pHandle, sPartNumber.c_str()));
	}
	
	/**
	* CObject::IsMeshObject - Retrieves, if an object is a mesh object
	* @return returns, whether the object is a mesh object
	*/
	bool CObject::IsMeshObject()
	{
		bool resultIsMeshObject = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_IsMeshObject(m_pHandle, &resultIsMeshObject));
		
		return resultIsMeshObject;
	}
	
	/**
	* CObject::IsComponentsObject - Retrieves, if an object is a components object
	* @return returns, whether the object is a components object
	*/
	bool CObject::IsComponentsObject()
	{
		bool resultIsComponentsObject = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_IsComponentsObject(m_pHandle, &resultIsComponentsObject));
		
		return resultIsComponentsObject;
	}
	
	/**
	* CObject::IsValid - Retrieves, if the object is valid according to the core spec. For mesh objects, we distinguish between the type attribute of the object:In case of object type other, this always means false.In case of object type model or solidsupport, this means, if the mesh suffices all requirements of the core spec chapter 4.1.In case of object type support or surface, this always means true.A component objects is valid if and only if it contains at least one component and all child components are valid objects.
	* @return returns whether the object is a valid object description
	*/
	bool CObject::IsValid()
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_IsValid(m_pHandle, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CObject::SetAttachmentAsThumbnail - Use an existing attachment as thumbnail for this object
	* @param[in] pAttachment - Instance of a new or the existing thumbnailattachment object.
	*/
	void CObject::SetAttachmentAsThumbnail(classParam<CAttachment> pAttachment)
	{
		Lib3MFHandle hAttachment = pAttachment.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetAttachmentAsThumbnail(m_pHandle, hAttachment));
	}
	
	/**
	* CObject::GetThumbnailAttachment - Get the attachment containing the object thumbnail.
	* @return Instance of the thumbnailattachment object or NULL.
	*/
	PAttachment CObject::GetThumbnailAttachment()
	{
		Lib3MFHandle hAttachment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetThumbnailAttachment(m_pHandle, &hAttachment));
		
		if (hAttachment) {
			return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachment)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CObject::ClearThumbnailAttachment - Clears the attachment. The attachment instance is not removed from the package.
	*/
	void CObject::ClearThumbnailAttachment()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_ClearThumbnailAttachment(m_pHandle));
	}
	
	/**
	* CObject::GetOutbox - Returns the outbox of a build item
	* @return Outbox of this build item
	*/
	sBox CObject::GetOutbox()
	{
		sBox resultOutbox;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetOutbox(m_pHandle, &resultOutbox));
		
		return resultOutbox;
	}
	
	/**
	* CObject::GetUUID - Retrieves an object's uuid string (see production extension specification)
	* @param[out] bHasUUID - flag whether the build item has a UUID
	* @return returns object uuid.
	*/
	std::string CObject::GetUUID(bool & bHasUUID)
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetUUID(m_pHandle, &bHasUUID, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetUUID(m_pHandle, &bHasUUID, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CObject::SetUUID - Sets a build object's uuid string (see production extension specification)
	* @param[in] sUUID - new object uuid string.
	*/
	void CObject::SetUUID(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetUUID(m_pHandle, sUUID.c_str()));
	}
	
	/**
	* CObject::GetMetaDataGroup - Returns the metadatagroup of this object
	* @return returns an Instance of the metadatagroup of this object
	*/
	PMetaDataGroup CObject::GetMetaDataGroup()
	{
		Lib3MFHandle hMetaDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetMetaDataGroup(m_pHandle, &hMetaDataGroup));
		
		if (!hMetaDataGroup) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaDataGroup>(dynamic_cast<CMetaDataGroup*>(m_pWrapper->polymorphicFactory(hMetaDataGroup)));
	}
	
	/**
	* CObject::SetSlicesMeshResolution - set the meshresolution of the mesh object
	* @param[in] eMeshResolution - meshresolution of this object
	*/
	void CObject::SetSlicesMeshResolution(const eSlicesMeshResolution eMeshResolution)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_SetSlicesMeshResolution(m_pHandle, eMeshResolution));
	}
	
	/**
	* CObject::GetSlicesMeshResolution - get the meshresolution of the mesh object
	* @return meshresolution of this object
	*/
	eSlicesMeshResolution CObject::GetSlicesMeshResolution()
	{
		eSlicesMeshResolution resultMeshResolution = (eSlicesMeshResolution) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetSlicesMeshResolution(m_pHandle, &resultMeshResolution));
		
		return resultMeshResolution;
	}
	
	/**
	* CObject::HasSlices - returns whether the Object has a slice stack. If Recursive is true, also checks whether any references object has a slice stack
	* @param[in] bRecursive - check also all referenced objects?
	* @return does the object have a slice stack?
	*/
	bool CObject::HasSlices(const bool bRecursive)
	{
		bool resultHasSlices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_HasSlices(m_pHandle, bRecursive, &resultHasSlices));
		
		return resultHasSlices;
	}
	
	/**
	* CObject::ClearSliceStack - unlinks the attached slicestack from this object. If no slice stack is attached, do noting.
	*/
	void CObject::ClearSliceStack()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Object_ClearSliceStack(m_pHandle));
	}
	
	/**
	* CObject::GetSliceStack - get the Slicestack attached to the object
	* @return returns the slicestack instance
	*/
	PSliceStack CObject::GetSliceStack()
	{
		Lib3MFHandle hSliceStackInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Object_GetSliceStack(m_pHandle, &hSliceStackInstance));
		
		if (!hSliceStackInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStack>(dynamic_cast<CSliceStack*>(m_pWrapper->polymorphicFactory(hSliceStackInstance)));
	}
	
	/**
	* CObject::AssignSliceStack - assigns a slicestack to the object
	* @param[in] pSliceStackInstance - the new slice stack of this Object
	*/
	void CObject::AssignSliceStack(classParam<CSliceStack> pSliceStackInstance)
	{
		Lib3MFHandle hSliceStackInstance = pSliceStackInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Object_AssignSliceStack(m_pHandle, hSliceStackInstance));
	}
	
	/**
	 * Method definitions for class CMeshObject
	 */
	
	/**
	* CMeshObject::GetVertexCount - Returns the vertex count of a mesh object.
	* @return filled with the vertex count.
	*/
	Lib3MF_uint32 CMeshObject::GetVertexCount()
	{
		Lib3MF_uint32 resultVertexCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertexCount(m_pHandle, &resultVertexCount));
		
		return resultVertexCount;
	}
	
	/**
	* CMeshObject::GetTriangleCount - Returns the triangle count of a mesh object.
	* @return filled with the triangle count.
	*/
	Lib3MF_uint32 CMeshObject::GetTriangleCount()
	{
		Lib3MF_uint32 resultVertexCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleCount(m_pHandle, &resultVertexCount));
		
		return resultVertexCount;
	}
	
	/**
	* CMeshObject::GetVertex - Returns the vertex count of a mesh object.
	* @param[in] nIndex - Index of the vertex (0 to vertexcount - 1)
	* @return filled with the vertex coordinates.
	*/
	sPosition CMeshObject::GetVertex(const Lib3MF_uint32 nIndex)
	{
		sPosition resultCoordinates;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertex(m_pHandle, nIndex, &resultCoordinates));
		
		return resultCoordinates;
	}
	
	/**
	* CMeshObject::SetVertex - Sets the coordinates of a single vertex of a mesh object
	* @param[in] nIndex - Index of the vertex (0 to vertexcount - 1)
	* @param[in] Coordinates - contains the vertex coordinates.
	*/
	void CMeshObject::SetVertex(const Lib3MF_uint32 nIndex, const sPosition & Coordinates)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetVertex(m_pHandle, nIndex, &Coordinates));
	}
	
	/**
	* CMeshObject::AddVertex - Adds a single vertex to a mesh object
	* @param[in] Coordinates - contains the vertex coordinates.
	* @return Index of the new vertex
	*/
	Lib3MF_uint32 CMeshObject::AddVertex(const sPosition & Coordinates)
	{
		Lib3MF_uint32 resultNewIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_AddVertex(m_pHandle, &Coordinates, &resultNewIndex));
		
		return resultNewIndex;
	}
	
	/**
	* CMeshObject::GetVertices - Obtains all vertex positions of a mesh object
	* @param[out] VerticesBuffer - contains the vertex coordinates.
	*/
	void CMeshObject::GetVertices(std::vector<sPosition> & VerticesBuffer)
	{
		Lib3MF_uint64 elementsNeededVertices = 0;
		Lib3MF_uint64 elementsWrittenVertices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertices(m_pHandle, 0, &elementsNeededVertices, nullptr));
		VerticesBuffer.resize((size_t) elementsNeededVertices);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertices(m_pHandle, elementsNeededVertices, &elementsWrittenVertices, VerticesBuffer.data()));
	}
	
	/**
	* CMeshObject::GetTriangle - Returns indices of a single triangle of a mesh object.
	* @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)
	* @return filled with the triangle indices.
	*/
	sTriangle CMeshObject::GetTriangle(const Lib3MF_uint32 nIndex)
	{
		sTriangle resultIndices;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangle(m_pHandle, nIndex, &resultIndices));
		
		return resultIndices;
	}
	
	/**
	* CMeshObject::SetTriangle - Sets the indices of a single triangle of a mesh object.
	* @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)
	* @param[in] Indices - contains the triangle indices.
	*/
	void CMeshObject::SetTriangle(const Lib3MF_uint32 nIndex, const sTriangle & Indices)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetTriangle(m_pHandle, nIndex, &Indices));
	}
	
	/**
	* CMeshObject::AddTriangle - Adds a single triangle to a mesh object
	* @param[in] Indices - contains the triangle indices.
	* @return Index of the new triangle
	*/
	Lib3MF_uint32 CMeshObject::AddTriangle(const sTriangle & Indices)
	{
		Lib3MF_uint32 resultNewIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_AddTriangle(m_pHandle, &Indices, &resultNewIndex));
		
		return resultNewIndex;
	}
	
	/**
	* CMeshObject::GetTriangleIndices - Get all triangles of a mesh object
	* @param[out] IndicesBuffer - contains the triangle indices.
	*/
	void CMeshObject::GetTriangleIndices(std::vector<sTriangle> & IndicesBuffer)
	{
		Lib3MF_uint64 elementsNeededIndices = 0;
		Lib3MF_uint64 elementsWrittenIndices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleIndices(m_pHandle, 0, &elementsNeededIndices, nullptr));
		IndicesBuffer.resize((size_t) elementsNeededIndices);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleIndices(m_pHandle, elementsNeededIndices, &elementsWrittenIndices, IndicesBuffer.data()));
	}
	
	/**
	* CMeshObject::SetObjectLevelProperty - Sets the property at the object-level of the mesh object.
	* @param[in] nUniqueResourceID - the object-level Property UniqueResourceID.
	* @param[in] nPropertyID - the object-level PropertyID.
	*/
	void CMeshObject::SetObjectLevelProperty(const Lib3MF_uint32 nUniqueResourceID, const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetObjectLevelProperty(m_pHandle, nUniqueResourceID, nPropertyID));
	}
	
	/**
	* CMeshObject::GetObjectLevelProperty - Gets the property at the object-level of the mesh object.
	* @param[out] nUniqueResourceID - the object-level Property UniqueResourceID.
	* @param[out] nPropertyID - the object-level PropertyID.
	* @return Has an object-level property been specified?
	*/
	bool CMeshObject::GetObjectLevelProperty(Lib3MF_uint32 & nUniqueResourceID, Lib3MF_uint32 & nPropertyID)
	{
		bool resultHasObjectLevelProperty = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetObjectLevelProperty(m_pHandle, &nUniqueResourceID, &nPropertyID, &resultHasObjectLevelProperty));
		
		return resultHasObjectLevelProperty;
	}
	
	/**
	* CMeshObject::SetTriangleProperties - Sets the properties of a single triangle of a mesh object.
	* @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)
	* @param[in] Properties - contains the triangle properties.
	*/
	void CMeshObject::SetTriangleProperties(const Lib3MF_uint32 nIndex, const sTriangleProperties & Properties)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetTriangleProperties(m_pHandle, nIndex, &Properties));
	}
	
	/**
	* CMeshObject::GetTriangleProperties - Gets the properties of a single triangle of a mesh object.
	* @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)
	* @param[out] Property - returns the triangle properties.
	*/
	void CMeshObject::GetTriangleProperties(const Lib3MF_uint32 nIndex, sTriangleProperties & Property)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleProperties(m_pHandle, nIndex, &Property));
	}
	
	/**
	* CMeshObject::SetAllTriangleProperties - Sets the properties of all triangles of a mesh object. Sets the object level property to the first entry of the passed triangle properties, if not yet specified.
	* @param[in] PropertiesArrayBuffer - contains the triangle properties array. Must have trianglecount elements.
	*/
	void CMeshObject::SetAllTriangleProperties(const CInputVector<sTriangleProperties> & PropertiesArrayBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetAllTriangleProperties(m_pHandle, (Lib3MF_uint64)PropertiesArrayBuffer.size(), PropertiesArrayBuffer.data()));
	}
	
	/**
	* CMeshObject::GetAllTriangleProperties - Gets the properties of all triangles of a mesh object.
	* @param[out] PropertiesArrayBuffer - returns the triangle properties array. Must have trianglecount elements.
	*/
	void CMeshObject::GetAllTriangleProperties(std::vector<sTriangleProperties> & PropertiesArrayBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertiesArray = 0;
		Lib3MF_uint64 elementsWrittenPropertiesArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllTriangleProperties(m_pHandle, 0, &elementsNeededPropertiesArray, nullptr));
		PropertiesArrayBuffer.resize((size_t) elementsNeededPropertiesArray);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllTriangleProperties(m_pHandle, elementsNeededPropertiesArray, &elementsWrittenPropertiesArray, PropertiesArrayBuffer.data()));
	}
	
	/**
	* CMeshObject::ClearAllProperties - Clears all properties of this mesh object (triangle and object-level).
	*/
	void CMeshObject::ClearAllProperties()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_ClearAllProperties(m_pHandle));
	}
	
	/**
	* CMeshObject::SetGeometry - Set all triangles of a mesh object
	* @param[in] VerticesBuffer - contains the positions.
	* @param[in] IndicesBuffer - contains the triangle indices.
	*/
	void CMeshObject::SetGeometry(const CInputVector<sPosition> & VerticesBuffer, const CInputVector<sTriangle> & IndicesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_SetGeometry(m_pHandle, (Lib3MF_uint64)VerticesBuffer.size(), VerticesBuffer.data(), (Lib3MF_uint64)IndicesBuffer.size(), IndicesBuffer.data()));
	}
	
	/**
	* CMeshObject::IsManifoldAndOriented - Retrieves, if an object describes a topologically oriented and manifold mesh, according to the core spec.
	* @return returns, if the object is oriented and manifold.
	*/
	bool CMeshObject::IsManifoldAndOriented()
	{
		bool resultIsManifoldAndOriented = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_IsManifoldAndOriented(m_pHandle, &resultIsManifoldAndOriented));
		
		return resultIsManifoldAndOriented;
	}
	
	/**
	* CMeshObject::BeamLattice - Retrieves the BeamLattice within this MeshObject.
	* @return the BeamLattice within this MeshObject
	*/
	PBeamLattice CMeshObject::BeamLattice()
	{
		Lib3MFHandle hTheBeamLattice = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_BeamLattice(m_pHandle, &hTheBeamLattice));
		
		if (!hTheBeamLattice) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBeamLattice>(dynamic_cast<CBeamLattice*>(m_pWrapper->polymorphicFactory(hTheBeamLattice)));
	}
	
	/**
	 * Method definitions for class CBeamLattice
	 */
	
	/**
	* CBeamLattice::GetMinLength - Returns the minimal length of beams for the beamlattice.
	* @return minimal length of beams for the beamlattice
	*/
	Lib3MF_double CBeamLattice::GetMinLength()
	{
		Lib3MF_double resultMinLength = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetMinLength(m_pHandle, &resultMinLength));
		
		return resultMinLength;
	}
	
	/**
	* CBeamLattice::SetMinLength - Sets the minimal length of beams for the beamlattice.
	* @param[in] dMinLength - minimal length of beams for the beamlattice
	*/
	void CBeamLattice::SetMinLength(const Lib3MF_double dMinLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetMinLength(m_pHandle, dMinLength));
	}
	
	/**
	* CBeamLattice::GetClipping - Returns the clipping mode and the clipping-mesh for the beamlattice of this mesh.
	* @param[out] eClipMode - contains the clip mode of this mesh
	* @param[out] nUniqueResourceID - filled with the UniqueResourceID of the clipping mesh-object or an undefined value if pClipMode is MODELBEAMLATTICECLIPMODE_NONE
	*/
	void CBeamLattice::GetClipping(eBeamLatticeClipMode & eClipMode, Lib3MF_uint32 & nUniqueResourceID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetClipping(m_pHandle, &eClipMode, &nUniqueResourceID));
	}
	
	/**
	* CBeamLattice::SetClipping - Sets the clipping mode and the clipping-mesh for the beamlattice of this mesh.
	* @param[in] eClipMode - contains the clip mode of this mesh
	* @param[in] nUniqueResourceID - the UniqueResourceID of the clipping mesh-object. This mesh-object has to be defined before setting the Clipping.
	*/
	void CBeamLattice::SetClipping(const eBeamLatticeClipMode eClipMode, const Lib3MF_uint32 nUniqueResourceID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetClipping(m_pHandle, eClipMode, nUniqueResourceID));
	}
	
	/**
	* CBeamLattice::GetRepresentation - Returns the representation-mesh for the beamlattice of this mesh.
	* @return flag whether the beamlattice has a representation mesh.
	* @param[out] nUniqueResourceID - filled with the UniqueResourceID of the clipping mesh-object.
	*/
	bool CBeamLattice::GetRepresentation(Lib3MF_uint32 & nUniqueResourceID)
	{
		bool resultHasRepresentation = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetRepresentation(m_pHandle, &resultHasRepresentation, &nUniqueResourceID));
		
		return resultHasRepresentation;
	}
	
	/**
	* CBeamLattice::SetRepresentation - Sets the representation-mesh for the beamlattice of this mesh.
	* @param[in] nUniqueResourceID - the UniqueResourceID of the representation mesh-object. This mesh-object has to be defined before setting the representation.
	*/
	void CBeamLattice::SetRepresentation(const Lib3MF_uint32 nUniqueResourceID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetRepresentation(m_pHandle, nUniqueResourceID));
	}
	
	/**
	* CBeamLattice::GetBallOptions - Returns the ball mode and the default ball radius for the beamlattice of this mesh.
	* @param[out] eBallMode - contains the ball mode of this mesh
	* @param[out] dBallRadius - default ball radius of balls for the beamlattice
	*/
	void CBeamLattice::GetBallOptions(eBeamLatticeBallMode & eBallMode, Lib3MF_double & dBallRadius)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBallOptions(m_pHandle, &eBallMode, &dBallRadius));
	}
	
	/**
	* CBeamLattice::SetBallOptions - Sets the ball mode and thedefault ball radius for the beamlattice.
	* @param[in] eBallMode - contains the ball mode of this mesh
	* @param[in] dBallRadius - default ball radius of balls for the beamlattice
	*/
	void CBeamLattice::SetBallOptions(const eBeamLatticeBallMode eBallMode, const Lib3MF_double dBallRadius)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetBallOptions(m_pHandle, eBallMode, dBallRadius));
	}
	
	/**
	* CBeamLattice::GetBeamCount - Returns the beam count of a mesh object.
	* @return filled with the beam count.
	*/
	Lib3MF_uint32 CBeamLattice::GetBeamCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeamCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBeamLattice::GetBeam - Returns indices, radii and capmodes of a single beam of a mesh object.
	* @param[in] nIndex - Index of the beam (0 to beamcount - 1).
	* @return filled with the beam indices, radii and capmodes.
	*/
	sBeam CBeamLattice::GetBeam(const Lib3MF_uint32 nIndex)
	{
		sBeam resultBeamInfo;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeam(m_pHandle, nIndex, &resultBeamInfo));
		
		return resultBeamInfo;
	}
	
	/**
	* CBeamLattice::AddBeam - Adds a single beam to a mesh object.
	* @param[in] BeamInfo - contains the node indices, radii and capmodes.
	* @return filled with the new Index of the beam.
	*/
	Lib3MF_uint32 CBeamLattice::AddBeam(const sBeam & BeamInfo)
	{
		Lib3MF_uint32 resultIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_AddBeam(m_pHandle, &BeamInfo, &resultIndex));
		
		return resultIndex;
	}
	
	/**
	* CBeamLattice::SetBeam - Sets the indices, radii and capmodes of a single beam of a mesh object.
	* @param[in] nIndex - Index of the beam (0 to beamcount - 1).
	* @param[in] BeamInfo - filled with the beam indices, radii and capmodes.
	*/
	void CBeamLattice::SetBeam(const Lib3MF_uint32 nIndex, const sBeam & BeamInfo)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetBeam(m_pHandle, nIndex, &BeamInfo));
	}
	
	/**
	* CBeamLattice::SetBeams - Sets all beam indices, radii and capmodes of a mesh object.
	* @param[in] BeamInfoBuffer - contains information of a number of  beams
	*/
	void CBeamLattice::SetBeams(const CInputVector<sBeam> & BeamInfoBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetBeams(m_pHandle, (Lib3MF_uint64)BeamInfoBuffer.size(), BeamInfoBuffer.data()));
	}
	
	/**
	* CBeamLattice::GetBeams - obtains all beam indices, radii and capmodes of a mesh object.
	* @param[out] BeamInfoBuffer - contains information of all beams
	*/
	void CBeamLattice::GetBeams(std::vector<sBeam> & BeamInfoBuffer)
	{
		Lib3MF_uint64 elementsNeededBeamInfo = 0;
		Lib3MF_uint64 elementsWrittenBeamInfo = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeams(m_pHandle, 0, &elementsNeededBeamInfo, nullptr));
		BeamInfoBuffer.resize((size_t) elementsNeededBeamInfo);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeams(m_pHandle, elementsNeededBeamInfo, &elementsWrittenBeamInfo, BeamInfoBuffer.data()));
	}
	
	/**
	* CBeamLattice::GetBallCount - Returns the ball count of a mesh object.
	* @return filled with the ball count.
	*/
	Lib3MF_uint32 CBeamLattice::GetBallCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBallCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBeamLattice::GetBall - Returns index and radius of a single ball of a mesh object.
	* @param[in] nIndex - Index of the ball (0 to ballcount - 1).
	* @return filled with the ball node index and radius.
	*/
	sBall CBeamLattice::GetBall(const Lib3MF_uint32 nIndex)
	{
		sBall resultBallInfo;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBall(m_pHandle, nIndex, &resultBallInfo));
		
		return resultBallInfo;
	}
	
	/**
	* CBeamLattice::AddBall - Adds a single ball to a mesh object.
	* @param[in] BallInfo - contains the node index and radius.
	* @return filled with the new Index of the ball.
	*/
	Lib3MF_uint32 CBeamLattice::AddBall(const sBall & BallInfo)
	{
		Lib3MF_uint32 resultIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_AddBall(m_pHandle, &BallInfo, &resultIndex));
		
		return resultIndex;
	}
	
	/**
	* CBeamLattice::SetBall - Sets the index and radius of a single ball of a mesh object.
	* @param[in] nIndex - Index of the ball (0 to ballcount - 1).
	* @param[in] BallInfo - filled with the ball node index and radius.
	*/
	void CBeamLattice::SetBall(const Lib3MF_uint32 nIndex, const sBall & BallInfo)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetBall(m_pHandle, nIndex, &BallInfo));
	}
	
	/**
	* CBeamLattice::SetBalls - Sets all ball indices and radii of a mesh object.
	* @param[in] BallInfoBuffer - contains information of a number of  balls
	*/
	void CBeamLattice::SetBalls(const CInputVector<sBall> & BallInfoBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_SetBalls(m_pHandle, (Lib3MF_uint64)BallInfoBuffer.size(), BallInfoBuffer.data()));
	}
	
	/**
	* CBeamLattice::GetBalls - obtains all ball indices and radii of a mesh object.
	* @param[out] BallInfoBuffer - contains information of all balls
	*/
	void CBeamLattice::GetBalls(std::vector<sBall> & BallInfoBuffer)
	{
		Lib3MF_uint64 elementsNeededBallInfo = 0;
		Lib3MF_uint64 elementsWrittenBallInfo = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBalls(m_pHandle, 0, &elementsNeededBallInfo, nullptr));
		BallInfoBuffer.resize((size_t) elementsNeededBallInfo);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBalls(m_pHandle, elementsNeededBallInfo, &elementsWrittenBallInfo, BallInfoBuffer.data()));
	}
	
	/**
	* CBeamLattice::GetBeamSetCount - Returns the number of beamsets of a mesh object.
	* @return filled with the beamset count.
	*/
	Lib3MF_uint32 CBeamLattice::GetBeamSetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeamSetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBeamLattice::AddBeamSet - Adds an empty beamset to a mesh object
	* @return the new beamset
	*/
	PBeamSet CBeamLattice::AddBeamSet()
	{
		Lib3MFHandle hBeamSet = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_AddBeamSet(m_pHandle, &hBeamSet));
		
		if (!hBeamSet) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBeamSet>(dynamic_cast<CBeamSet*>(m_pWrapper->polymorphicFactory(hBeamSet)));
	}
	
	/**
	* CBeamLattice::GetBeamSet - Returns a beamset of a mesh object
	* @param[in] nIndex - index of the requested beamset (0 ... beamsetcount-1).
	* @return the requested beamset
	*/
	PBeamSet CBeamLattice::GetBeamSet(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hBeamSet = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamLattice_GetBeamSet(m_pHandle, nIndex, &hBeamSet));
		
		if (!hBeamSet) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBeamSet>(dynamic_cast<CBeamSet*>(m_pWrapper->polymorphicFactory(hBeamSet)));
	}
	
	/**
	 * Method definitions for class CComponent
	 */
	
	/**
	* CComponent::GetObjectResource - Returns the Resource Instance of the component.
	* @return filled with the Resource Instance.
	*/
	PObject CComponent::GetObjectResource()
	{
		Lib3MFHandle hObjectResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Component_GetObjectResource(m_pHandle, &hObjectResource));
		
		if (!hObjectResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CObject>(dynamic_cast<CObject*>(m_pWrapper->polymorphicFactory(hObjectResource)));
	}
	
	/**
	* CComponent::GetObjectResourceID - Returns the UniqueResourceID of the component.
	* @return returns the UniqueResourceID.
	*/
	Lib3MF_uint32 CComponent::GetObjectResourceID()
	{
		Lib3MF_uint32 resultUniqueResourceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Component_GetObjectResourceID(m_pHandle, &resultUniqueResourceID));
		
		return resultUniqueResourceID;
	}
	
	/**
	* CComponent::GetUUID - returns, whether a component has a UUID and, if true, the component's UUID
	* @param[out] bHasUUID - flag whether the component has a UUID
	* @return the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	std::string CComponent::GetUUID(bool & bHasUUID)
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Component_GetUUID(m_pHandle, &bHasUUID, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Component_GetUUID(m_pHandle, &bHasUUID, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CComponent::SetUUID - sets the component's UUID
	* @param[in] sUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	void CComponent::SetUUID(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Component_SetUUID(m_pHandle, sUUID.c_str()));
	}
	
	/**
	* CComponent::HasTransform - Returns, if the component has a different transformation than the identity matrix
	* @return if true is returned, the transformation is not equal than the identity
	*/
	bool CComponent::HasTransform()
	{
		bool resultHasTransform = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Component_HasTransform(m_pHandle, &resultHasTransform));
		
		return resultHasTransform;
	}
	
	/**
	* CComponent::GetTransform - Returns the transformation matrix of the component.
	* @return filled with the component transformation matrix
	*/
	sTransform CComponent::GetTransform()
	{
		sTransform resultTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_Component_GetTransform(m_pHandle, &resultTransform));
		
		return resultTransform;
	}
	
	/**
	* CComponent::SetTransform - Sets the transformation matrix of the component.
	* @param[in] Transform - new transformation matrix
	*/
	void CComponent::SetTransform(const sTransform & Transform)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Component_SetTransform(m_pHandle, &Transform));
	}
	
	/**
	 * Method definitions for class CComponentsObject
	 */
	
	/**
	* CComponentsObject::AddComponent - Adds a new component to a components object.
	* @param[in] pObjectResource - object to add as component. Must not lead to circular references!
	* @param[in] Transform - optional transform matrix for the component.
	* @return new component instance
	*/
	PComponent CComponentsObject::AddComponent(classParam<CObject> pObjectResource, const sTransform & Transform)
	{
		Lib3MFHandle hObjectResource = pObjectResource.GetHandle();
		Lib3MFHandle hComponentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ComponentsObject_AddComponent(m_pHandle, hObjectResource, &Transform, &hComponentInstance));
		
		if (!hComponentInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponent>(dynamic_cast<CComponent*>(m_pWrapper->polymorphicFactory(hComponentInstance)));
	}
	
	/**
	* CComponentsObject::GetComponent - Retrieves a component from a component object.
	* @param[in] nIndex - index of the component to retrieve (0 to componentcount - 1)
	* @return component instance
	*/
	PComponent CComponentsObject::GetComponent(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hComponentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ComponentsObject_GetComponent(m_pHandle, nIndex, &hComponentInstance));
		
		if (!hComponentInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponent>(dynamic_cast<CComponent*>(m_pWrapper->polymorphicFactory(hComponentInstance)));
	}
	
	/**
	* CComponentsObject::GetComponentCount - Retrieves a component count of a component object.
	* @return returns the component count
	*/
	Lib3MF_uint32 CComponentsObject::GetComponentCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ComponentsObject_GetComponentCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CBeamSet
	 */
	
	/**
	* CBeamSet::SetName - Sets a beamset's name string
	* @param[in] sName - new name of the beamset.
	*/
	void CBeamSet::SetName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_SetName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CBeamSet::GetName - Retrieves a beamset's name string
	* @return returns the name of the beamset.
	*/
	std::string CBeamSet::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBeamSet::SetIdentifier - Sets a beamset's identifier string
	* @param[in] sIdentifier - new name of the beamset.
	*/
	void CBeamSet::SetIdentifier(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_SetIdentifier(m_pHandle, sIdentifier.c_str()));
	}
	
	/**
	* CBeamSet::GetIdentifier - Retrieves a beamset's identifier string
	* @return returns the identifier of the beamset.
	*/
	std::string CBeamSet::GetIdentifier()
	{
		Lib3MF_uint32 bytesNeededIdentifier = 0;
		Lib3MF_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CBeamSet::GetReferenceCount - Retrieves the reference count of a beamset
	* @return returns the reference count
	*/
	Lib3MF_uint32 CBeamSet::GetReferenceCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetReferenceCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBeamSet::SetReferences - Sets the references of a beamset
	* @param[in] ReferencesBuffer - the new indices of all beams in this beamset
	*/
	void CBeamSet::SetReferences(const CInputVector<Lib3MF_uint32> & ReferencesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_SetReferences(m_pHandle, (Lib3MF_uint64)ReferencesBuffer.size(), ReferencesBuffer.data()));
	}
	
	/**
	* CBeamSet::GetReferences - Retrieves the references of a beamset
	* @param[out] ReferencesBuffer - retrieves the indices of all beams in this beamset
	*/
	void CBeamSet::GetReferences(std::vector<Lib3MF_uint32> & ReferencesBuffer)
	{
		Lib3MF_uint64 elementsNeededReferences = 0;
		Lib3MF_uint64 elementsWrittenReferences = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetReferences(m_pHandle, 0, &elementsNeededReferences, nullptr));
		ReferencesBuffer.resize((size_t) elementsNeededReferences);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetReferences(m_pHandle, elementsNeededReferences, &elementsWrittenReferences, ReferencesBuffer.data()));
	}
	
	/**
	* CBeamSet::GetBallReferenceCount - Retrieves the ball reference count of a beamset
	* @return returns the ball reference count
	*/
	Lib3MF_uint32 CBeamSet::GetBallReferenceCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetBallReferenceCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBeamSet::SetBallReferences - Sets the ball references of a beamset
	* @param[in] BallReferencesBuffer - the new indices of all balls in this beamset
	*/
	void CBeamSet::SetBallReferences(const CInputVector<Lib3MF_uint32> & BallReferencesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_SetBallReferences(m_pHandle, (Lib3MF_uint64)BallReferencesBuffer.size(), BallReferencesBuffer.data()));
	}
	
	/**
	* CBeamSet::GetBallReferences - Retrieves the ball references of a beamset
	* @param[out] BallReferencesBuffer - retrieves the indices of all balls in this beamset
	*/
	void CBeamSet::GetBallReferences(std::vector<Lib3MF_uint32> & BallReferencesBuffer)
	{
		Lib3MF_uint64 elementsNeededBallReferences = 0;
		Lib3MF_uint64 elementsWrittenBallReferences = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetBallReferences(m_pHandle, 0, &elementsNeededBallReferences, nullptr));
		BallReferencesBuffer.resize((size_t) elementsNeededBallReferences);
		CheckError(m_pWrapper->m_WrapperTable.m_BeamSet_GetBallReferences(m_pHandle, elementsNeededBallReferences, &elementsWrittenBallReferences, BallReferencesBuffer.data()));
	}
	
	/**
	 * Method definitions for class CBaseMaterialGroup
	 */
	
	/**
	* CBaseMaterialGroup::GetCount - Retrieves the count of base materials in the material group.
	* @return returns the count of base materials.
	*/
	Lib3MF_uint32 CBaseMaterialGroup::GetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CBaseMaterialGroup::GetAllPropertyIDs - returns all the PropertyIDs of all materials in this group
	* @param[out] PropertyIDsBuffer - PropertyID of the material in the material group.
	*/
	void CBaseMaterialGroup::GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetAllPropertyIDs(m_pHandle, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetAllPropertyIDs(m_pHandle, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CBaseMaterialGroup::AddMaterial - Adds a new material to the material group
	* @param[in] sName - new name of the base material.
	* @param[in] DisplayColor - Display color of the material
	* @return returns new PropertyID of the new material in the material group.
	*/
	Lib3MF_uint32 CBaseMaterialGroup::AddMaterial(const std::string & sName, const sColor & DisplayColor)
	{
		Lib3MF_uint32 resultPropertyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_AddMaterial(m_pHandle, sName.c_str(), &DisplayColor, &resultPropertyID));
		
		return resultPropertyID;
	}
	
	/**
	* CBaseMaterialGroup::RemoveMaterial - Removes a material from the material group.
	* @param[in] nPropertyID - PropertyID of the material in the material group.
	*/
	void CBaseMaterialGroup::RemoveMaterial(const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_RemoveMaterial(m_pHandle, nPropertyID));
	}
	
	/**
	* CBaseMaterialGroup::GetName - Returns the base material's name
	* @param[in] nPropertyID - PropertyID of the material in the material group.
	* @return returns the name of the base material.
	*/
	std::string CBaseMaterialGroup::GetName(const Lib3MF_uint32 nPropertyID)
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetName(m_pHandle, nPropertyID, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetName(m_pHandle, nPropertyID, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBaseMaterialGroup::SetName - Sets a base material's name
	* @param[in] nPropertyID - PropertyID of the material in the material group.
	* @param[in] sName - new name of the base material.
	*/
	void CBaseMaterialGroup::SetName(const Lib3MF_uint32 nPropertyID, const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_SetName(m_pHandle, nPropertyID, sName.c_str()));
	}
	
	/**
	* CBaseMaterialGroup::SetDisplayColor - Sets a base material's display color.
	* @param[in] nPropertyID - PropertyID of the material in the material group.
	* @param[in] TheColor - The base material's display color
	*/
	void CBaseMaterialGroup::SetDisplayColor(const Lib3MF_uint32 nPropertyID, const sColor & TheColor)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_SetDisplayColor(m_pHandle, nPropertyID, &TheColor));
	}
	
	/**
	* CBaseMaterialGroup::GetDisplayColor - Returns a base material's display color.
	* @param[in] nPropertyID - PropertyID of the material in the material group.
	* @return The base material's display color
	*/
	sColor CBaseMaterialGroup::GetDisplayColor(const Lib3MF_uint32 nPropertyID)
	{
		sColor resultTheColor;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseMaterialGroup_GetDisplayColor(m_pHandle, nPropertyID, &resultTheColor));
		
		return resultTheColor;
	}
	
	/**
	 * Method definitions for class CColorGroup
	 */
	
	/**
	* CColorGroup::GetCount - Retrieves the count of base materials in this Color Group.
	* @return returns the count of colors within this color group.
	*/
	Lib3MF_uint32 CColorGroup::GetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CColorGroup::GetAllPropertyIDs - returns all the PropertyIDs of all colors within this group
	* @param[out] PropertyIDsBuffer - PropertyID of the color in the color group.
	*/
	void CColorGroup::GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_GetAllPropertyIDs(m_pHandle, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_GetAllPropertyIDs(m_pHandle, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CColorGroup::AddColor - Adds a new value.
	* @param[in] TheColor - The new color
	* @return PropertyID of the new color within this color group.
	*/
	Lib3MF_uint32 CColorGroup::AddColor(const sColor & TheColor)
	{
		Lib3MF_uint32 resultPropertyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_AddColor(m_pHandle, &TheColor, &resultPropertyID));
		
		return resultPropertyID;
	}
	
	/**
	* CColorGroup::RemoveColor - Removes a color from the color group.
	* @param[in] nPropertyID - PropertyID of the color to be removed from the color group.
	*/
	void CColorGroup::RemoveColor(const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_RemoveColor(m_pHandle, nPropertyID));
	}
	
	/**
	* CColorGroup::SetColor - Sets a color value.
	* @param[in] nPropertyID - PropertyID of a color within this color group.
	* @param[in] TheColor - The color
	*/
	void CColorGroup::SetColor(const Lib3MF_uint32 nPropertyID, const sColor & TheColor)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_SetColor(m_pHandle, nPropertyID, &TheColor));
	}
	
	/**
	* CColorGroup::GetColor - Sets a color value.
	* @param[in] nPropertyID - PropertyID of a color within this color group.
	* @return The color
	*/
	sColor CColorGroup::GetColor(const Lib3MF_uint32 nPropertyID)
	{
		sColor resultTheColor;
		CheckError(m_pWrapper->m_WrapperTable.m_ColorGroup_GetColor(m_pHandle, nPropertyID, &resultTheColor));
		
		return resultTheColor;
	}
	
	/**
	 * Method definitions for class CTexture2DGroup
	 */
	
	/**
	* CTexture2DGroup::GetCount - Retrieves the count of tex2coords in the Texture2DGroup.
	* @return returns the count of tex2coords.
	*/
	Lib3MF_uint32 CTexture2DGroup::GetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CTexture2DGroup::GetAllPropertyIDs - returns all the PropertyIDs of all tex2coords in this Texture2DGroup
	* @param[out] PropertyIDsBuffer - PropertyID of the tex2coords in the Texture2DGroup.
	*/
	void CTexture2DGroup::GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_GetAllPropertyIDs(m_pHandle, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_GetAllPropertyIDs(m_pHandle, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CTexture2DGroup::AddTex2Coord - Adds a new tex2coord to the Texture2DGroup
	* @param[in] UVCoordinate - The u/v-coordinate within the texture, horizontally right/vertically up from the origin in the lower left of the texture.
	* @return returns new PropertyID of the new tex2coord in the Texture2DGroup.
	*/
	Lib3MF_uint32 CTexture2DGroup::AddTex2Coord(const sTex2Coord & UVCoordinate)
	{
		Lib3MF_uint32 resultPropertyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_AddTex2Coord(m_pHandle, &UVCoordinate, &resultPropertyID));
		
		return resultPropertyID;
	}
	
	/**
	* CTexture2DGroup::GetTex2Coord - Obtains a tex2coord to the Texture2DGroup
	* @param[in] nPropertyID - the PropertyID of the tex2coord in the Texture2DGroup.
	* @return The u/v-coordinate within the texture, horizontally right/vertically up from the origin in the lower left of the texture.
	*/
	sTex2Coord CTexture2DGroup::GetTex2Coord(const Lib3MF_uint32 nPropertyID)
	{
		sTex2Coord resultUVCoordinate;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_GetTex2Coord(m_pHandle, nPropertyID, &resultUVCoordinate));
		
		return resultUVCoordinate;
	}
	
	/**
	* CTexture2DGroup::RemoveTex2Coord - Removes a tex2coords from the Texture2DGroup.
	* @param[in] nPropertyID - PropertyID of the tex2coords in the Texture2DGroup.
	*/
	void CTexture2DGroup::RemoveTex2Coord(const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_RemoveTex2Coord(m_pHandle, nPropertyID));
	}
	
	/**
	* CTexture2DGroup::GetTexture2D - Obtains the texture2D instance of this group.
	* @return the texture2D instance of this group.
	*/
	PTexture2D CTexture2DGroup::GetTexture2D()
	{
		Lib3MFHandle hTexture2DInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2DGroup_GetTexture2D(m_pHandle, &hTexture2DInstance));
		
		if (!hTexture2DInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2D>(dynamic_cast<CTexture2D*>(m_pWrapper->polymorphicFactory(hTexture2DInstance)));
	}
	
	/**
	 * Method definitions for class CCompositeMaterials
	 */
	
	/**
	* CCompositeMaterials::GetCount - Retrieves the count of Composite-s in the CompositeMaterials.
	* @return returns the count of Composite-s
	*/
	Lib3MF_uint32 CCompositeMaterials::GetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CCompositeMaterials::GetAllPropertyIDs - returns all the PropertyIDs of all Composite-Mixing Values in this CompositeMaterials
	* @param[out] PropertyIDsBuffer - PropertyID of the Composite-Mixing Values in the CompositeMaterials.
	*/
	void CCompositeMaterials::GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetAllPropertyIDs(m_pHandle, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetAllPropertyIDs(m_pHandle, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CCompositeMaterials::GetBaseMaterialGroup - Obtains the BaseMaterialGroup instance of this CompositeMaterials.
	* @return returns the BaseMaterialGroup instance of this CompositeMaterials
	*/
	PBaseMaterialGroup CCompositeMaterials::GetBaseMaterialGroup()
	{
		Lib3MFHandle hBaseMaterialGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetBaseMaterialGroup(m_pHandle, &hBaseMaterialGroupInstance));
		
		if (!hBaseMaterialGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBaseMaterialGroup>(dynamic_cast<CBaseMaterialGroup*>(m_pWrapper->polymorphicFactory(hBaseMaterialGroupInstance)));
	}
	
	/**
	* CCompositeMaterials::AddComposite - Adds a new Composite-Mixing Values to the CompositeMaterials.
	* @param[in] CompositeBuffer - The Composite Constituents to be added as composite
	* @return returns new PropertyID of the new Composite in the CompositeMaterials.
	*/
	Lib3MF_uint32 CCompositeMaterials::AddComposite(const CInputVector<sCompositeConstituent> & CompositeBuffer)
	{
		Lib3MF_uint32 resultPropertyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_AddComposite(m_pHandle, (Lib3MF_uint64)CompositeBuffer.size(), CompositeBuffer.data(), &resultPropertyID));
		
		return resultPropertyID;
	}
	
	/**
	* CCompositeMaterials::RemoveComposite - Removes a Composite-Maxing Ratio from the CompositeMaterials.
	* @param[in] nPropertyID - PropertyID of the  Composite-Mixing Values in the CompositeMaterials to be removed.
	*/
	void CCompositeMaterials::RemoveComposite(const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_RemoveComposite(m_pHandle, nPropertyID));
	}
	
	/**
	* CCompositeMaterials::GetComposite - Obtains a Composite-Maxing Ratio of this CompositeMaterials.
	* @param[in] nPropertyID - the PropertyID of the Composite-Maxing Ratio in the CompositeMaterials.
	* @param[out] CompositeBuffer - The Composite-Mixing Values with the given PropertyID
	*/
	void CCompositeMaterials::GetComposite(const Lib3MF_uint32 nPropertyID, std::vector<sCompositeConstituent> & CompositeBuffer)
	{
		Lib3MF_uint64 elementsNeededComposite = 0;
		Lib3MF_uint64 elementsWrittenComposite = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetComposite(m_pHandle, nPropertyID, 0, &elementsNeededComposite, nullptr));
		CompositeBuffer.resize((size_t) elementsNeededComposite);
		CheckError(m_pWrapper->m_WrapperTable.m_CompositeMaterials_GetComposite(m_pHandle, nPropertyID, elementsNeededComposite, &elementsWrittenComposite, CompositeBuffer.data()));
	}
	
	/**
	 * Method definitions for class CMultiPropertyGroup
	 */
	
	/**
	* CMultiPropertyGroup::GetCount - Retrieves the count of MultiProperty-s in the MultiPropertyGroup.
	* @return returns the count of MultiProperty-s
	*/
	Lib3MF_uint32 CMultiPropertyGroup::GetCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CMultiPropertyGroup::GetAllPropertyIDs - returns all the PropertyIDs of all MultiProperty-s in this MultiPropertyGroup
	* @param[out] PropertyIDsBuffer - PropertyID of the MultiProperty-s in the MultiPropertyGroup.
	*/
	void CMultiPropertyGroup::GetAllPropertyIDs(std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetAllPropertyIDs(m_pHandle, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetAllPropertyIDs(m_pHandle, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CMultiPropertyGroup::AddMultiProperty - Adds a new MultiProperty to the MultiPropertyGroup.
	* @param[in] PropertyIDsBuffer - The PropertyIDs of the new MultiProperty.
	* @return returns the PropertyID of the new MultiProperty in the MultiPropertyGroup.
	*/
	Lib3MF_uint32 CMultiPropertyGroup::AddMultiProperty(const CInputVector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint32 resultPropertyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_AddMultiProperty(m_pHandle, (Lib3MF_uint64)PropertyIDsBuffer.size(), PropertyIDsBuffer.data(), &resultPropertyID));
		
		return resultPropertyID;
	}
	
	/**
	* CMultiPropertyGroup::SetMultiProperty - Sets the PropertyIDs of a MultiProperty.
	* @param[in] nPropertyID - the PropertyID of the MultiProperty to be changed.
	* @param[in] PropertyIDsBuffer - The new PropertyIDs of the MultiProperty
	*/
	void CMultiPropertyGroup::SetMultiProperty(const Lib3MF_uint32 nPropertyID, const CInputVector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_SetMultiProperty(m_pHandle, nPropertyID, (Lib3MF_uint64)PropertyIDsBuffer.size(), PropertyIDsBuffer.data()));
	}
	
	/**
	* CMultiPropertyGroup::GetMultiProperty - Obtains the PropertyIDs of a MultiProperty.
	* @param[in] nPropertyID - the PropertyID of the MultiProperty to be queried.
	* @param[out] PropertyIDsBuffer - The PropertyIDs of the MultiProperty
	*/
	void CMultiPropertyGroup::GetMultiProperty(const Lib3MF_uint32 nPropertyID, std::vector<Lib3MF_uint32> & PropertyIDsBuffer)
	{
		Lib3MF_uint64 elementsNeededPropertyIDs = 0;
		Lib3MF_uint64 elementsWrittenPropertyIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetMultiProperty(m_pHandle, nPropertyID, 0, &elementsNeededPropertyIDs, nullptr));
		PropertyIDsBuffer.resize((size_t) elementsNeededPropertyIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetMultiProperty(m_pHandle, nPropertyID, elementsNeededPropertyIDs, &elementsWrittenPropertyIDs, PropertyIDsBuffer.data()));
	}
	
	/**
	* CMultiPropertyGroup::RemoveMultiProperty - Removes a MultiProperty from this MultiPropertyGroup.
	* @param[in] nPropertyID - the PropertyID of the MultiProperty to be removed.
	*/
	void CMultiPropertyGroup::RemoveMultiProperty(const Lib3MF_uint32 nPropertyID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_RemoveMultiProperty(m_pHandle, nPropertyID));
	}
	
	/**
	* CMultiPropertyGroup::GetLayerCount - Retrieves the number of layers of this MultiPropertyGroup.
	* @return returns the number of layers
	*/
	Lib3MF_uint32 CMultiPropertyGroup::GetLayerCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetLayerCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CMultiPropertyGroup::AddLayer - Adds a MultiPropertyLayer to this MultiPropertyGroup.
	* @param[in] TheLayer - The MultiPropertyLayer to add to this MultiPropertyGroup
	* @return returns the index of this MultiPropertyLayer
	*/
	Lib3MF_uint32 CMultiPropertyGroup::AddLayer(const sMultiPropertyLayer & TheLayer)
	{
		Lib3MF_uint32 resultLayerIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_AddLayer(m_pHandle, &TheLayer, &resultLayerIndex));
		
		return resultLayerIndex;
	}
	
	/**
	* CMultiPropertyGroup::GetLayer - Obtains a MultiPropertyLayer of this MultiPropertyGroup.
	* @param[in] nLayerIndex - The Index of the MultiPropertyLayer queried
	* @return The MultiPropertyLayer with index LayerIndex within MultiPropertyGroup
	*/
	sMultiPropertyLayer CMultiPropertyGroup::GetLayer(const Lib3MF_uint32 nLayerIndex)
	{
		sMultiPropertyLayer resultTheLayer;
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_GetLayer(m_pHandle, nLayerIndex, &resultTheLayer));
		
		return resultTheLayer;
	}
	
	/**
	* CMultiPropertyGroup::RemoveLayer - Removes a MultiPropertyLayer from this MultiPropertyGroup.
	* @param[in] nLayerIndex - The Index of the MultiPropertyLayer to be removed
	*/
	void CMultiPropertyGroup::RemoveLayer(const Lib3MF_uint32 nLayerIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MultiPropertyGroup_RemoveLayer(m_pHandle, nLayerIndex));
	}
	
	/**
	 * Method definitions for class CAttachment
	 */
	
	/**
	* CAttachment::GetPath - Retrieves an attachment's package path. This function will be removed in a later release.
	* @return returns the attachment's package path string
	*/
	std::string CAttachment::GetPath()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_GetPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_GetPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CAttachment::SetPath - Sets an attachment's package path. This function will be removed in a later release.
	* @param[in] sPath - new path of the attachment.
	*/
	void CAttachment::SetPath(const std::string & sPath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_SetPath(m_pHandle, sPath.c_str()));
	}
	
	/**
	* CAttachment::PackagePart - Returns the PackagePart that is this attachment.
	* @return The PackagePart of this attachment.
	*/
	PPackagePart CAttachment::PackagePart()
	{
		Lib3MFHandle hPackagePart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_PackagePart(m_pHandle, &hPackagePart));
		
		if (!hPackagePart) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPackagePart>(dynamic_cast<CPackagePart*>(m_pWrapper->polymorphicFactory(hPackagePart)));
	}
	
	/**
	* CAttachment::GetRelationShipType - Retrieves an attachment's relationship type
	* @return returns the attachment's package relationship type string
	*/
	std::string CAttachment::GetRelationShipType()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_GetRelationShipType(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_GetRelationShipType(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CAttachment::SetRelationShipType - Sets an attachment's relationship type.
	* @param[in] sPath - new relationship type string.
	*/
	void CAttachment::SetRelationShipType(const std::string & sPath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_SetRelationShipType(m_pHandle, sPath.c_str()));
	}
	
	/**
	* CAttachment::WriteToFile - Writes out the attachment as file.
	* @param[in] sFileName - file to write into.
	*/
	void CAttachment::WriteToFile(const std::string & sFileName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_WriteToFile(m_pHandle, sFileName.c_str()));
	}
	
	/**
	* CAttachment::ReadFromFile - Reads an attachment from a file. The path of this file is only read when this attachment is being written as part of the 3MF package, or via the WriteToFile or WriteToBuffer-methods.
	* @param[in] sFileName - file to read from.
	*/
	void CAttachment::ReadFromFile(const std::string & sFileName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_ReadFromFile(m_pHandle, sFileName.c_str()));
	}
	
	/**
	* CAttachment::ReadFromCallback - Reads an attachment from the data provided by a callback function. This callback function is only invoked when this attachment is being written as part of the 3MF package, or via the WriteToFile or WriteToBuffer-methods.
	* @param[in] pTheReadCallback - Callback to call for reading a data chunk
	* @param[in] nStreamSize - number of bytes the callback returns
	* @param[in] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CAttachment::ReadFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_ReadFromCallback(m_pHandle, pTheReadCallback, nStreamSize, pTheSeekCallback, pUserData));
	}
	
	/**
	* CAttachment::GetStreamSize - Retrieves the size of the attachment stream
	* @return the stream size
	*/
	Lib3MF_uint64 CAttachment::GetStreamSize()
	{
		Lib3MF_uint64 resultStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_GetStreamSize(m_pHandle, &resultStreamSize));
		
		return resultStreamSize;
	}
	
	/**
	* CAttachment::WriteToBuffer - Writes out the attachment into a buffer
	* @param[out] BufferBuffer - Buffer to write into
	*/
	void CAttachment::WriteToBuffer(std::vector<Lib3MF_uint8> & BufferBuffer)
	{
		Lib3MF_uint64 elementsNeededBuffer = 0;
		Lib3MF_uint64 elementsWrittenBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_WriteToBuffer(m_pHandle, 0, &elementsNeededBuffer, nullptr));
		BufferBuffer.resize((size_t) elementsNeededBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_WriteToBuffer(m_pHandle, elementsNeededBuffer, &elementsWrittenBuffer, BufferBuffer.data()));
	}
	
	/**
	* CAttachment::ReadFromBuffer - Reads an attachment from a memory buffer. This buffer is immediatly read (in contrast to the ReadFromCallback and ReadFromFile-methods).
	* @param[in] BufferBuffer - Buffer to read from
	*/
	void CAttachment::ReadFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Attachment_ReadFromBuffer(m_pHandle, (Lib3MF_uint64)BufferBuffer.size(), BufferBuffer.data()));
	}
	
	/**
	 * Method definitions for class CTexture2D
	 */
	
	/**
	* CTexture2D::GetAttachment - Retrieves the attachment located at the path of the texture.
	* @return attachment that holds the texture's image information.
	*/
	PAttachment CTexture2D::GetAttachment()
	{
		Lib3MFHandle hAttachment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_GetAttachment(m_pHandle, &hAttachment));
		
		if (!hAttachment) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachment)));
	}
	
	/**
	* CTexture2D::SetAttachment - Sets the texture's package path to the path of the attachment.
	* @param[in] pAttachment - attachment that holds the texture's image information.
	*/
	void CTexture2D::SetAttachment(classParam<CAttachment> pAttachment)
	{
		Lib3MFHandle hAttachment = pAttachment.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_SetAttachment(m_pHandle, hAttachment));
	}
	
	/**
	* CTexture2D::GetContentType - Retrieves a texture's content type.
	* @return returns content type enum.
	*/
	eTextureType CTexture2D::GetContentType()
	{
		eTextureType resultContentType = (eTextureType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_GetContentType(m_pHandle, &resultContentType));
		
		return resultContentType;
	}
	
	/**
	* CTexture2D::SetContentType - Retrieves a texture's content type.
	* @param[in] eContentType - new Content Type
	*/
	void CTexture2D::SetContentType(const eTextureType eContentType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_SetContentType(m_pHandle, eContentType));
	}
	
	/**
	* CTexture2D::GetTileStyleUV - Retrieves a texture's tilestyle type.
	* @param[out] eTileStyleU - returns tilestyle type enum.
	* @param[out] eTileStyleV - returns tilestyle type enum.
	*/
	void CTexture2D::GetTileStyleUV(eTextureTileStyle & eTileStyleU, eTextureTileStyle & eTileStyleV)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_GetTileStyleUV(m_pHandle, &eTileStyleU, &eTileStyleV));
	}
	
	/**
	* CTexture2D::SetTileStyleUV - Sets a texture's tilestyle type.
	* @param[in] eTileStyleU - new tilestyle type enum.
	* @param[in] eTileStyleV - new tilestyle type enum.
	*/
	void CTexture2D::SetTileStyleUV(const eTextureTileStyle eTileStyleU, const eTextureTileStyle eTileStyleV)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_SetTileStyleUV(m_pHandle, eTileStyleU, eTileStyleV));
	}
	
	/**
	* CTexture2D::GetFilter - Retrieves a texture's filter type.
	* @return returns filter type enum.
	*/
	eTextureFilter CTexture2D::GetFilter()
	{
		eTextureFilter resultFilter = (eTextureFilter) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_GetFilter(m_pHandle, &resultFilter));
		
		return resultFilter;
	}
	
	/**
	* CTexture2D::SetFilter - Sets a texture's filter type.
	* @param[in] eFilter - sets new filter type enum.
	*/
	void CTexture2D::SetFilter(const eTextureFilter eFilter)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Texture2D_SetFilter(m_pHandle, eFilter));
	}
	
	/**
	 * Method definitions for class CBuildItem
	 */
	
	/**
	* CBuildItem::GetObjectResource - Retrieves the object resource associated to a build item
	* @return returns the associated resource instance
	*/
	PObject CBuildItem::GetObjectResource()
	{
		Lib3MFHandle hObjectResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetObjectResource(m_pHandle, &hObjectResource));
		
		if (!hObjectResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CObject>(dynamic_cast<CObject*>(m_pWrapper->polymorphicFactory(hObjectResource)));
	}
	
	/**
	* CBuildItem::GetUUID - returns, whether a build item has a UUID and, if true, the build item's UUID
	* @param[out] bHasUUID - flag whether the build item has a UUID
	* @return the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	std::string CBuildItem::GetUUID(bool & bHasUUID)
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetUUID(m_pHandle, &bHasUUID, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetUUID(m_pHandle, &bHasUUID, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildItem::SetUUID - sets the build item's UUID
	* @param[in] sUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	void CBuildItem::SetUUID(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_SetUUID(m_pHandle, sUUID.c_str()));
	}
	
	/**
	* CBuildItem::GetObjectResourceID - Retrieves the object UniqueResourceID associated to a build item
	* @return returns the UniqueResourceID of the object
	*/
	Lib3MF_uint32 CBuildItem::GetObjectResourceID()
	{
		Lib3MF_uint32 resultUniqueResourceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetObjectResourceID(m_pHandle, &resultUniqueResourceID));
		
		return resultUniqueResourceID;
	}
	
	/**
	* CBuildItem::HasObjectTransform - Checks, if a build item has a non-identity transformation matrix
	* @return returns true, if the transformation matrix is not the identity
	*/
	bool CBuildItem::HasObjectTransform()
	{
		bool resultHasTransform = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_HasObjectTransform(m_pHandle, &resultHasTransform));
		
		return resultHasTransform;
	}
	
	/**
	* CBuildItem::GetObjectTransform - Retrieves a build item's transformation matrix.
	* @return returns the transformation matrix
	*/
	sTransform CBuildItem::GetObjectTransform()
	{
		sTransform resultTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetObjectTransform(m_pHandle, &resultTransform));
		
		return resultTransform;
	}
	
	/**
	* CBuildItem::SetObjectTransform - Sets a build item's transformation matrix.
	* @param[in] Transform - new transformation matrix
	*/
	void CBuildItem::SetObjectTransform(const sTransform & Transform)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_SetObjectTransform(m_pHandle, &Transform));
	}
	
	/**
	* CBuildItem::GetPartNumber - Retrieves a build item's part number string
	* @return Returns a build item's part number string
	*/
	std::string CBuildItem::GetPartNumber()
	{
		Lib3MF_uint32 bytesNeededPartNumber = 0;
		Lib3MF_uint32 bytesWrittenPartNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetPartNumber(m_pHandle, 0, &bytesNeededPartNumber, nullptr));
		std::vector<char> bufferPartNumber(bytesNeededPartNumber);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetPartNumber(m_pHandle, bytesNeededPartNumber, &bytesWrittenPartNumber, &bufferPartNumber[0]));
		
		return std::string(&bufferPartNumber[0]);
	}
	
	/**
	* CBuildItem::SetPartNumber - Sets a build item's part number string
	* @param[in] sSetPartnumber - new part number string for referencing parts from the outside world
	*/
	void CBuildItem::SetPartNumber(const std::string & sSetPartnumber)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_SetPartNumber(m_pHandle, sSetPartnumber.c_str()));
	}
	
	/**
	* CBuildItem::GetMetaDataGroup - Returns the metadatagroup of this build item
	* @return returns an Instance of the metadatagroup of this build item
	*/
	PMetaDataGroup CBuildItem::GetMetaDataGroup()
	{
		Lib3MFHandle hMetaDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetMetaDataGroup(m_pHandle, &hMetaDataGroup));
		
		if (!hMetaDataGroup) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaDataGroup>(dynamic_cast<CMetaDataGroup*>(m_pWrapper->polymorphicFactory(hMetaDataGroup)));
	}
	
	/**
	* CBuildItem::GetOutbox - Returns the outbox of a build item
	* @return Outbox of this build item
	*/
	sBox CBuildItem::GetOutbox()
	{
		sBox resultOutbox;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItem_GetOutbox(m_pHandle, &resultOutbox));
		
		return resultOutbox;
	}
	
	/**
	 * Method definitions for class CBuildItemIterator
	 */
	
	/**
	* CBuildItemIterator::MoveNext - Iterates to the next build item in the list.
	* @return Iterates to the next build item in the list.
	*/
	bool CBuildItemIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItemIterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CBuildItemIterator::MovePrevious - Iterates to the previous build item in the list.
	* @return Iterates to the previous build item in the list.
	*/
	bool CBuildItemIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItemIterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CBuildItemIterator::GetCurrent - Returns the build item the iterator points at.
	* @return returns the build item instance.
	*/
	PBuildItem CBuildItemIterator::GetCurrent()
	{
		Lib3MFHandle hBuildItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItemIterator_GetCurrent(m_pHandle, &hBuildItem));
		
		if (!hBuildItem) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBuildItem>(dynamic_cast<CBuildItem*>(m_pWrapper->polymorphicFactory(hBuildItem)));
	}
	
	/**
	* CBuildItemIterator::Clone - Creates a new build item iterator with the same build item list.
	* @return returns the cloned Iterator instance
	*/
	PBuildItemIterator CBuildItemIterator::Clone()
	{
		Lib3MFHandle hOutBuildItemIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItemIterator_Clone(m_pHandle, &hOutBuildItemIterator));
		
		if (!hOutBuildItemIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBuildItemIterator>(dynamic_cast<CBuildItemIterator*>(m_pWrapper->polymorphicFactory(hOutBuildItemIterator)));
	}
	
	/**
	* CBuildItemIterator::Count - Returns the number of build items the iterator captures.
	* @return returns the number of build items the iterator captures.
	*/
	Lib3MF_uint64 CBuildItemIterator::Count()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildItemIterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CSlice
	 */
	
	/**
	* CSlice::SetVertices - Set all vertices of a slice. All polygons will be cleared.
	* @param[in] VerticesBuffer - contains the positions.
	*/
	void CSlice::SetVertices(const CInputVector<sPosition2D> & VerticesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_SetVertices(m_pHandle, (Lib3MF_uint64)VerticesBuffer.size(), VerticesBuffer.data()));
	}
	
	/**
	* CSlice::GetVertices - Get all vertices of a slice
	* @param[out] VerticesBuffer - contains the positions.
	*/
	void CSlice::GetVertices(std::vector<sPosition2D> & VerticesBuffer)
	{
		Lib3MF_uint64 elementsNeededVertices = 0;
		Lib3MF_uint64 elementsWrittenVertices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetVertices(m_pHandle, 0, &elementsNeededVertices, nullptr));
		VerticesBuffer.resize((size_t) elementsNeededVertices);
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetVertices(m_pHandle, elementsNeededVertices, &elementsWrittenVertices, VerticesBuffer.data()));
	}
	
	/**
	* CSlice::GetVertexCount - Get the number of vertices in a slice
	* @return the number of vertices in the slice
	*/
	Lib3MF_uint64 CSlice::GetVertexCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetVertexCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CSlice::AddPolygon - Add a new polygon to this slice
	* @param[in] IndicesBuffer - the new indices of the new polygon
	* @return the index of the new polygon
	*/
	Lib3MF_uint64 CSlice::AddPolygon(const CInputVector<Lib3MF_uint32> & IndicesBuffer)
	{
		Lib3MF_uint64 resultIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_AddPolygon(m_pHandle, (Lib3MF_uint64)IndicesBuffer.size(), IndicesBuffer.data(), &resultIndex));
		
		return resultIndex;
	}
	
	/**
	* CSlice::GetPolygonCount - Get the number of polygons in the slice
	* @return the number of polygons in the slice
	*/
	Lib3MF_uint64 CSlice::GetPolygonCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetPolygonCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CSlice::SetPolygonIndices - Set all indices of a polygon
	* @param[in] nIndex - the index of the polygon to manipulate
	* @param[in] IndicesBuffer - the new indices of the index-th polygon
	*/
	void CSlice::SetPolygonIndices(const Lib3MF_uint64 nIndex, const CInputVector<Lib3MF_uint32> & IndicesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_SetPolygonIndices(m_pHandle, nIndex, (Lib3MF_uint64)IndicesBuffer.size(), IndicesBuffer.data()));
	}
	
	/**
	* CSlice::GetPolygonIndices - Get all vertices of a slice
	* @param[in] nIndex - the index of the polygon to manipulate
	* @param[out] IndicesBuffer - the indices of the index-th polygon 
	*/
	void CSlice::GetPolygonIndices(const Lib3MF_uint64 nIndex, std::vector<Lib3MF_uint32> & IndicesBuffer)
	{
		Lib3MF_uint64 elementsNeededIndices = 0;
		Lib3MF_uint64 elementsWrittenIndices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetPolygonIndices(m_pHandle, nIndex, 0, &elementsNeededIndices, nullptr));
		IndicesBuffer.resize((size_t) elementsNeededIndices);
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetPolygonIndices(m_pHandle, nIndex, elementsNeededIndices, &elementsWrittenIndices, IndicesBuffer.data()));
	}
	
	/**
	* CSlice::GetPolygonIndexCount - Get the number of vertices in a slice
	* @param[in] nIndex - the index of the polygon to manipulate
	* @return the number of indices of the index-th polygon
	*/
	Lib3MF_uint64 CSlice::GetPolygonIndexCount(const Lib3MF_uint64 nIndex)
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetPolygonIndexCount(m_pHandle, nIndex, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CSlice::GetZTop - Get the upper Z-Coordinate of this slice.
	* @return the upper Z-Coordinate of this slice
	*/
	Lib3MF_double CSlice::GetZTop()
	{
		Lib3MF_double resultZTop = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Slice_GetZTop(m_pHandle, &resultZTop));
		
		return resultZTop;
	}
	
	/**
	 * Method definitions for class CToolpathProfile
	 */
	
	/**
	* CToolpathProfile::GetUUID - Retrieves the profile's uuid
	* @return Returns the uuid value.
	*/
	std::string CToolpathProfile::GetUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathProfile::GetName - Retrieves the profile's name
	* @return Returns the name.
	*/
	std::string CToolpathProfile::GetName()
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CToolpathProfile::GetParameterCount - Returns the number of parameters.
	* @return Returns the number of parameters.
	*/
	Lib3MF_uint32 CToolpathProfile::GetParameterCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpathProfile::GetParameterName - Returns the Name of a parameter.
	* @param[in] nIndex - Index of Parameter (0-based). Call will fail if an invalid index is given.
	* @return Returns the name of the parameter.
	*/
	std::string CToolpathProfile::GetParameterName(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 bytesNeededName = 0;
		Lib3MF_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterName(m_pHandle, nIndex, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterName(m_pHandle, nIndex, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CToolpathProfile::GetParameterNameSpace - Returns the NameSpace of a parameter.
	* @param[in] nIndex - Index of Parameter (0-based). Call will fail if an invalid index is given.
	* @return Returns the namespace of the parameter.
	*/
	std::string CToolpathProfile::GetParameterNameSpace(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterNameSpace(m_pHandle, nIndex, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterNameSpace(m_pHandle, nIndex, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CToolpathProfile::HasParameterValue - Checks if a parameter value exists.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @return Returns if a value exists.
	*/
	bool CToolpathProfile::HasParameterValue(const std::string & sNameSpaceName, const std::string & sValueName)
	{
		bool resultValueExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_HasParameterValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), &resultValueExists));
		
		return resultValueExists;
	}
	
	/**
	* CToolpathProfile::GetParameterValue - Retrieves a profile's parameter value. Fails if value does not exist.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @return Returns the value of the field.
	*/
	std::string CToolpathProfile::GetParameterValue(const std::string & sNameSpaceName, const std::string & sValueName)
	{
		Lib3MF_uint32 bytesNeededValue = 0;
		Lib3MF_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CToolpathProfile::GetParameterValueDef - Retrieves a profile's parameter value
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] sDefaultValue - Default value if value does not exist.
	* @return Returns the value of the field.
	*/
	std::string CToolpathProfile::GetParameterValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const std::string & sDefaultValue)
	{
		Lib3MF_uint32 bytesNeededValue = 0;
		Lib3MF_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterValueDef(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), sDefaultValue.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterValueDef(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), sDefaultValue.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CToolpathProfile::GetParameterDoubleValue - Retrieves a profile's parameter value as double. Fails if value does not exist or is not a double value.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @return Returns the value of the field.
	*/
	Lib3MF_double CToolpathProfile::GetParameterDoubleValue(const std::string & sNameSpaceName, const std::string & sValueName)
	{
		Lib3MF_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterDoubleValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::GetParameterDoubleValueDef - Retrieves a profile's parameter value as double.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] dDefaultValue - Default value if value does not exist or is not a double value.
	* @return Returns the value of the field.
	*/
	Lib3MF_double CToolpathProfile::GetParameterDoubleValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_double dDefaultValue)
	{
		Lib3MF_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterDoubleValueDef(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), dDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::GetParameterIntegerValue - Retrieves a profile's parameter value as integer. Fails if value does not exist or is not a integer value.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @return Returns the value of the field.
	*/
	Lib3MF_int64 CToolpathProfile::GetParameterIntegerValue(const std::string & sNameSpaceName, const std::string & sValueName)
	{
		Lib3MF_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterIntegerValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::GetParameterIntegerValueDef - Retrieves a profile's parameter value as integer.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] nDefaultValue - Default value if value does not exist or is not a integer value.
	* @return Returns the value of the field.
	*/
	Lib3MF_int64 CToolpathProfile::GetParameterIntegerValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_int64 nDefaultValue)
	{
		Lib3MF_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterIntegerValueDef(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), nDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::GetParameterBoolValue - Retrieves a profile's parameter value as boolean. Fails if value does not exist or is not a boolean value.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @return Returns the value of the field.
	*/
	bool CToolpathProfile::GetParameterBoolValue(const std::string & sNameSpaceName, const std::string & sValueName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterBoolValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::GetParameterBoolValueDef - Retrieves a profile's parameter value as boolean.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] bDefaultValue - Default value if value does not exist or is not a boolean value.
	* @return Returns the value of the field.
	*/
	bool CToolpathProfile::GetParameterBoolValueDef(const std::string & sNameSpaceName, const std::string & sValueName, const bool bDefaultValue)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_GetParameterBoolValueDef(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), bDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathProfile::SetName - Sets the profile's name
	* @param[in] sName - Returns the name.
	*/
	void CToolpathProfile::SetName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_SetName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CToolpathProfile::SetParameterValue - Sets a profile's parameter value.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] sValue - String value of the parameter.
	*/
	void CToolpathProfile::SetParameterValue(const std::string & sNameSpaceName, const std::string & sValueName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_SetParameterValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), sValue.c_str()));
	}
	
	/**
	* CToolpathProfile::SetParameterDoubleValue - Sets a profile's parameter value as double.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] dValue - Double value of the parameter.
	*/
	void CToolpathProfile::SetParameterDoubleValue(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_SetParameterDoubleValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), dValue));
	}
	
	/**
	* CToolpathProfile::SetParameterIntegerValue - Sets a profile's parameter value as integer.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] nValue - Integer value of the parameter.
	*/
	void CToolpathProfile::SetParameterIntegerValue(const std::string & sNameSpaceName, const std::string & sValueName, const Lib3MF_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_SetParameterIntegerValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), nValue));
	}
	
	/**
	* CToolpathProfile::SetParameterBoolValue - Sets a profile's parameter value as boolean.
	* @param[in] sNameSpaceName - Name of the Parameter Namespace.
	* @param[in] sValueName - Value key string.
	* @param[in] bValue - Boolean value of the parameter.
	*/
	void CToolpathProfile::SetParameterBoolValue(const std::string & sNameSpaceName, const std::string & sValueName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathProfile_SetParameterBoolValue(m_pHandle, sNameSpaceName.c_str(), sValueName.c_str(), bValue));
	}
	
	/**
	 * Method definitions for class CToolpathLayerReader
	 */
	
	/**
	* CToolpathLayerReader::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	std::string CToolpathLayerReader::GetLayerDataUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetLayerDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetLayerDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathLayerReader::GetSegmentCount - Retrieves the count of segments.
	* @return Count
	*/
	Lib3MF_uint32 CToolpathLayerReader::GetSegmentCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpathLayerReader::GetSegmentInfo - Retrieves the segment type information .
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] eType - Segment Type
	* @param[out] nPointCount - Point count of segment.
	*/
	void CToolpathLayerReader::GetSegmentInfo(const Lib3MF_uint32 nIndex, eToolpathSegmentType & eType, Lib3MF_uint32 & nPointCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentInfo(m_pHandle, nIndex, &eType, &nPointCount));
	}
	
	/**
	* CToolpathLayerReader::GetSegmentProfile - Retrieves the assigned segment profile.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile
	*/
	PToolpathProfile CToolpathLayerReader::GetSegmentProfile(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hProfile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentProfile(m_pHandle, nIndex, &hProfile));
		
		if (!hProfile) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathProfile>(dynamic_cast<CToolpathProfile*>(m_pWrapper->polymorphicFactory(hProfile)));
	}
	
	/**
	* CToolpathLayerReader::GetSegmentProfileUUID - Retrieves the assigned segment profile uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile UUID
	*/
	std::string CToolpathLayerReader::GetSegmentProfileUUID(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 bytesNeededProfileUUID = 0;
		Lib3MF_uint32 bytesWrittenProfileUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentProfileUUID(m_pHandle, nIndex, 0, &bytesNeededProfileUUID, nullptr));
		std::vector<char> bufferProfileUUID(bytesNeededProfileUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentProfileUUID(m_pHandle, nIndex, bytesNeededProfileUUID, &bytesWrittenProfileUUID, &bufferProfileUUID[0]));
		
		return std::string(&bufferProfileUUID[0]);
	}
	
	/**
	* CToolpathLayerReader::GetSegmentPart - Retrieves the assigned segment profile.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Build Item
	*/
	PBuildItem CToolpathLayerReader::GetSegmentPart(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hBuildItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentPart(m_pHandle, nIndex, &hBuildItem));
		
		if (!hBuildItem) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBuildItem>(dynamic_cast<CBuildItem*>(m_pWrapper->polymorphicFactory(hBuildItem)));
	}
	
	/**
	* CToolpathLayerReader::GetSegmentPartUUID - Retrieves the assigned segment part uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Part UUID
	*/
	std::string CToolpathLayerReader::GetSegmentPartUUID(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 bytesNeededPartUUID = 0;
		Lib3MF_uint32 bytesWrittenPartUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentPartUUID(m_pHandle, nIndex, 0, &bytesNeededPartUUID, nullptr));
		std::vector<char> bufferPartUUID(bytesNeededPartUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentPartUUID(m_pHandle, nIndex, bytesNeededPartUUID, &bytesWrittenPartUUID, &bufferPartUUID[0]));
		
		return std::string(&bufferPartUUID[0]);
	}
	
	/**
	* CToolpathLayerReader::GetSegmentPointData - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] PointDataBuffer - The point data array
	*/
	void CToolpathLayerReader::GetSegmentPointData(const Lib3MF_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer)
	{
		Lib3MF_uint64 elementsNeededPointData = 0;
		Lib3MF_uint64 elementsWrittenPointData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentPointData(m_pHandle, nIndex, 0, &elementsNeededPointData, nullptr));
		PointDataBuffer.resize((size_t) elementsNeededPointData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentPointData(m_pHandle, nIndex, elementsNeededPointData, &elementsWrittenPointData, PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayerReader::FindAttributeInfoByName - Retrieves a segment attribute Information by Attribute Name. Will fail if Attribute does not exist.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @param[out] nID - Attribute ID.
	* @param[out] eAttributeType - Attribute Type.
	*/
	void CToolpathLayerReader::FindAttributeInfoByName(const std::string & sNameSpace, const std::string & sAttributeName, Lib3MF_uint32 & nID, eToolpathAttributeType & eAttributeType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_FindAttributeInfoByName(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), &nID, &eAttributeType));
	}
	
	/**
	* CToolpathLayerReader::FindAttributeIDByName - Retrieves a segment attribute ID by Attribute Name. Will fail if Attribute does not exist.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @return Attribute ID.
	*/
	Lib3MF_uint32 CToolpathLayerReader::FindAttributeIDByName(const std::string & sNameSpace, const std::string & sAttributeName)
	{
		Lib3MF_uint32 resultID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_FindAttributeIDByName(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), &resultID));
		
		return resultID;
	}
	
	/**
	* CToolpathLayerReader::FindAttributeValueByName - Retrieves a segment attribute Type by Attribute Name. Will fail if Attribute does not exist.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @return Attribute Type.
	*/
	eToolpathAttributeType CToolpathLayerReader::FindAttributeValueByName(const std::string & sNameSpace, const std::string & sAttributeName)
	{
		eToolpathAttributeType resultAttributeType = (eToolpathAttributeType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_FindAttributeValueByName(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), &resultAttributeType));
		
		return resultAttributeType;
	}
	
	/**
	* CToolpathLayerReader::GetSegmentIntegerAttributeByID - Retrieves a segment Uint32 attribute by Attribute ID. Will fail if Attribute does not exist.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nID - Attribute ID.
	* @return Attribute Value.
	*/
	Lib3MF_int64 CToolpathLayerReader::GetSegmentIntegerAttributeByID(const Lib3MF_uint32 nIndex, const Lib3MF_uint32 nID)
	{
		Lib3MF_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentIntegerAttributeByID(m_pHandle, nIndex, nID, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayerReader::GetSegmentIntegerAttributeByName - Retrieves a segment integer attribute by Attribute Name. Will fail if Attribute does not exist or is of different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @return Attribute Value.
	*/
	Lib3MF_int64 CToolpathLayerReader::GetSegmentIntegerAttributeByName(const Lib3MF_uint32 nIndex, const std::string & sNameSpace, const std::string & sAttributeName)
	{
		Lib3MF_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentIntegerAttributeByName(m_pHandle, nIndex, sNameSpace.c_str(), sAttributeName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayerReader::GetSegmentDoubleAttributeByID - Retrieves a segment Double attribute by Attribute ID. Will fail if Attribute does not exist.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nID - Attribute ID.
	* @return Attribute Value.
	*/
	Lib3MF_double CToolpathLayerReader::GetSegmentDoubleAttributeByID(const Lib3MF_uint32 nIndex, const Lib3MF_uint32 nID)
	{
		Lib3MF_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentDoubleAttributeByID(m_pHandle, nIndex, nID, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayerReader::GetSegmentDoubleAttributeByName - Retrieves a segment Double attribute by Attribute Name. Will fail if Attribute does not exist.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @return Attribute Value.
	*/
	Lib3MF_double CToolpathLayerReader::GetSegmentDoubleAttributeByName(const Lib3MF_uint32 nIndex, const std::string & sNameSpace, const std::string & sAttributeName)
	{
		Lib3MF_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetSegmentDoubleAttributeByName(m_pHandle, nIndex, sNameSpace.c_str(), sAttributeName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayerReader::GetCustomDataCount - Retrieves the count of custom data elements.
	* @return Count
	*/
	Lib3MF_uint32 CToolpathLayerReader::GetCustomDataCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetCustomDataCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpathLayerReader::GetCustomData - Retrieves the custom data.
	* @param[in] nIndex - Index of the Custom Data. 0-based. MUST be smaller than Data Count
	* @return DOM Tree of the data.
	*/
	PCustomDOMTree CToolpathLayerReader::GetCustomData(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetCustomData(m_pHandle, nIndex, &hData));
		
		if (!hData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomDOMTree>(dynamic_cast<CCustomDOMTree*>(m_pWrapper->polymorphicFactory(hData)));
	}
	
	/**
	* CToolpathLayerReader::GetCustomDataName - Retrieves the node name of the custom data.
	* @param[in] nIndex - Index of the Custom Data. 0-based. MUST be smaller than Data Count
	* @param[out] sNameSpace - Namespace of the custom data tree.
	* @param[out] sDataName - Root name of the data tree.
	*/
	void CToolpathLayerReader::GetCustomDataName(const Lib3MF_uint32 nIndex, std::string & sNameSpace, std::string & sDataName)
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		Lib3MF_uint32 bytesNeededDataName = 0;
		Lib3MF_uint32 bytesWrittenDataName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetCustomDataName(m_pHandle, nIndex, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededDataName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferDataName(bytesNeededDataName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerReader_GetCustomDataName(m_pHandle, nIndex, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededDataName, &bytesWrittenDataName, &bufferDataName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sDataName = std::string(&bufferDataName[0]);
	}
	
	/**
	 * Method definitions for class CToolpathLayerData
	 */
	
	/**
	* CToolpathLayerData::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	std::string CToolpathLayerData::GetLayerDataUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_GetLayerDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_GetLayerDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathLayerData::RegisterProfile - Registers a toolpath profile
	* @param[in] pProfile - The toolpath profile to register.
	* @return returns the local profile ID for the layer.
	*/
	Lib3MF_uint32 CToolpathLayerData::RegisterProfile(classParam<CToolpathProfile> pProfile)
	{
		Lib3MFHandle hProfile = pProfile.GetHandle();
		Lib3MF_uint32 resultProfileID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_RegisterProfile(m_pHandle, hProfile, &resultProfileID));
		
		return resultProfileID;
	}
	
	/**
	* CToolpathLayerData::RegisterBuildItem - Registers a Model Build Item
	* @param[in] pBuildItem - The model build item to use.
	* @return returns the local part ID for the layer.
	*/
	Lib3MF_uint32 CToolpathLayerData::RegisterBuildItem(classParam<CBuildItem> pBuildItem)
	{
		Lib3MFHandle hBuildItem = pBuildItem.GetHandle();
		Lib3MF_uint32 resultPartID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_RegisterBuildItem(m_pHandle, hBuildItem, &resultPartID));
		
		return resultPartID;
	}
	
	/**
	* CToolpathLayerData::SetSegmentAttribute - Sets Segment Attribute for all following segments that are added. Overrides previously set attribute.
	* @param[in] sNameSpace - The namespace of the attribute to register.
	* @param[in] sAttributeName - The name of the attribute to register.
	* @param[in] sValue - The value of the attribute to register.
	*/
	void CToolpathLayerData::SetSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_SetSegmentAttribute(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), sValue.c_str()));
	}
	
	/**
	* CToolpathLayerData::ClearSegmentAttributes - Clears current segment attributes.
	*/
	void CToolpathLayerData::ClearSegmentAttributes()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_ClearSegmentAttributes(m_pHandle));
	}
	
	/**
	* CToolpathLayerData::WriteHatchData - writes hatch data to the layer.
	* @param[in] nProfileID - The toolpath profile to use
	* @param[in] nPartID - The toolpath part to use
	* @param[in] PointDataBuffer - The point data
	*/
	void CToolpathLayerData::WriteHatchData(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_WriteHatchData(m_pHandle, nProfileID, nPartID, (Lib3MF_uint64)PointDataBuffer.size(), PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayerData::WriteLoop - writes loop data to the layer.
	* @param[in] nProfileID - The toolpath profile to use
	* @param[in] nPartID - The toolpath part to use
	* @param[in] PointDataBuffer - The point data
	*/
	void CToolpathLayerData::WriteLoop(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_WriteLoop(m_pHandle, nProfileID, nPartID, (Lib3MF_uint64)PointDataBuffer.size(), PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayerData::WritePolyline - writes polyline data to the layer.
	* @param[in] nProfileID - The toolpath profile to use
	* @param[in] nPartID - The toolpath part to use
	* @param[in] PointDataBuffer - The point data
	*/
	void CToolpathLayerData::WritePolyline(const Lib3MF_uint32 nProfileID, const Lib3MF_uint32 nPartID, const CInputVector<sPosition2D> & PointDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_WritePolyline(m_pHandle, nProfileID, nPartID, (Lib3MF_uint64)PointDataBuffer.size(), PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayerData::AddCustomData - Adds a custom data DOM tree to the layer. Layer MUST not be finished when changing the DOM tree.
	* @param[in] sNameSpace - Namespace of the custom data tree. MUST not be empty.
	* @param[in] sDataName - Root name of the data tree. MUST not be empty. MUST be a valid XML name string.
	* @return DOM Tree of the data.
	*/
	PCustomDOMTree CToolpathLayerData::AddCustomData(const std::string & sNameSpace, const std::string & sDataName)
	{
		Lib3MFHandle hData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_AddCustomData(m_pHandle, sNameSpace.c_str(), sDataName.c_str(), &hData));
		
		if (!hData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomDOMTree>(dynamic_cast<CCustomDOMTree*>(m_pWrapper->polymorphicFactory(hData)));
	}
	
	/**
	* CToolpathLayerData::Finish - finishes all writing of the layer and compresses toolpath data.
	*/
	void CToolpathLayerData::Finish()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayerData_Finish(m_pHandle));
	}
	
	/**
	 * Method definitions for class CToolpath
	 */
	
	/**
	* CToolpath::GetUnits - Retrieves the unit factor
	* @return Returns the unit factor.
	*/
	Lib3MF_double CToolpath::GetUnits()
	{
		Lib3MF_double resultUnits = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetUnits(m_pHandle, &resultUnits));
		
		return resultUnits;
	}
	
	/**
	* CToolpath::GetLayerCount - Retrieves the count of layers
	* @return Returns the layer count
	*/
	Lib3MF_uint32 CToolpath::GetLayerCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpath::GetProfileCount - Retrieves the count of profiles
	* @return Returns the profile count
	*/
	Lib3MF_uint32 CToolpath::GetProfileCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetProfileCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpath::AddLayer - Adds a new toolpath layer
	* @param[in] nZMax - ZMax value
	* @param[in] sPath - Package Path
	* @param[in] pModelWriter - The model writer that writes out the 3MF.
	* @return Returns the layerdata object to write the layer content into.
	*/
	PToolpathLayerData CToolpath::AddLayer(const Lib3MF_uint32 nZMax, const std::string & sPath, classParam<CWriter> pModelWriter)
	{
		Lib3MFHandle hModelWriter = pModelWriter.GetHandle();
		Lib3MFHandle hLayerData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_AddLayer(m_pHandle, nZMax, sPath.c_str(), hModelWriter, &hLayerData));
		
		if (!hLayerData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathLayerData>(dynamic_cast<CToolpathLayerData*>(m_pWrapper->polymorphicFactory(hLayerData)));
	}
	
	/**
	* CToolpath::GetLayerAttachment - Retrieves the Attachment of a layer
	* @param[in] nIndex - Layer Index
	* @return Attachment
	*/
	PAttachment CToolpath::GetLayerAttachment(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hAttachment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerAttachment(m_pHandle, nIndex, &hAttachment));
		
		if (!hAttachment) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachment)));
	}
	
	/**
	* CToolpath::ReadLayerData - Reads the toolpath of a layer.
	* @param[in] nIndex - Layer Index
	* @return Toolpath Reader Instance
	*/
	PToolpathLayerReader CToolpath::ReadLayerData(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hToolpathReader = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_ReadLayerData(m_pHandle, nIndex, &hToolpathReader));
		
		if (!hToolpathReader) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathLayerReader>(dynamic_cast<CToolpathLayerReader*>(m_pWrapper->polymorphicFactory(hToolpathReader)));
	}
	
	/**
	* CToolpath::GetLayerPath - Retrieves the Path of a layer
	* @param[in] nIndex - Layer Index
	* @return Package Path
	*/
	std::string CToolpath::GetLayerPath(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerPath(m_pHandle, nIndex, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerPath(m_pHandle, nIndex, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CToolpath::GetLayerZMax - Retrieves the ZMax of a layer
	* @param[in] nIndex - Layer Index
	* @return ZMax value
	*/
	Lib3MF_uint32 CToolpath::GetLayerZMax(const Lib3MF_uint32 nIndex)
	{
		Lib3MF_uint32 resultZMax = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerZMax(m_pHandle, nIndex, &resultZMax));
		
		return resultZMax;
	}
	
	/**
	* CToolpath::GetLayerZ - Return the z value of a layer in units.
	* @param[in] nLayerIndex - Layer Index.
	* @return Z Value in Units.
	*/
	Lib3MF_uint32 CToolpath::GetLayerZ(const Lib3MF_uint32 nLayerIndex)
	{
		Lib3MF_uint32 resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetLayerZ(m_pHandle, nLayerIndex, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpath::AddProfile - Adds a new profile to the toolpath.
	* @param[in] sName - the name.
	* @return Returns the profile.
	*/
	PToolpathProfile CToolpath::AddProfile(const std::string & sName)
	{
		Lib3MFHandle hProfile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_AddProfile(m_pHandle, sName.c_str(), &hProfile));
		
		if (!hProfile) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathProfile>(dynamic_cast<CToolpathProfile*>(m_pWrapper->polymorphicFactory(hProfile)));
	}
	
	/**
	* CToolpath::GetProfile - Returns a profile of the toolpath.
	* @param[in] nProfileIndex - Layer Index.
	* @return Returns the profile.
	*/
	PToolpathProfile CToolpath::GetProfile(const Lib3MF_uint32 nProfileIndex)
	{
		Lib3MFHandle hProfile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetProfile(m_pHandle, nProfileIndex, &hProfile));
		
		if (!hProfile) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathProfile>(dynamic_cast<CToolpathProfile*>(m_pWrapper->polymorphicFactory(hProfile)));
	}
	
	/**
	* CToolpath::GetProfileUUID - Returns a profile of the toolpath by UUID.
	* @param[in] sProfileUUID - UUID string.
	* @return Returns the profile.
	*/
	PToolpathProfile CToolpath::GetProfileUUID(const std::string & sProfileUUID)
	{
		Lib3MFHandle hProfile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetProfileUUID(m_pHandle, sProfileUUID.c_str(), &hProfile));
		
		if (!hProfile) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathProfile>(dynamic_cast<CToolpathProfile*>(m_pWrapper->polymorphicFactory(hProfile)));
	}
	
	/**
	* CToolpath::GetCustomDataCount - Retrieves the count of custom data elements.
	* @return Count
	*/
	Lib3MF_uint32 CToolpath::GetCustomDataCount()
	{
		Lib3MF_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetCustomDataCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpath::GetCustomData - Retrieves the custom data.
	* @param[in] nIndex - Index of the Custom Data. 0-based. MUST be smaller than Data Count
	* @return DOM Tree of the data.
	*/
	PCustomDOMTree CToolpath::GetCustomData(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetCustomData(m_pHandle, nIndex, &hData));
		
		if (!hData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomDOMTree>(dynamic_cast<CCustomDOMTree*>(m_pWrapper->polymorphicFactory(hData)));
	}
	
	/**
	* CToolpath::GetCustomDataName - Retrieves the node name of the custom data.
	* @param[in] nIndex - Index of the Custom Data. 0-based. MUST be smaller than Data Count
	* @param[out] sNameSpace - Namespace of the custom data tree.
	* @param[out] sDataName - Root name of the data tree.
	*/
	void CToolpath::GetCustomDataName(const Lib3MF_uint32 nIndex, std::string & sNameSpace, std::string & sDataName)
	{
		Lib3MF_uint32 bytesNeededNameSpace = 0;
		Lib3MF_uint32 bytesWrittenNameSpace = 0;
		Lib3MF_uint32 bytesNeededDataName = 0;
		Lib3MF_uint32 bytesWrittenDataName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetCustomDataName(m_pHandle, nIndex, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededDataName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferDataName(bytesNeededDataName);
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_GetCustomDataName(m_pHandle, nIndex, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededDataName, &bytesWrittenDataName, &bufferDataName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sDataName = std::string(&bufferDataName[0]);
	}
	
	/**
	* CToolpath::HasUniqueCustomData - Retrieves if custom data with a specific namespace and name combination exists.
	* @param[in] sNameSpace - Namespace of the custom data tree.
	* @param[in] sDataName - Root name of the data tree.
	* @return Returns true if DOM Tree Exists.
	*/
	bool CToolpath::HasUniqueCustomData(const std::string & sNameSpace, const std::string & sDataName)
	{
		bool resultCustomDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_HasUniqueCustomData(m_pHandle, sNameSpace.c_str(), sDataName.c_str(), &resultCustomDataExists));
		
		return resultCustomDataExists;
	}
	
	/**
	* CToolpath::FindUniqueCustomData - Retrieves the custom data with a specific namespace and name combination. Fails if combination is not unique.
	* @param[in] sNameSpace - Namespace of the custom data tree.
	* @param[in] sDataName - Root name of the data tree.
	* @return DOM Tree of the data.
	*/
	PCustomDOMTree CToolpath::FindUniqueCustomData(const std::string & sNameSpace, const std::string & sDataName)
	{
		Lib3MFHandle hData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_FindUniqueCustomData(m_pHandle, sNameSpace.c_str(), sDataName.c_str(), &hData));
		
		if (!hData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomDOMTree>(dynamic_cast<CCustomDOMTree*>(m_pWrapper->polymorphicFactory(hData)));
	}
	
	/**
	* CToolpath::AddCustomData - Adds a custom data DOM tree to the toolpath.
	* @param[in] sNameSpace - Namespace of the custom data tree. MUST not be empty.
	* @param[in] sDataName - Root name of the data tree. MUST not be empty. MUST be a valid XML name string.
	* @return DOM Tree of the data.
	*/
	PCustomDOMTree CToolpath::AddCustomData(const std::string & sNameSpace, const std::string & sDataName)
	{
		Lib3MFHandle hData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_AddCustomData(m_pHandle, sNameSpace.c_str(), sDataName.c_str(), &hData));
		
		if (!hData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCustomDOMTree>(dynamic_cast<CCustomDOMTree*>(m_pWrapper->polymorphicFactory(hData)));
	}
	
	/**
	* CToolpath::ClearCustomData - Deletes all custom data.
	* @return Returns number of deleted items.
	*/
	Lib3MF_uint32 CToolpath::ClearCustomData()
	{
		Lib3MF_uint32 resultNumberOfDeletedItems = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_ClearCustomData(m_pHandle, &resultNumberOfDeletedItems));
		
		return resultNumberOfDeletedItems;
	}
	
	/**
	* CToolpath::DeleteCustomData - Deletes a custom data instance from the list.
	* @param[in] pData - DOM Tree of the data.
	* @return Returns if deletion was successful.
	*/
	bool CToolpath::DeleteCustomData(classParam<CCustomDOMTree> pData)
	{
		Lib3MFHandle hData = pData.GetHandle();
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_DeleteCustomData(m_pHandle, hData, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CToolpath::RegisterCustomIntegerAttribute - Registers an Integer Attribute that each segment holds.
	* @param[in] sNameSpace - Namespace of the custom data tree. MUST not be empty.
	* @param[in] sAttributeName - Attribute name. MUST not be empty.
	*/
	void CToolpath::RegisterCustomIntegerAttribute(const std::string & sNameSpace, const std::string & sAttributeName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_RegisterCustomIntegerAttribute(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str()));
	}
	
	/**
	* CToolpath::RegisterCustomDoubleAttribute - Registers a Double Attribute that each segment holds. Registering only applies to reader or writer objects created after the call.
	* @param[in] sNameSpace - Namespace of the custom data tree. MUST not be empty.
	* @param[in] sAttributeName - Attribute name. MUST not be empty.
	*/
	void CToolpath::RegisterCustomDoubleAttribute(const std::string & sNameSpace, const std::string & sAttributeName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Toolpath_RegisterCustomDoubleAttribute(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str()));
	}
	
	/**
	 * Method definitions for class CToolpathIterator
	 */
	
	/**
	* CToolpathIterator::GetCurrentToolpath - Returns the Toolpath the iterator points at.
	* @return returns the Toolpath instance.
	*/
	PToolpath CToolpathIterator::GetCurrentToolpath()
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathIterator_GetCurrentToolpath(m_pHandle, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpath>(dynamic_cast<CToolpath*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	 * Method definitions for class CSliceStack
	 */
	
	/**
	* CSliceStack::GetBottomZ - Get the lower Z-Coordinate of the slice stack.
	* @return the lower Z-Coordinate the slice stack
	*/
	Lib3MF_double CSliceStack::GetBottomZ()
	{
		Lib3MF_double resultZBottom = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetBottomZ(m_pHandle, &resultZBottom));
		
		return resultZBottom;
	}
	
	/**
	* CSliceStack::GetSliceCount - Returns the number of slices
	* @return the number of slices
	*/
	Lib3MF_uint64 CSliceStack::GetSliceCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetSliceCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CSliceStack::GetSlice - Query a slice from the slice stack
	* @param[in] nSliceIndex - the index of the slice
	* @return the Slice instance
	*/
	PSlice CSliceStack::GetSlice(const Lib3MF_uint64 nSliceIndex)
	{
		Lib3MFHandle hTheSlice = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetSlice(m_pHandle, nSliceIndex, &hTheSlice));
		
		if (!hTheSlice) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSlice>(dynamic_cast<CSlice*>(m_pWrapper->polymorphicFactory(hTheSlice)));
	}
	
	/**
	* CSliceStack::AddSlice - Returns the number of slices
	* @param[in] dZTop - upper Z coordinate of the slice
	* @return a new Slice instance
	*/
	PSlice CSliceStack::AddSlice(const Lib3MF_double dZTop)
	{
		Lib3MFHandle hTheSlice = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_AddSlice(m_pHandle, dZTop, &hTheSlice));
		
		if (!hTheSlice) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSlice>(dynamic_cast<CSlice*>(m_pWrapper->polymorphicFactory(hTheSlice)));
	}
	
	/**
	* CSliceStack::GetSliceRefCount - Returns the number of slice refs
	* @return the number of slicereferences
	*/
	Lib3MF_uint64 CSliceStack::GetSliceRefCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetSliceRefCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CSliceStack::AddSliceStackReference - Adds another existing slicestack as sliceref in this slicestack
	* @param[in] pTheSliceStack - the slicestack to use as sliceref
	*/
	void CSliceStack::AddSliceStackReference(classParam<CSliceStack> pTheSliceStack)
	{
		Lib3MFHandle hTheSliceStack = pTheSliceStack.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_AddSliceStackReference(m_pHandle, hTheSliceStack));
	}
	
	/**
	* CSliceStack::GetSliceStackReference - Adds another existing slicestack as sliceref in this slicestack
	* @param[in] nSliceRefIndex - the index of the slice ref
	* @return the slicestack that is used as sliceref
	*/
	PSliceStack CSliceStack::GetSliceStackReference(const Lib3MF_uint64 nSliceRefIndex)
	{
		Lib3MFHandle hTheSliceStack = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetSliceStackReference(m_pHandle, nSliceRefIndex, &hTheSliceStack));
		
		if (!hTheSliceStack) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStack>(dynamic_cast<CSliceStack*>(m_pWrapper->polymorphicFactory(hTheSliceStack)));
	}
	
	/**
	* CSliceStack::CollapseSliceReferences - Removes the indirection of slices via slice-refs, i.e. creates the slices of all slice refs of this SliceStack as actual slices of this SliceStack. All previously existing slices or slicerefs will be removed.
	*/
	void CSliceStack::CollapseSliceReferences()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_CollapseSliceReferences(m_pHandle));
	}
	
	/**
	* CSliceStack::SetOwnPath - Sets the package path where this Slice should be stored. Input an empty string to reset the path
	* @param[in] sPath - the package path where this Slice should be stored
	*/
	void CSliceStack::SetOwnPath(const std::string & sPath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_SetOwnPath(m_pHandle, sPath.c_str()));
	}
	
	/**
	* CSliceStack::GetOwnPath - Obtains the package path where this Slice should be stored. Returns an empty string if the slicestack is stored within the root model.
	* @return the package path where this Slice will be stored
	*/
	std::string CSliceStack::GetOwnPath()
	{
		Lib3MF_uint32 bytesNeededPath = 0;
		Lib3MF_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetOwnPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetOwnPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	 * Method definitions for class CConsumer
	 */
	
	/**
	* CConsumer::GetConsumerID - Gets the consumerid
	* @return A unique identifier for the consumers
	*/
	std::string CConsumer::GetConsumerID()
	{
		Lib3MF_uint32 bytesNeededConsumerID = 0;
		Lib3MF_uint32 bytesWrittenConsumerID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetConsumerID(m_pHandle, 0, &bytesNeededConsumerID, nullptr));
		std::vector<char> bufferConsumerID(bytesNeededConsumerID);
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetConsumerID(m_pHandle, bytesNeededConsumerID, &bytesWrittenConsumerID, &bufferConsumerID[0]));
		
		return std::string(&bufferConsumerID[0]);
	}
	
	/**
	* CConsumer::GetKeyID - Getts the keyid
	* @return The identifier for the key of this consumer
	*/
	std::string CConsumer::GetKeyID()
	{
		Lib3MF_uint32 bytesNeededKeyID = 0;
		Lib3MF_uint32 bytesWrittenKeyID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetKeyID(m_pHandle, 0, &bytesNeededKeyID, nullptr));
		std::vector<char> bufferKeyID(bytesNeededKeyID);
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetKeyID(m_pHandle, bytesNeededKeyID, &bytesWrittenKeyID, &bufferKeyID[0]));
		
		return std::string(&bufferKeyID[0]);
	}
	
	/**
	* CConsumer::GetKeyValue - Gets the keyvalue associated with this consumer
	* @return The public key, when available, of this consumer
	*/
	std::string CConsumer::GetKeyValue()
	{
		Lib3MF_uint32 bytesNeededKeyValue = 0;
		Lib3MF_uint32 bytesWrittenKeyValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetKeyValue(m_pHandle, 0, &bytesNeededKeyValue, nullptr));
		std::vector<char> bufferKeyValue(bytesNeededKeyValue);
		CheckError(m_pWrapper->m_WrapperTable.m_Consumer_GetKeyValue(m_pHandle, bytesNeededKeyValue, &bytesWrittenKeyValue, &bufferKeyValue[0]));
		
		return std::string(&bufferKeyValue[0]);
	}
	
	/**
	 * Method definitions for class CAccessRight
	 */
	
	/**
	* CAccessRight::GetConsumer - Gets the consumer associated with this access right
	* @return The consumer instance
	*/
	PConsumer CAccessRight::GetConsumer()
	{
		Lib3MFHandle hConsumer = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AccessRight_GetConsumer(m_pHandle, &hConsumer));
		
		if (!hConsumer) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CConsumer>(dynamic_cast<CConsumer*>(m_pWrapper->polymorphicFactory(hConsumer)));
	}
	
	/**
	* CAccessRight::GetWrappingAlgorithm - Gets the associated encryption algorithm
	* @return The algorithm used for the key in this accessright
	*/
	eWrappingAlgorithm CAccessRight::GetWrappingAlgorithm()
	{
		eWrappingAlgorithm resultAlgorithm = (eWrappingAlgorithm) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_AccessRight_GetWrappingAlgorithm(m_pHandle, &resultAlgorithm));
		
		return resultAlgorithm;
	}
	
	/**
	* CAccessRight::GetMgfAlgorithm - Gets the associated mask generation function algorithm
	* @return The MFG1 algorithm
	*/
	eMgfAlgorithm CAccessRight::GetMgfAlgorithm()
	{
		eMgfAlgorithm resultAlgorithm = (eMgfAlgorithm) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_AccessRight_GetMgfAlgorithm(m_pHandle, &resultAlgorithm));
		
		return resultAlgorithm;
	}
	
	/**
	* CAccessRight::GetDigestMethod - Gets the digest method assoicated
	* @return The digest method for this accessright
	*/
	eDigestMethod CAccessRight::GetDigestMethod()
	{
		eDigestMethod resultAlgorithm = (eDigestMethod) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_AccessRight_GetDigestMethod(m_pHandle, &resultAlgorithm));
		
		return resultAlgorithm;
	}
	
	/**
	 * Method definitions for class CContentEncryptionParams
	 */
	
	/**
	* CContentEncryptionParams::GetEncryptionAlgorithm - Returns the encryption method to be used in this encryption process
	* @return 
	*/
	eEncryptionAlgorithm CContentEncryptionParams::GetEncryptionAlgorithm()
	{
		eEncryptionAlgorithm resultAlgorithm = (eEncryptionAlgorithm) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetEncryptionAlgorithm(m_pHandle, &resultAlgorithm));
		
		return resultAlgorithm;
	}
	
	/**
	* CContentEncryptionParams::GetKey - Gets the key for the resource associated
	* @param[out] ByteDataBuffer - Pointer to a buffer where to place the key.
	*/
	void CContentEncryptionParams::GetKey(std::vector<Lib3MF_uint8> & ByteDataBuffer)
	{
		Lib3MF_uint64 elementsNeededByteData = 0;
		Lib3MF_uint64 elementsWrittenByteData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetKey(m_pHandle, 0, &elementsNeededByteData, nullptr));
		ByteDataBuffer.resize((size_t) elementsNeededByteData);
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetKey(m_pHandle, elementsNeededByteData, &elementsWrittenByteData, ByteDataBuffer.data()));
	}
	
	/**
	* CContentEncryptionParams::GetInitializationVector - Gets the IV data
	* @param[out] ByteDataBuffer - Pointer to a buffer where to place the data.
	*/
	void CContentEncryptionParams::GetInitializationVector(std::vector<Lib3MF_uint8> & ByteDataBuffer)
	{
		Lib3MF_uint64 elementsNeededByteData = 0;
		Lib3MF_uint64 elementsWrittenByteData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetInitializationVector(m_pHandle, 0, &elementsNeededByteData, nullptr));
		ByteDataBuffer.resize((size_t) elementsNeededByteData);
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetInitializationVector(m_pHandle, elementsNeededByteData, &elementsWrittenByteData, ByteDataBuffer.data()));
	}
	
	/**
	* CContentEncryptionParams::GetAuthenticationTag - A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value
	* @param[out] ByteDataBuffer - Pointer to a buffer where to place the data.
	*/
	void CContentEncryptionParams::GetAuthenticationTag(std::vector<Lib3MF_uint8> & ByteDataBuffer)
	{
		Lib3MF_uint64 elementsNeededByteData = 0;
		Lib3MF_uint64 elementsWrittenByteData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetAuthenticationTag(m_pHandle, 0, &elementsNeededByteData, nullptr));
		ByteDataBuffer.resize((size_t) elementsNeededByteData);
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetAuthenticationTag(m_pHandle, elementsNeededByteData, &elementsWrittenByteData, ByteDataBuffer.data()));
	}
	
	/**
	* CContentEncryptionParams::SetAuthenticationTag - Sets the authentication tag
	* @param[in] ByteDataBuffer - The authentication tag size
	*/
	void CContentEncryptionParams::SetAuthenticationTag(const CInputVector<Lib3MF_uint8> & ByteDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_SetAuthenticationTag(m_pHandle, (Lib3MF_uint64)ByteDataBuffer.size(), ByteDataBuffer.data()));
	}
	
	/**
	* CContentEncryptionParams::GetAdditionalAuthenticationData - A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value
	* @param[out] ByteDataBuffer - Buffer where the data will be placed
	*/
	void CContentEncryptionParams::GetAdditionalAuthenticationData(std::vector<Lib3MF_uint8> & ByteDataBuffer)
	{
		Lib3MF_uint64 elementsNeededByteData = 0;
		Lib3MF_uint64 elementsWrittenByteData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetAdditionalAuthenticationData(m_pHandle, 0, &elementsNeededByteData, nullptr));
		ByteDataBuffer.resize((size_t) elementsNeededByteData);
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetAdditionalAuthenticationData(m_pHandle, elementsNeededByteData, &elementsWrittenByteData, ByteDataBuffer.data()));
	}
	
	/**
	* CContentEncryptionParams::GetDescriptor - A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value
	* @return 
	*/
	Lib3MF_uint64 CContentEncryptionParams::GetDescriptor()
	{
		Lib3MF_uint64 resultDescriptor = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetDescriptor(m_pHandle, &resultDescriptor));
		
		return resultDescriptor;
	}
	
	/**
	* CContentEncryptionParams::GetKeyUUID - Gets the resourcedatagroup keyuuid
	* @return The resourcedatagroup keyuuid that may be use to reference an external key
	*/
	std::string CContentEncryptionParams::GetKeyUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetKeyUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ContentEncryptionParams_GetKeyUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	 * Method definitions for class CResourceData
	 */
	
	/**
	* CResourceData::GetPath - Gets the encrypted part path
	* @return The part path
	*/
	PPackagePart CResourceData::GetPath()
	{
		Lib3MFHandle hPath = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceData_GetPath(m_pHandle, &hPath));
		
		if (!hPath) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPackagePart>(dynamic_cast<CPackagePart*>(m_pWrapper->polymorphicFactory(hPath)));
	}
	
	/**
	* CResourceData::GetEncryptionAlgorithm - Gets the encryption algorithm used to encrypt this ResourceData
	* @return The encryption algorithm
	*/
	eEncryptionAlgorithm CResourceData::GetEncryptionAlgorithm()
	{
		eEncryptionAlgorithm resultEncryptionAlgorithm = (eEncryptionAlgorithm) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceData_GetEncryptionAlgorithm(m_pHandle, &resultEncryptionAlgorithm));
		
		return resultEncryptionAlgorithm;
	}
	
	/**
	* CResourceData::GetCompression - Tells whether this ResourceData is compressed or not
	* @return The compression method
	*/
	eCompression CResourceData::GetCompression()
	{
		eCompression resultCompression = (eCompression) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceData_GetCompression(m_pHandle, &resultCompression));
		
		return resultCompression;
	}
	
	/**
	* CResourceData::GetAdditionalAuthenticationData - Tells whether this ResourceData is compressed or not
	* @param[out] ByteDataBuffer - The compression method
	*/
	void CResourceData::GetAdditionalAuthenticationData(std::vector<Lib3MF_uint8> & ByteDataBuffer)
	{
		Lib3MF_uint64 elementsNeededByteData = 0;
		Lib3MF_uint64 elementsWrittenByteData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceData_GetAdditionalAuthenticationData(m_pHandle, 0, &elementsNeededByteData, nullptr));
		ByteDataBuffer.resize((size_t) elementsNeededByteData);
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceData_GetAdditionalAuthenticationData(m_pHandle, elementsNeededByteData, &elementsWrittenByteData, ByteDataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CResourceDataGroup
	 */
	
	/**
	* CResourceDataGroup::GetKeyUUID - Sets the resourcedatagroup keyuuid
	* @return The new resourcedatagroup keyuuid.
	*/
	std::string CResourceDataGroup::GetKeyUUID()
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceDataGroup_GetKeyUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceDataGroup_GetKeyUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CResourceDataGroup::AddAccessRight - Add accessright to resourcedatagroup element
	* @param[in] pConsumer - The Consumer reference
	* @param[in] eWrappingAlgorithm - The key wrapping algorithm to be used
	* @param[in] eMgfAlgorithm - The mask generation function to be used
	* @param[in] eDigestMethod - The digest mechanism to be used
	* @return The acess right instance
	*/
	PAccessRight CResourceDataGroup::AddAccessRight(classParam<CConsumer> pConsumer, const eWrappingAlgorithm eWrappingAlgorithm, const eMgfAlgorithm eMgfAlgorithm, const eDigestMethod eDigestMethod)
	{
		Lib3MFHandle hConsumer = pConsumer.GetHandle();
		Lib3MFHandle hTheAccessRight = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceDataGroup_AddAccessRight(m_pHandle, hConsumer, eWrappingAlgorithm, eMgfAlgorithm, eDigestMethod, &hTheAccessRight));
		
		if (!hTheAccessRight) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAccessRight>(dynamic_cast<CAccessRight*>(m_pWrapper->polymorphicFactory(hTheAccessRight)));
	}
	
	/**
	* CResourceDataGroup::FindAccessRightByConsumer - Finds the AccessRight associated with a Consumer
	* @param[in] pConsumer - The Consumer instance
	* @return The AcessRight instance
	*/
	PAccessRight CResourceDataGroup::FindAccessRightByConsumer(classParam<CConsumer> pConsumer)
	{
		Lib3MFHandle hConsumer = pConsumer.GetHandle();
		Lib3MFHandle hTheAccessRight = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceDataGroup_FindAccessRightByConsumer(m_pHandle, hConsumer, &hTheAccessRight));
		
		if (hTheAccessRight) {
			return std::shared_ptr<CAccessRight>(dynamic_cast<CAccessRight*>(m_pWrapper->polymorphicFactory(hTheAccessRight)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CResourceDataGroup::RemoveAccessRight - Removes access from a Consumer on this resource data group
	* @param[in] pConsumer - The Consumer instance
	*/
	void CResourceDataGroup::RemoveAccessRight(classParam<CConsumer> pConsumer)
	{
		Lib3MFHandle hConsumer = pConsumer.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_ResourceDataGroup_RemoveAccessRight(m_pHandle, hConsumer));
	}
	
	/**
	 * Method definitions for class CKeyStore
	 */
	
	/**
	* CKeyStore::AddConsumer - Adds a consumer to the keystore
	* @param[in] sConsumerID - A unique identifier for the consumer
	* @param[in] sKeyID - The id of the key of the consumer
	* @param[in] sKeyValue - The public key for this consumer in PEM format
	* @return The consumer instance
	*/
	PConsumer CKeyStore::AddConsumer(const std::string & sConsumerID, const std::string & sKeyID, const std::string & sKeyValue)
	{
		Lib3MFHandle hConsumer = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_AddConsumer(m_pHandle, sConsumerID.c_str(), sKeyID.c_str(), sKeyValue.c_str(), &hConsumer));
		
		if (!hConsumer) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CConsumer>(dynamic_cast<CConsumer*>(m_pWrapper->polymorphicFactory(hConsumer)));
	}
	
	/**
	* CKeyStore::GetConsumerCount - Gets the number of consumers in the keystore
	* @return The consumer count
	*/
	Lib3MF_uint64 CKeyStore::GetConsumerCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetConsumerCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CKeyStore::GetConsumer - Get a consumer from the keystore
	* @param[in] nConsumerIndex - The index of the consumer
	* @return The consumer instance
	*/
	PConsumer CKeyStore::GetConsumer(const Lib3MF_uint64 nConsumerIndex)
	{
		Lib3MFHandle hConsumer = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetConsumer(m_pHandle, nConsumerIndex, &hConsumer));
		
		if (!hConsumer) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CConsumer>(dynamic_cast<CConsumer*>(m_pWrapper->polymorphicFactory(hConsumer)));
	}
	
	/**
	* CKeyStore::RemoveConsumer - Removes a consumer from the keystore
	* @param[in] pConsumer - The consumer instance to remove
	*/
	void CKeyStore::RemoveConsumer(classParam<CConsumer> pConsumer)
	{
		Lib3MFHandle hConsumer = pConsumer.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_RemoveConsumer(m_pHandle, hConsumer));
	}
	
	/**
	* CKeyStore::FindConsumer - Finds a consumer by ID
	* @param[in] sConsumerID - The ID of the consumer
	* @return The consumer instance
	*/
	PConsumer CKeyStore::FindConsumer(const std::string & sConsumerID)
	{
		Lib3MFHandle hConsumer = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_FindConsumer(m_pHandle, sConsumerID.c_str(), &hConsumer));
		
		if (hConsumer) {
			return std::shared_ptr<CConsumer>(dynamic_cast<CConsumer*>(m_pWrapper->polymorphicFactory(hConsumer)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CKeyStore::GetResourceDataGroupCount - Gets the number of resource data group in the keysore
	* @return The number of resource data available
	*/
	Lib3MF_uint64 CKeyStore::GetResourceDataGroupCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetResourceDataGroupCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CKeyStore::AddResourceDataGroup - Adds a resource data group into the keystore.
	* @return The resource data group instance
	*/
	PResourceDataGroup CKeyStore::AddResourceDataGroup()
	{
		Lib3MFHandle hResourceDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_AddResourceDataGroup(m_pHandle, &hResourceDataGroup));
		
		if (!hResourceDataGroup) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceDataGroup>(dynamic_cast<CResourceDataGroup*>(m_pWrapper->polymorphicFactory(hResourceDataGroup)));
	}
	
	/**
	* CKeyStore::GetResourceDataGroup - Gets a resource data group
	* @param[in] nResourceDataIndex - The index of the resource data
	* @return The resource data group instance
	*/
	PResourceDataGroup CKeyStore::GetResourceDataGroup(const Lib3MF_uint64 nResourceDataIndex)
	{
		Lib3MFHandle hResourceDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetResourceDataGroup(m_pHandle, nResourceDataIndex, &hResourceDataGroup));
		
		if (!hResourceDataGroup) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceDataGroup>(dynamic_cast<CResourceDataGroup*>(m_pWrapper->polymorphicFactory(hResourceDataGroup)));
	}
	
	/**
	* CKeyStore::RemoveResourceDataGroup - Removes a resource data group
	* @param[in] pResourceDataGroup - The resource data group instance
	*/
	void CKeyStore::RemoveResourceDataGroup(classParam<CResourceDataGroup> pResourceDataGroup)
	{
		Lib3MFHandle hResourceDataGroup = pResourceDataGroup.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_RemoveResourceDataGroup(m_pHandle, hResourceDataGroup));
	}
	
	/**
	* CKeyStore::FindResourceDataGroup - Finds a resource data group that contains a particular resourcedata
	* @param[in] pPartPath - The target path for the resourcedata hold by the resource data group
	* @return The data resource instance
	*/
	PResourceDataGroup CKeyStore::FindResourceDataGroup(classParam<CPackagePart> pPartPath)
	{
		Lib3MFHandle hPartPath = pPartPath.GetHandle();
		Lib3MFHandle hResourceDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_FindResourceDataGroup(m_pHandle, hPartPath, &hResourceDataGroup));
		
		if (hResourceDataGroup) {
			return std::shared_ptr<CResourceDataGroup>(dynamic_cast<CResourceDataGroup*>(m_pWrapper->polymorphicFactory(hResourceDataGroup)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CKeyStore::AddResourceData - Add resourcedata to resourcedatagroup element
	* @param[in] pResourceDataGroup - The resource data group where to add this resource data
	* @param[in] pPartPath - The path of the part to be encrypted
	* @param[in] eAlgorithm - The encryption algorithm to be used to encrypt this resource
	* @param[in] eCompression - Whether compression should be used prior to encryption
	* @param[in] AdditionalAuthenticationDataBuffer - Additional data to be encrypted along the contents for better security
	* @return The data resource instance
	*/
	PResourceData CKeyStore::AddResourceData(classParam<CResourceDataGroup> pResourceDataGroup, classParam<CPackagePart> pPartPath, const eEncryptionAlgorithm eAlgorithm, const eCompression eCompression, const CInputVector<Lib3MF_uint8> & AdditionalAuthenticationDataBuffer)
	{
		Lib3MFHandle hResourceDataGroup = pResourceDataGroup.GetHandle();
		Lib3MFHandle hPartPath = pPartPath.GetHandle();
		Lib3MFHandle hResourceData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_AddResourceData(m_pHandle, hResourceDataGroup, hPartPath, eAlgorithm, eCompression, (Lib3MF_uint64)AdditionalAuthenticationDataBuffer.size(), AdditionalAuthenticationDataBuffer.data(), &hResourceData));
		
		if (!hResourceData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceData>(dynamic_cast<CResourceData*>(m_pWrapper->polymorphicFactory(hResourceData)));
	}
	
	/**
	* CKeyStore::RemoveResourceData - Removes a resource data
	* @param[in] pResourceData - The resource data to be removed
	*/
	void CKeyStore::RemoveResourceData(classParam<CResourceData> pResourceData)
	{
		Lib3MFHandle hResourceData = pResourceData.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_RemoveResourceData(m_pHandle, hResourceData));
	}
	
	/**
	* CKeyStore::FindResourceData - Finds a resource data on this resource group
	* @param[in] pResourcePath - The target path for the resourcedata
	* @return The resource data instance
	*/
	PResourceData CKeyStore::FindResourceData(classParam<CPackagePart> pResourcePath)
	{
		Lib3MFHandle hResourcePath = pResourcePath.GetHandle();
		Lib3MFHandle hResourceData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_FindResourceData(m_pHandle, hResourcePath, &hResourceData));
		
		if (hResourceData) {
			return std::shared_ptr<CResourceData>(dynamic_cast<CResourceData*>(m_pWrapper->polymorphicFactory(hResourceData)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CKeyStore::GetResourceDataCount - Gets the number of resource data in the keysore
	* @return The number of resource data available
	*/
	Lib3MF_uint64 CKeyStore::GetResourceDataCount()
	{
		Lib3MF_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetResourceDataCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CKeyStore::GetResourceData - Gets a resource data
	* @param[in] nResourceDataIndex - The index of the resource data
	* @return The data resource instance
	*/
	PResourceData CKeyStore::GetResourceData(const Lib3MF_uint64 nResourceDataIndex)
	{
		Lib3MFHandle hResourceData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetResourceData(m_pHandle, nResourceDataIndex, &hResourceData));
		
		if (!hResourceData) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceData>(dynamic_cast<CResourceData*>(m_pWrapper->polymorphicFactory(hResourceData)));
	}
	
	/**
	* CKeyStore::GetUUID - Gets the keystore UUID
	* @param[out] bHasUUID - flag whether the keystore has a UUID
	* @return returns the keystore uuid.
	*/
	std::string CKeyStore::GetUUID(bool & bHasUUID)
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetUUID(m_pHandle, &bHasUUID, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_GetUUID(m_pHandle, &bHasUUID, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CKeyStore::SetUUID - Sets the keystore UUID
	* @param[in] sUUID - The new keystore uuid.
	*/
	void CKeyStore::SetUUID(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_KeyStore_SetUUID(m_pHandle, sUUID.c_str()));
	}
	
	/**
	 * Method definitions for class CModel
	 */
	
	/**
	* CModel::RootModelPart - Returns the PackagePart within the OPC package that holds the root model.
	* @return the PackagePart within the OPC package that holds the model-file
	*/
	PPackagePart CModel::RootModelPart()
	{
		Lib3MFHandle hRootModelPart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_RootModelPart(m_pHandle, &hRootModelPart));
		
		if (!hRootModelPart) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPackagePart>(dynamic_cast<CPackagePart*>(m_pWrapper->polymorphicFactory(hRootModelPart)));
	}
	
	/**
	* CModel::FindOrCreatePackagePart - Returns a new PackagePart for use within the OPC package.
	* @param[in] sAbsolutePath - the absolute Path (physical location) within the OPC package
	* @return the new PackagePart within the OPC package
	*/
	PPackagePart CModel::FindOrCreatePackagePart(const std::string & sAbsolutePath)
	{
		Lib3MFHandle hModelPart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_FindOrCreatePackagePart(m_pHandle, sAbsolutePath.c_str(), &hModelPart));
		
		if (!hModelPart) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPackagePart>(dynamic_cast<CPackagePart*>(m_pWrapper->polymorphicFactory(hModelPart)));
	}
	
	/**
	* CModel::SetUnit - sets the units of a model.
	* @param[in] eUnit - Unit enum value for the model unit
	*/
	void CModel::SetUnit(const eModelUnit eUnit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_SetUnit(m_pHandle, eUnit));
	}
	
	/**
	* CModel::GetUnit - returns the units of a model.
	* @return Unit enum value for the model unit
	*/
	eModelUnit CModel::GetUnit()
	{
		eModelUnit resultUnit = (eModelUnit) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetUnit(m_pHandle, &resultUnit));
		
		return resultUnit;
	}
	
	/**
	* CModel::GetLanguage - retrieves the language of a model
	* @return language identifier
	*/
	std::string CModel::GetLanguage()
	{
		Lib3MF_uint32 bytesNeededLanguage = 0;
		Lib3MF_uint32 bytesWrittenLanguage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetLanguage(m_pHandle, 0, &bytesNeededLanguage, nullptr));
		std::vector<char> bufferLanguage(bytesNeededLanguage);
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetLanguage(m_pHandle, bytesNeededLanguage, &bytesWrittenLanguage, &bufferLanguage[0]));
		
		return std::string(&bufferLanguage[0]);
	}
	
	/**
	* CModel::SetLanguage - sets the language of a model
	* @param[in] sLanguage - language identifier
	*/
	void CModel::SetLanguage(const std::string & sLanguage)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_SetLanguage(m_pHandle, sLanguage.c_str()));
	}
	
	/**
	* CModel::QueryWriter - creates a model writer instance for a specific file type
	* @param[in] sWriterClass -  string identifier for the file type
	* @return  string identifier for the file type
	*/
	PWriter CModel::QueryWriter(const std::string & sWriterClass)
	{
		Lib3MFHandle hWriterInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_QueryWriter(m_pHandle, sWriterClass.c_str(), &hWriterInstance));
		
		if (!hWriterInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CWriter>(dynamic_cast<CWriter*>(m_pWrapper->polymorphicFactory(hWriterInstance)));
	}
	
	/**
	* CModel::QueryReader - creates a model reader instance for a specific file type
	* @param[in] sReaderClass -  string identifier for the file type
	* @return  string identifier for the file type
	*/
	PReader CModel::QueryReader(const std::string & sReaderClass)
	{
		Lib3MFHandle hReaderInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_QueryReader(m_pHandle, sReaderClass.c_str(), &hReaderInstance));
		
		if (!hReaderInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CReader>(dynamic_cast<CReader*>(m_pWrapper->polymorphicFactory(hReaderInstance)));
	}
	
	/**
	* CModel::GetResourceByID - finds a model resource by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the resource instance
	*/
	PResource CModel::GetResourceByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hResource = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetResourceByID(m_pHandle, nUniqueResourceID, &hResource));
		
		if (!hResource) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResource>(dynamic_cast<CResource*>(m_pWrapper->polymorphicFactory(hResource)));
	}
	
	/**
	* CModel::GetTexture2DByID - finds a model texture by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the texture2d instance
	*/
	PTexture2D CModel::GetTexture2DByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hTextureInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetTexture2DByID(m_pHandle, nUniqueResourceID, &hTextureInstance));
		
		if (!hTextureInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2D>(dynamic_cast<CTexture2D*>(m_pWrapper->polymorphicFactory(hTextureInstance)));
	}
	
	/**
	* CModel::GetPropertyTypeByID - returns a Property's type
	* @param[in] nUniqueResourceID - Resource ID of the Property to Query
	* @return returns a Property's type
	*/
	ePropertyType CModel::GetPropertyTypeByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		ePropertyType resultThePropertyType = (ePropertyType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetPropertyTypeByID(m_pHandle, nUniqueResourceID, &resultThePropertyType));
		
		return resultThePropertyType;
	}
	
	/**
	* CModel::GetBaseMaterialGroupByID - finds a model base material group by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the BaseMaterialGroup instance
	*/
	PBaseMaterialGroup CModel::GetBaseMaterialGroupByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hBaseMaterialGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetBaseMaterialGroupByID(m_pHandle, nUniqueResourceID, &hBaseMaterialGroupInstance));
		
		if (!hBaseMaterialGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBaseMaterialGroup>(dynamic_cast<CBaseMaterialGroup*>(m_pWrapper->polymorphicFactory(hBaseMaterialGroupInstance)));
	}
	
	/**
	* CModel::GetTexture2DGroupByID - finds a model texture2d group by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the Texture2DGroup instance
	*/
	PTexture2DGroup CModel::GetTexture2DGroupByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hTexture2DGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetTexture2DGroupByID(m_pHandle, nUniqueResourceID, &hTexture2DGroupInstance));
		
		if (!hTexture2DGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2DGroup>(dynamic_cast<CTexture2DGroup*>(m_pWrapper->polymorphicFactory(hTexture2DGroupInstance)));
	}
	
	/**
	* CModel::GetCompositeMaterialsByID - finds a model CompositeMaterials by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the CompositeMaterials instance
	*/
	PCompositeMaterials CModel::GetCompositeMaterialsByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hCompositeMaterialsInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetCompositeMaterialsByID(m_pHandle, nUniqueResourceID, &hCompositeMaterialsInstance));
		
		if (!hCompositeMaterialsInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCompositeMaterials>(dynamic_cast<CCompositeMaterials*>(m_pWrapper->polymorphicFactory(hCompositeMaterialsInstance)));
	}
	
	/**
	* CModel::GetMultiPropertyGroupByID - finds a model MultiPropertyGroup by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the MultiPropertyGroup instance
	*/
	PMultiPropertyGroup CModel::GetMultiPropertyGroupByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hMultiPropertyGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetMultiPropertyGroupByID(m_pHandle, nUniqueResourceID, &hMultiPropertyGroupInstance));
		
		if (!hMultiPropertyGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMultiPropertyGroup>(dynamic_cast<CMultiPropertyGroup*>(m_pWrapper->polymorphicFactory(hMultiPropertyGroupInstance)));
	}
	
	/**
	* CModel::GetMeshObjectByID - finds a mesh object by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the mesh object instance
	*/
	PMeshObject CModel::GetMeshObjectByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hMeshObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetMeshObjectByID(m_pHandle, nUniqueResourceID, &hMeshObjectInstance));
		
		if (!hMeshObjectInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMeshObject>(dynamic_cast<CMeshObject*>(m_pWrapper->polymorphicFactory(hMeshObjectInstance)));
	}
	
	/**
	* CModel::GetComponentsObjectByID - finds a components object by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the components object instance
	*/
	PComponentsObject CModel::GetComponentsObjectByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hComponentsObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetComponentsObjectByID(m_pHandle, nUniqueResourceID, &hComponentsObjectInstance));
		
		if (!hComponentsObjectInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponentsObject>(dynamic_cast<CComponentsObject*>(m_pWrapper->polymorphicFactory(hComponentsObjectInstance)));
	}
	
	/**
	* CModel::GetColorGroupByID - finds a model color group by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the ColorGroup instance
	*/
	PColorGroup CModel::GetColorGroupByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hColorGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetColorGroupByID(m_pHandle, nUniqueResourceID, &hColorGroupInstance));
		
		if (!hColorGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CColorGroup>(dynamic_cast<CColorGroup*>(m_pWrapper->polymorphicFactory(hColorGroupInstance)));
	}
	
	/**
	* CModel::GetSliceStackByID - finds a model slicestack by its UniqueResourceID
	* @param[in] nUniqueResourceID - UniqueResourceID
	* @return returns the slicestack instance
	*/
	PSliceStack CModel::GetSliceStackByID(const Lib3MF_uint32 nUniqueResourceID)
	{
		Lib3MFHandle hSliceStacInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetSliceStackByID(m_pHandle, nUniqueResourceID, &hSliceStacInstance));
		
		if (!hSliceStacInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStack>(dynamic_cast<CSliceStack*>(m_pWrapper->polymorphicFactory(hSliceStacInstance)));
	}
	
	/**
	* CModel::GetBuildUUID - returns, whether a build has a UUID and, if true, the build's UUID
	* @param[out] bHasUUID - flag whether the build has a UUID
	* @return the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	std::string CModel::GetBuildUUID(bool & bHasUUID)
	{
		Lib3MF_uint32 bytesNeededUUID = 0;
		Lib3MF_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetBuildUUID(m_pHandle, &bHasUUID, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetBuildUUID(m_pHandle, &bHasUUID, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CModel::SetBuildUUID - sets the build's UUID
	* @param[in] sUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'
	*/
	void CModel::SetBuildUUID(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_SetBuildUUID(m_pHandle, sUUID.c_str()));
	}
	
	/**
	* CModel::GetBuildItems - creates a build item iterator instance with all build items.
	* @return returns the iterator instance.
	*/
	PBuildItemIterator CModel::GetBuildItems()
	{
		Lib3MFHandle hBuildItemIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetBuildItems(m_pHandle, &hBuildItemIterator));
		
		if (!hBuildItemIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBuildItemIterator>(dynamic_cast<CBuildItemIterator*>(m_pWrapper->polymorphicFactory(hBuildItemIterator)));
	}
	
	/**
	* CModel::GetOutbox - Returns the outbox of a Model
	* @return Outbox of this Model
	*/
	sBox CModel::GetOutbox()
	{
		sBox resultOutbox;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetOutbox(m_pHandle, &resultOutbox));
		
		return resultOutbox;
	}
	
	/**
	* CModel::GetResources - creates a resource iterator instance with all resources.
	* @return returns the iterator instance.
	*/
	PResourceIterator CModel::GetResources()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetResources(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CResourceIterator>(dynamic_cast<CResourceIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetObjects - creates a resource iterator instance with all object resources.
	* @return returns the iterator instance.
	*/
	PObjectIterator CModel::GetObjects()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetObjects(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CObjectIterator>(dynamic_cast<CObjectIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetMeshObjects - creates a resource iterator instance with all mesh object resources.
	* @return returns the iterator instance.
	*/
	PMeshObjectIterator CModel::GetMeshObjects()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetMeshObjects(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMeshObjectIterator>(dynamic_cast<CMeshObjectIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetComponentsObjects - creates a resource iterator instance with all components object resources.
	* @return returns the iterator instance.
	*/
	PComponentsObjectIterator CModel::GetComponentsObjects()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetComponentsObjects(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponentsObjectIterator>(dynamic_cast<CComponentsObjectIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetTexture2Ds - creates a Texture2DIterator instance with all texture2d resources.
	* @return returns the iterator instance.
	*/
	PTexture2DIterator CModel::GetTexture2Ds()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetTexture2Ds(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2DIterator>(dynamic_cast<CTexture2DIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetBaseMaterialGroups - creates a BaseMaterialGroupIterator instance with all base material resources.
	* @return returns the iterator instance.
	*/
	PBaseMaterialGroupIterator CModel::GetBaseMaterialGroups()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetBaseMaterialGroups(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBaseMaterialGroupIterator>(dynamic_cast<CBaseMaterialGroupIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetColorGroups - creates a ColorGroupIterator instance with all ColorGroup resources.
	* @return returns the iterator instance.
	*/
	PColorGroupIterator CModel::GetColorGroups()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetColorGroups(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CColorGroupIterator>(dynamic_cast<CColorGroupIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetTexture2DGroups - creates a Texture2DGroupIterator instance with all base material resources.
	* @return returns the iterator instance.
	*/
	PTexture2DGroupIterator CModel::GetTexture2DGroups()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetTexture2DGroups(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2DGroupIterator>(dynamic_cast<CTexture2DGroupIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetCompositeMaterials - creates a CompositeMaterialsIterator instance with all CompositeMaterials resources.
	* @return returns the iterator instance.
	*/
	PCompositeMaterialsIterator CModel::GetCompositeMaterials()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetCompositeMaterials(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCompositeMaterialsIterator>(dynamic_cast<CCompositeMaterialsIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetMultiPropertyGroups - creates a MultiPropertyGroupsIterator instance with all MultiPropertyGroup resources.
	* @return returns the iterator instance.
	*/
	PMultiPropertyGroupIterator CModel::GetMultiPropertyGroups()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetMultiPropertyGroups(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMultiPropertyGroupIterator>(dynamic_cast<CMultiPropertyGroupIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetToolpaths - creates a Toolpath instance with all toolpath resources.
	* @return returns the iterator instance.
	*/
	PToolpathIterator CModel::GetToolpaths()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetToolpaths(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpathIterator>(dynamic_cast<CToolpathIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::GetSliceStacks - creates a resource iterator instance with all slice stack resources.
	* @return returns the iterator instance.
	*/
	PSliceStackIterator CModel::GetSliceStacks()
	{
		Lib3MFHandle hResourceIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetSliceStacks(m_pHandle, &hResourceIterator));
		
		if (!hResourceIterator) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStackIterator>(dynamic_cast<CSliceStackIterator*>(m_pWrapper->polymorphicFactory(hResourceIterator)));
	}
	
	/**
	* CModel::MergeToModel - Merges all components and objects which are referenced by a build item into a mesh. The memory is duplicated and a new model is created.
	* @return returns the merged model instance
	*/
	PModel CModel::MergeToModel()
	{
		Lib3MFHandle hMergedModelInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_MergeToModel(m_pHandle, &hMergedModelInstance));
		
		if (!hMergedModelInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CModel>(dynamic_cast<CModel*>(m_pWrapper->polymorphicFactory(hMergedModelInstance)));
	}
	
	/**
	* CModel::AddMeshObject - adds an empty mesh object to the model.
	* @return  returns the mesh object instance
	*/
	PMeshObject CModel::AddMeshObject()
	{
		Lib3MFHandle hMeshObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddMeshObject(m_pHandle, &hMeshObjectInstance));
		
		if (!hMeshObjectInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMeshObject>(dynamic_cast<CMeshObject*>(m_pWrapper->polymorphicFactory(hMeshObjectInstance)));
	}
	
	/**
	* CModel::AddComponentsObject - adds an empty component object to the model.
	* @return  returns the components object instance
	*/
	PComponentsObject CModel::AddComponentsObject()
	{
		Lib3MFHandle hComponentsObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddComponentsObject(m_pHandle, &hComponentsObjectInstance));
		
		if (!hComponentsObjectInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CComponentsObject>(dynamic_cast<CComponentsObject*>(m_pWrapper->polymorphicFactory(hComponentsObjectInstance)));
	}
	
	/**
	* CModel::AddSliceStack - creates a new model slicestack by its id
	* @param[in] dZBottom - Bottom Z value of the slicestack
	* @return returns the new slicestack instance
	*/
	PSliceStack CModel::AddSliceStack(const Lib3MF_double dZBottom)
	{
		Lib3MFHandle hSliceStackInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddSliceStack(m_pHandle, dZBottom, &hSliceStackInstance));
		
		if (!hSliceStackInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CSliceStack>(dynamic_cast<CSliceStack*>(m_pWrapper->polymorphicFactory(hSliceStackInstance)));
	}
	
	/**
	* CModel::AddTexture2DFromAttachment - adds a texture2d resource to the model. Its path is given by that of an existing attachment.
	* @param[in] pTextureAttachment - attachment containing the image data.
	* @return returns the new texture instance.
	*/
	PTexture2D CModel::AddTexture2DFromAttachment(classParam<CAttachment> pTextureAttachment)
	{
		Lib3MFHandle hTextureAttachment = pTextureAttachment.GetHandle();
		Lib3MFHandle hTexture2DInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddTexture2DFromAttachment(m_pHandle, hTextureAttachment, &hTexture2DInstance));
		
		if (!hTexture2DInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2D>(dynamic_cast<CTexture2D*>(m_pWrapper->polymorphicFactory(hTexture2DInstance)));
	}
	
	/**
	* CModel::AddBaseMaterialGroup - adds an empty BaseMaterialGroup resource to the model.
	* @return returns the new base material instance.
	*/
	PBaseMaterialGroup CModel::AddBaseMaterialGroup()
	{
		Lib3MFHandle hBaseMaterialGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddBaseMaterialGroup(m_pHandle, &hBaseMaterialGroupInstance));
		
		if (!hBaseMaterialGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBaseMaterialGroup>(dynamic_cast<CBaseMaterialGroup*>(m_pWrapper->polymorphicFactory(hBaseMaterialGroupInstance)));
	}
	
	/**
	* CModel::AddColorGroup - adds an empty ColorGroup resource to the model.
	* @return returns the new ColorGroup instance.
	*/
	PColorGroup CModel::AddColorGroup()
	{
		Lib3MFHandle hColorGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddColorGroup(m_pHandle, &hColorGroupInstance));
		
		if (!hColorGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CColorGroup>(dynamic_cast<CColorGroup*>(m_pWrapper->polymorphicFactory(hColorGroupInstance)));
	}
	
	/**
	* CModel::AddTexture2DGroup - adds an empty Texture2DGroup resource to the model.
	* @param[in] pTexture2DInstance - The texture2D instance of the created Texture2DGroup.
	* @return returns the new Texture2DGroup instance.
	*/
	PTexture2DGroup CModel::AddTexture2DGroup(classParam<CTexture2D> pTexture2DInstance)
	{
		Lib3MFHandle hTexture2DInstance = pTexture2DInstance.GetHandle();
		Lib3MFHandle hTexture2DGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddTexture2DGroup(m_pHandle, hTexture2DInstance, &hTexture2DGroupInstance));
		
		if (!hTexture2DGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CTexture2DGroup>(dynamic_cast<CTexture2DGroup*>(m_pWrapper->polymorphicFactory(hTexture2DGroupInstance)));
	}
	
	/**
	* CModel::AddCompositeMaterials - adds an empty CompositeMaterials resource to the model.
	* @param[in] pBaseMaterialGroupInstance - The BaseMaterialGroup instance of the created CompositeMaterials.
	* @return returns the new CompositeMaterials instance.
	*/
	PCompositeMaterials CModel::AddCompositeMaterials(classParam<CBaseMaterialGroup> pBaseMaterialGroupInstance)
	{
		Lib3MFHandle hBaseMaterialGroupInstance = pBaseMaterialGroupInstance.GetHandle();
		Lib3MFHandle hCompositeMaterialsInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddCompositeMaterials(m_pHandle, hBaseMaterialGroupInstance, &hCompositeMaterialsInstance));
		
		if (!hCompositeMaterialsInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CCompositeMaterials>(dynamic_cast<CCompositeMaterials*>(m_pWrapper->polymorphicFactory(hCompositeMaterialsInstance)));
	}
	
	/**
	* CModel::AddMultiPropertyGroup - adds an empty MultiPropertyGroup resource to the model.
	* @return returns the new MultiPropertyGroup instance.
	*/
	PMultiPropertyGroup CModel::AddMultiPropertyGroup()
	{
		Lib3MFHandle hMultiPropertyGroupInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddMultiPropertyGroup(m_pHandle, &hMultiPropertyGroupInstance));
		
		if (!hMultiPropertyGroupInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMultiPropertyGroup>(dynamic_cast<CMultiPropertyGroup*>(m_pWrapper->polymorphicFactory(hMultiPropertyGroupInstance)));
	}
	
	/**
	* CModel::AddBuildItem - adds a build item to the model.
	* @param[in] pObject - Object instance.
	* @param[in] Transform - Transformation matrix.
	* @return returns the build item instance.
	*/
	PBuildItem CModel::AddBuildItem(classParam<CObject> pObject, const sTransform & Transform)
	{
		Lib3MFHandle hObject = pObject.GetHandle();
		Lib3MFHandle hBuildItemInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddBuildItem(m_pHandle, hObject, &Transform, &hBuildItemInstance));
		
		if (!hBuildItemInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CBuildItem>(dynamic_cast<CBuildItem*>(m_pWrapper->polymorphicFactory(hBuildItemInstance)));
	}
	
	/**
	* CModel::RemoveBuildItem - removes a build item from the model
	* @param[in] pBuildItemInstance - Build item to remove.
	*/
	void CModel::RemoveBuildItem(classParam<CBuildItem> pBuildItemInstance)
	{
		Lib3MFHandle hBuildItemInstance = pBuildItemInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Model_RemoveBuildItem(m_pHandle, hBuildItemInstance));
	}
	
	/**
	* CModel::AddToolpath - adds an empty Toolpath resource to the model.
	* @param[in] dUnitFactor - The toolpath instance of the created Toolpath.
	* @return The toolpath instance of the created Toolpath.
	*/
	PToolpath CModel::AddToolpath(const Lib3MF_double dUnitFactor)
	{
		Lib3MFHandle hToolpathInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddToolpath(m_pHandle, dUnitFactor, &hToolpathInstance));
		
		if (!hToolpathInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CToolpath>(dynamic_cast<CToolpath*>(m_pWrapper->polymorphicFactory(hToolpathInstance)));
	}
	
	/**
	* CModel::GetMetaDataGroup - Returns the metadata of the model as MetaDataGroup
	* @return returns an Instance of the metadatagroup of the model
	*/
	PMetaDataGroup CModel::GetMetaDataGroup()
	{
		Lib3MFHandle hTheMetaDataGroup = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetMetaDataGroup(m_pHandle, &hTheMetaDataGroup));
		
		if (!hTheMetaDataGroup) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CMetaDataGroup>(dynamic_cast<CMetaDataGroup*>(m_pWrapper->polymorphicFactory(hTheMetaDataGroup)));
	}
	
	/**
	* CModel::AddAttachment - adds an attachment stream to the model. The OPC part will be related to the model stream with a certain relationship type.
	* @param[in] sURI - Path of the attachment
	* @param[in] sRelationShipType - Relationship type of the attachment
	* @return Instance of the attachment object
	*/
	PAttachment CModel::AddAttachment(const std::string & sURI, const std::string & sRelationShipType)
	{
		Lib3MFHandle hAttachmentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddAttachment(m_pHandle, sURI.c_str(), sRelationShipType.c_str(), &hAttachmentInstance));
		
		if (!hAttachmentInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachmentInstance)));
	}
	
	/**
	* CModel::RemoveAttachment - Removes attachment from the model.
	* @param[in] pAttachmentInstance - Attachment instance to remove
	*/
	void CModel::RemoveAttachment(classParam<CAttachment> pAttachmentInstance)
	{
		Lib3MFHandle hAttachmentInstance = pAttachmentInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Model_RemoveAttachment(m_pHandle, hAttachmentInstance));
	}
	
	/**
	* CModel::GetAttachment - retrieves an attachment stream object from the model..
	* @param[in] nIndex - Index of the attachment stream
	* @return Instance of the attachment object
	*/
	PAttachment CModel::GetAttachment(const Lib3MF_uint32 nIndex)
	{
		Lib3MFHandle hAttachmentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetAttachment(m_pHandle, nIndex, &hAttachmentInstance));
		
		if (!hAttachmentInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachmentInstance)));
	}
	
	/**
	* CModel::FindAttachment - retrieves an attachment stream object from the model.
	* @param[in] sURI - Path URI in the package
	* @return Instance of the attachment object
	*/
	PAttachment CModel::FindAttachment(const std::string & sURI)
	{
		Lib3MFHandle hAttachmentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_FindAttachment(m_pHandle, sURI.c_str(), &hAttachmentInstance));
		
		if (!hAttachmentInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachmentInstance)));
	}
	
	/**
	* CModel::GetAttachmentCount - retrieves the number of attachments of the model.
	* @return Returns the number of attachments.
	*/
	Lib3MF_uint32 CModel::GetAttachmentCount()
	{
		Lib3MF_uint32 resultAttachmentCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetAttachmentCount(m_pHandle, &resultAttachmentCount));
		
		return resultAttachmentCount;
	}
	
	/**
	* CModel::HasPackageThumbnailAttachment - Retrieve whether the OPC package contains a package thumbnail.
	* @return returns whether the OPC package contains a package thumbnail
	*/
	bool CModel::HasPackageThumbnailAttachment()
	{
		bool resultHasThumbnail = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_HasPackageThumbnailAttachment(m_pHandle, &resultHasThumbnail));
		
		return resultHasThumbnail;
	}
	
	/**
	* CModel::CreatePackageThumbnailAttachment - Create a new or the existing package thumbnail for the OPC package.
	* @return Instance of a new or the existing thumbnailattachment object.
	*/
	PAttachment CModel::CreatePackageThumbnailAttachment()
	{
		Lib3MFHandle hAttachment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_CreatePackageThumbnailAttachment(m_pHandle, &hAttachment));
		
		if (!hAttachment) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachment)));
	}
	
	/**
	* CModel::GetPackageThumbnailAttachment - Get the attachment to the OPC package containing the package thumbnail.
	* @return Instance of the thumbnailattachment object or NULL.
	*/
	PAttachment CModel::GetPackageThumbnailAttachment()
	{
		Lib3MFHandle hAttachment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetPackageThumbnailAttachment(m_pHandle, &hAttachment));
		
		if (hAttachment) {
			return std::shared_ptr<CAttachment>(dynamic_cast<CAttachment*>(m_pWrapper->polymorphicFactory(hAttachment)));
		} else {
			return nullptr;
		}
	}
	
	/**
	* CModel::RemovePackageThumbnailAttachment - Remove the attachment to the OPC package containing the package thumbnail.
	*/
	void CModel::RemovePackageThumbnailAttachment()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_RemovePackageThumbnailAttachment(m_pHandle));
	}
	
	/**
	* CModel::AddCustomContentType - Adds a new Content Type to the model.
	* @param[in] sExtension - File Extension
	* @param[in] sContentType - Content Type Identifier
	*/
	void CModel::AddCustomContentType(const std::string & sExtension, const std::string & sContentType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_AddCustomContentType(m_pHandle, sExtension.c_str(), sContentType.c_str()));
	}
	
	/**
	* CModel::RemoveCustomContentType - Removes a custom Content Type from the model (UTF8 version).
	* @param[in] sExtension - File Extension
	*/
	void CModel::RemoveCustomContentType(const std::string & sExtension)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_RemoveCustomContentType(m_pHandle, sExtension.c_str()));
	}
	
	/**
	* CModel::SetRandomNumberCallback - Sets the random number generator callback for use in the library
	* @param[in] pTheCallback - The callback used to generate random numbers
	* @param[in] pUserData - Userdata to be passed to the callback function
	*/
	void CModel::SetRandomNumberCallback(const RandomNumberCallback pTheCallback, const Lib3MF_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Model_SetRandomNumberCallback(m_pHandle, pTheCallback, pUserData));
	}
	
	/**
	* CModel::GetKeyStore - Gets the keystore associated with this model
	* @return The package keystore
	*/
	PKeyStore CModel::GetKeyStore()
	{
		Lib3MFHandle hKeyStore = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_GetKeyStore(m_pHandle, &hKeyStore));
		
		if (!hKeyStore) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CKeyStore>(dynamic_cast<CKeyStore*>(m_pWrapper->polymorphicFactory(hKeyStore)));
	}
	
	/**
	* CModel::CreatePersistentSourceFromFile - Creates an OPC Reader Source from a file.
	* @param[in] sFilename - Filename to read from
	* @return The instance of the created reader source
	*/
	PPersistentReaderSource CModel::CreatePersistentSourceFromFile(const std::string & sFilename)
	{
		Lib3MFHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_CreatePersistentSourceFromFile(m_pHandle, sFilename.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPersistentReaderSource>(dynamic_cast<CPersistentReaderSource*>(m_pWrapper->polymorphicFactory(hInstance)));
	}
	
	/**
	* CModel::CreatePersistentSourceFromBuffer - Creates an OPC Reader Source from a memory buffer. The memory buffer MUST exist as long as the Source object exists.
	* @param[in] BufferBuffer - Buffer to read from
	* @return The instance of the created reader source
	*/
	PPersistentReaderSource CModel::CreatePersistentSourceFromBuffer(const CInputVector<Lib3MF_uint8> & BufferBuffer)
	{
		Lib3MFHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_CreatePersistentSourceFromBuffer(m_pHandle, (Lib3MF_uint64)BufferBuffer.size(), BufferBuffer.data(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPersistentReaderSource>(dynamic_cast<CPersistentReaderSource*>(m_pWrapper->polymorphicFactory(hInstance)));
	}
	
	/**
	* CModel::CreatePersistentSourceFromCallback - Creates an OPC Reader Source from a data provided by a callback function. The callbacks MUST exist as long as the source object exists.
	* @param[in] pTheReadCallback - Callback to call for reading a data chunk
	* @param[in] nStreamSize - number of bytes the callback returns
	* @param[in] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[in] pUserData - Userdata that is passed to the callback function
	* @return The instance of the created reader source
	*/
	PPersistentReaderSource CModel::CreatePersistentSourceFromCallback(const ReadCallback pTheReadCallback, const Lib3MF_uint64 nStreamSize, const SeekCallback pTheSeekCallback, const Lib3MF_pvoid pUserData)
	{
		Lib3MFHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Model_CreatePersistentSourceFromCallback(m_pHandle, pTheReadCallback, nStreamSize, pTheSeekCallback, pUserData, &hInstance));
		
		if (!hInstance) {
			CheckError(LIB3MF_ERROR_INVALIDPARAM);
		}
		return std::shared_ptr<CPersistentReaderSource>(dynamic_cast<CPersistentReaderSource*>(m_pWrapper->polymorphicFactory(hInstance)));
	}

} // namespace Lib3MF

#endif // __LIB3MF_CPPHEADER_DYNAMIC_CPP

