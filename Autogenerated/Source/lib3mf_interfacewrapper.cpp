/*++

Copyright (C) 2023 3MF Consortium (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of the 3MF Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.4.0

*/

#include "lib3mf_abi.hpp"
#include "lib3mf_interfaces.hpp"
#include "lib3mf_interfaceexception.hpp"
#include "lib3mf_interfacejournal.hpp"

#include <map>

using namespace Lib3MF::Impl;

PLib3MFInterfaceJournal m_GlobalJournal;

Lib3MFResult handleLib3MFException(IBase * pIBaseClass, ELib3MFInterfaceException & Exception, CLib3MFInterfaceJournalEntry * pJournalEntry = nullptr)
{
	Lib3MFResult errorCode = Exception.getErrorCode();

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

Lib3MFResult handleStdException(IBase * pIBaseClass, std::exception & Exception, CLib3MFInterfaceJournalEntry * pJournalEntry = nullptr)
{
	Lib3MFResult errorCode = LIB3MF_ERROR_GENERICEXCEPTION;

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

Lib3MFResult handleUnhandledException(IBase * pIBaseClass, CLib3MFInterfaceJournalEntry * pJournalEntry = nullptr)
{
	Lib3MFResult errorCode = LIB3MF_ERROR_GENERICEXCEPTION;

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/
Lib3MFResult lib3mf_base_classtypeid(Lib3MF_Base pBase, Lib3MF_uint64 * pClassTypeId)
{
	IBase* pIBaseClass = (IBase *)pBase;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBase, "Base", "ClassTypeId");
		}
		if (pClassTypeId == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pClassTypeId = pIBase->ClassTypeId();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("ClassTypeId", *pClassTypeId);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Writer
**************************************************************************************************************************/
Lib3MFResult lib3mf_writer_writetofile(Lib3MF_Writer pWriter, const char * pFilename)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "WriteToFile");
			pJournalEntry->addStringParameter("Filename", pFilename);
		}
		if (pFilename == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sFilename(pFilename);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->WriteToFile(sFilename);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_getstreamsize(Lib3MF_Writer pWriter, Lib3MF_uint64 * pStreamSize)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "GetStreamSize");
		}
		if (pStreamSize == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pStreamSize = pIWriter->GetStreamSize();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("StreamSize", *pStreamSize);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_writetobuffer(Lib3MF_Writer pWriter, const Lib3MF_uint64 nBufferBufferSize, Lib3MF_uint64* pBufferNeededCount, Lib3MF_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "WriteToBuffer");
		}
		if ((!pBufferBuffer) && !(pBufferNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->WriteToBuffer(nBufferBufferSize, pBufferNeededCount, pBufferBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_writetocallback(Lib3MF_Writer pWriter, Lib3MFWriteCallback pTheWriteCallback, Lib3MFSeekCallback pTheSeekCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "WriteToCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->WriteToCallback(pTheWriteCallback, pTheSeekCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_setprogresscallback(Lib3MF_Writer pWriter, Lib3MFProgressCallback pProgressCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "SetProgressCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->SetProgressCallback(pProgressCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_getdecimalprecision(Lib3MF_Writer pWriter, Lib3MF_uint32 * pDecimalPrecision)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "GetDecimalPrecision");
		}
		if (pDecimalPrecision == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pDecimalPrecision = pIWriter->GetDecimalPrecision();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("DecimalPrecision", *pDecimalPrecision);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_setdecimalprecision(Lib3MF_Writer pWriter, Lib3MF_uint32 nDecimalPrecision)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "SetDecimalPrecision");
			pJournalEntry->addUInt32Parameter("DecimalPrecision", nDecimalPrecision);
		}
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->SetDecimalPrecision(nDecimalPrecision);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_setstrictmodeactive(Lib3MF_Writer pWriter, bool bStrictModeActive)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "SetStrictModeActive");
			pJournalEntry->addBooleanParameter("StrictModeActive", bStrictModeActive);
		}
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->SetStrictModeActive(bStrictModeActive);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_getstrictmodeactive(Lib3MF_Writer pWriter, bool * pStrictModeActive)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "GetStrictModeActive");
		}
		if (pStrictModeActive == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pStrictModeActive = pIWriter->GetStrictModeActive();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("StrictModeActive", *pStrictModeActive);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_getwarning(Lib3MF_Writer pWriter, Lib3MF_uint32 nIndex, Lib3MF_uint32 * pErrorCode, const Lib3MF_uint32 nWarningBufferSize, Lib3MF_uint32* pWarningNeededChars, char * pWarningBuffer)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "GetWarning");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (!pErrorCode)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pWarningBuffer) && !(pWarningNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sWarning("");
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pWarningBuffer == nullptr);
		if (isCacheCall) {
			sWarning = pIWriter->GetWarning(nIndex, *pErrorCode);

			pIWriter->_setCache (new ParameterCache_2<Lib3MF_uint32, std::string> (*pErrorCode, sWarning));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<Lib3MF_uint32, std::string>*> (pIWriter->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pErrorCode, sWarning);
			pIWriter->_setCache (nullptr);
		}
		
		if (pWarningNeededChars)
			*pWarningNeededChars = (Lib3MF_uint32) (sWarning.size()+1);
		if (pWarningBuffer) {
			if (sWarning.size() >= nWarningBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iWarning = 0; iWarning < sWarning.size(); iWarning++)
				pWarningBuffer[iWarning] = sWarning[iWarning];
			pWarningBuffer[sWarning.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("ErrorCode", *pErrorCode);
			pJournalEntry->addStringResult("Warning", sWarning.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_getwarningcount(Lib3MF_Writer pWriter, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "GetWarningCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIWriter->GetWarningCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_addkeywrappingcallback(Lib3MF_Writer pWriter, const char * pConsumerID, Lib3MFKeyWrappingCallback pTheCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "AddKeyWrappingCallback");
			pJournalEntry->addStringParameter("ConsumerID", pConsumerID);
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		if (pConsumerID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sConsumerID(pConsumerID);
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->AddKeyWrappingCallback(sConsumerID, pTheCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_writer_setcontentencryptioncallback(Lib3MF_Writer pWriter, Lib3MFContentEncryptionCallback pTheCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pWriter;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pWriter, "Writer", "SetContentEncryptionCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IWriter* pIWriter = dynamic_cast<IWriter*>(pIBaseClass);
		if (!pIWriter)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIWriter->SetContentEncryptionCallback(pTheCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Reader
**************************************************************************************************************************/
Lib3MFResult lib3mf_reader_readfromfile(Lib3MF_Reader pReader, const char * pFilename)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "ReadFromFile");
			pJournalEntry->addStringParameter("Filename", pFilename);
		}
		if (pFilename == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sFilename(pFilename);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->ReadFromFile(sFilename);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_readfrombuffer(Lib3MF_Reader pReader, Lib3MF_uint64 nBufferBufferSize, const Lib3MF_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "ReadFromBuffer");
		}
		if ( (!pBufferBuffer) && (nBufferBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->ReadFromBuffer(nBufferBufferSize, pBufferBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_readfromcallback(Lib3MF_Reader pReader, Lib3MFReadCallback pTheReadCallback, Lib3MF_uint64 nStreamSize, Lib3MFSeekCallback pTheSeekCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "ReadFromCallback");
			pJournalEntry->addUInt64Parameter("StreamSize", nStreamSize);
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->ReadFromCallback(pTheReadCallback, nStreamSize, pTheSeekCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_setprogresscallback(Lib3MF_Reader pReader, Lib3MFProgressCallback pProgressCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "SetProgressCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->SetProgressCallback(pProgressCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_addrelationtoread(Lib3MF_Reader pReader, const char * pRelationShipType)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "AddRelationToRead");
			pJournalEntry->addStringParameter("RelationShipType", pRelationShipType);
		}
		if (pRelationShipType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sRelationShipType(pRelationShipType);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->AddRelationToRead(sRelationShipType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_removerelationtoread(Lib3MF_Reader pReader, const char * pRelationShipType)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "RemoveRelationToRead");
			pJournalEntry->addStringParameter("RelationShipType", pRelationShipType);
		}
		if (pRelationShipType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sRelationShipType(pRelationShipType);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->RemoveRelationToRead(sRelationShipType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_setstrictmodeactive(Lib3MF_Reader pReader, bool bStrictModeActive)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "SetStrictModeActive");
			pJournalEntry->addBooleanParameter("StrictModeActive", bStrictModeActive);
		}
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->SetStrictModeActive(bStrictModeActive);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_getstrictmodeactive(Lib3MF_Reader pReader, bool * pStrictModeActive)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "GetStrictModeActive");
		}
		if (pStrictModeActive == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pStrictModeActive = pIReader->GetStrictModeActive();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("StrictModeActive", *pStrictModeActive);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_getwarning(Lib3MF_Reader pReader, Lib3MF_uint32 nIndex, Lib3MF_uint32 * pErrorCode, const Lib3MF_uint32 nWarningBufferSize, Lib3MF_uint32* pWarningNeededChars, char * pWarningBuffer)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "GetWarning");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (!pErrorCode)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pWarningBuffer) && !(pWarningNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sWarning("");
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pWarningBuffer == nullptr);
		if (isCacheCall) {
			sWarning = pIReader->GetWarning(nIndex, *pErrorCode);

			pIReader->_setCache (new ParameterCache_2<Lib3MF_uint32, std::string> (*pErrorCode, sWarning));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<Lib3MF_uint32, std::string>*> (pIReader->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pErrorCode, sWarning);
			pIReader->_setCache (nullptr);
		}
		
		if (pWarningNeededChars)
			*pWarningNeededChars = (Lib3MF_uint32) (sWarning.size()+1);
		if (pWarningBuffer) {
			if (sWarning.size() >= nWarningBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iWarning = 0; iWarning < sWarning.size(); iWarning++)
				pWarningBuffer[iWarning] = sWarning[iWarning];
			pWarningBuffer[sWarning.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("ErrorCode", *pErrorCode);
			pJournalEntry->addStringResult("Warning", sWarning.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_getwarningcount(Lib3MF_Reader pReader, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "GetWarningCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIReader->GetWarningCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_addkeywrappingcallback(Lib3MF_Reader pReader, const char * pConsumerID, Lib3MFKeyWrappingCallback pTheCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "AddKeyWrappingCallback");
			pJournalEntry->addStringParameter("ConsumerID", pConsumerID);
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		if (pConsumerID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sConsumerID(pConsumerID);
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->AddKeyWrappingCallback(sConsumerID, pTheCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_reader_setcontentencryptioncallback(Lib3MF_Reader pReader, Lib3MFContentEncryptionCallback pTheCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pReader;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pReader, "Reader", "SetContentEncryptionCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IReader* pIReader = dynamic_cast<IReader*>(pIBaseClass);
		if (!pIReader)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIReader->SetContentEncryptionCallback(pTheCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for PackagePart
**************************************************************************************************************************/
Lib3MFResult lib3mf_packagepart_getpath(Lib3MF_PackagePart pPackagePart, const Lib3MF_uint32 nPathBufferSize, Lib3MF_uint32* pPathNeededChars, char * pPathBuffer)
{
	IBase* pIBaseClass = (IBase *)pPackagePart;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pPackagePart, "PackagePart", "GetPath");
		}
		if ( (!pPathBuffer) && !(pPathNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath("");
		IPackagePart* pIPackagePart = dynamic_cast<IPackagePart*>(pIBaseClass);
		if (!pIPackagePart)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPathBuffer == nullptr);
		if (isCacheCall) {
			sPath = pIPackagePart->GetPath();

			pIPackagePart->_setCache (new ParameterCache_1<std::string> (sPath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPackagePart->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPath);
			pIPackagePart->_setCache (nullptr);
		}
		
		if (pPathNeededChars)
			*pPathNeededChars = (Lib3MF_uint32) (sPath.size()+1);
		if (pPathBuffer) {
			if (sPath.size() >= nPathBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPath = 0; iPath < sPath.size(); iPath++)
				pPathBuffer[iPath] = sPath[iPath];
			pPathBuffer[sPath.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Path", sPath.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_packagepart_setpath(Lib3MF_PackagePart pPackagePart, const char * pPath)
{
	IBase* pIBaseClass = (IBase *)pPackagePart;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pPackagePart, "PackagePart", "SetPath");
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		IPackagePart* pIPackagePart = dynamic_cast<IPackagePart*>(pIBaseClass);
		if (!pIPackagePart)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIPackagePart->SetPath(sPath);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Resource
**************************************************************************************************************************/
Lib3MFResult lib3mf_resource_getresourceid(Lib3MF_Resource pResource, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pResource;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResource, "Resource", "GetResourceID");
		}
		if (pUniqueResourceID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResource* pIResource = dynamic_cast<IResource*>(pIBaseClass);
		if (!pIResource)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUniqueResourceID = pIResource->GetResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resource_getuniqueresourceid(Lib3MF_Resource pResource, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pResource;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResource, "Resource", "GetUniqueResourceID");
		}
		if (pUniqueResourceID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResource* pIResource = dynamic_cast<IResource*>(pIBaseClass);
		if (!pIResource)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUniqueResourceID = pIResource->GetUniqueResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resource_packagepart(Lib3MF_Resource pResource, Lib3MF_PackagePart * pPackagePart)
{
	IBase* pIBaseClass = (IBase *)pResource;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResource, "Resource", "PackagePart");
		}
		if (pPackagePart == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBasePackagePart(nullptr);
		IResource* pIResource = dynamic_cast<IResource*>(pIBaseClass);
		if (!pIResource)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePackagePart = pIResource->PackagePart();

		*pPackagePart = (IBase*)(pBasePackagePart);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("PackagePart", *pPackagePart);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resource_setpackagepart(Lib3MF_Resource pResource, Lib3MF_PackagePart pPackagePart)
{
	IBase* pIBaseClass = (IBase *)pResource;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResource, "Resource", "SetPackagePart");
			pJournalEntry->addHandleParameter("PackagePart", pPackagePart);
		}
		IBase* pIBaseClassPackagePart = (IBase *)pPackagePart;
		IPackagePart* pIPackagePart = dynamic_cast<IPackagePart*>(pIBaseClassPackagePart);
		if (!pIPackagePart)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IResource* pIResource = dynamic_cast<IResource*>(pIBaseClass);
		if (!pIResource)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIResource->SetPackagePart(pIPackagePart);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resource_getmodelresourceid(Lib3MF_Resource pResource, Lib3MF_uint32 * pModelResourceId)
{
	IBase* pIBaseClass = (IBase *)pResource;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResource, "Resource", "GetModelResourceID");
		}
		if (pModelResourceId == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResource* pIResource = dynamic_cast<IResource*>(pIBaseClass);
		if (!pIResource)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pModelResourceId = pIResource->GetModelResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("ModelResourceId", *pModelResourceId);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ResourceIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_resourceiterator_movenext(Lib3MF_ResourceIterator pResourceIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pResourceIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceIterator, "ResourceIterator", "MoveNext");
		}
		if (pHasNext == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceIterator* pIResourceIterator = dynamic_cast<IResourceIterator*>(pIBaseClass);
		if (!pIResourceIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasNext = pIResourceIterator->MoveNext();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasNext", *pHasNext);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourceiterator_moveprevious(Lib3MF_ResourceIterator pResourceIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pResourceIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceIterator, "ResourceIterator", "MovePrevious");
		}
		if (pHasPrevious == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceIterator* pIResourceIterator = dynamic_cast<IResourceIterator*>(pIBaseClass);
		if (!pIResourceIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIResourceIterator->MovePrevious();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasPrevious", *pHasPrevious);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourceiterator_getcurrent(Lib3MF_ResourceIterator pResourceIterator, Lib3MF_Resource * pResource)
{
	IBase* pIBaseClass = (IBase *)pResourceIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceIterator, "ResourceIterator", "GetCurrent");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IResourceIterator* pIResourceIterator = dynamic_cast<IResourceIterator*>(pIBaseClass);
		if (!pIResourceIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIResourceIterator->GetCurrent();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourceiterator_clone(Lib3MF_ResourceIterator pResourceIterator, Lib3MF_ResourceIterator * pOutResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pResourceIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceIterator, "ResourceIterator", "Clone");
		}
		if (pOutResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseOutResourceIterator(nullptr);
		IResourceIterator* pIResourceIterator = dynamic_cast<IResourceIterator*>(pIBaseClass);
		if (!pIResourceIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseOutResourceIterator = pIResourceIterator->Clone();

		*pOutResourceIterator = (IBase*)(pBaseOutResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("OutResourceIterator", *pOutResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourceiterator_count(Lib3MF_ResourceIterator pResourceIterator, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pResourceIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceIterator, "ResourceIterator", "Count");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceIterator* pIResourceIterator = dynamic_cast<IResourceIterator*>(pIBaseClass);
		if (!pIResourceIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIResourceIterator->Count();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for SliceStackIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_slicestackiterator_getcurrentslicestack(Lib3MF_SliceStackIterator pSliceStackIterator, Lib3MF_SliceStack * pResource)
{
	IBase* pIBaseClass = (IBase *)pSliceStackIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStackIterator, "SliceStackIterator", "GetCurrentSliceStack");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		ISliceStackIterator* pISliceStackIterator = dynamic_cast<ISliceStackIterator*>(pIBaseClass);
		if (!pISliceStackIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pISliceStackIterator->GetCurrentSliceStack();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ObjectIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_objectiterator_getcurrentobject(Lib3MF_ObjectIterator pObjectIterator, Lib3MF_Object * pResource)
{
	IBase* pIBaseClass = (IBase *)pObjectIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObjectIterator, "ObjectIterator", "GetCurrentObject");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IObjectIterator* pIObjectIterator = dynamic_cast<IObjectIterator*>(pIBaseClass);
		if (!pIObjectIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIObjectIterator->GetCurrentObject();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MeshObjectIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_meshobjectiterator_getcurrentmeshobject(Lib3MF_MeshObjectIterator pMeshObjectIterator, Lib3MF_MeshObject * pResource)
{
	IBase* pIBaseClass = (IBase *)pMeshObjectIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObjectIterator, "MeshObjectIterator", "GetCurrentMeshObject");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IMeshObjectIterator* pIMeshObjectIterator = dynamic_cast<IMeshObjectIterator*>(pIBaseClass);
		if (!pIMeshObjectIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIMeshObjectIterator->GetCurrentMeshObject();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ComponentsObjectIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_componentsobjectiterator_getcurrentcomponentsobject(Lib3MF_ComponentsObjectIterator pComponentsObjectIterator, Lib3MF_ComponentsObject * pResource)
{
	IBase* pIBaseClass = (IBase *)pComponentsObjectIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponentsObjectIterator, "ComponentsObjectIterator", "GetCurrentComponentsObject");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IComponentsObjectIterator* pIComponentsObjectIterator = dynamic_cast<IComponentsObjectIterator*>(pIBaseClass);
		if (!pIComponentsObjectIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIComponentsObjectIterator->GetCurrentComponentsObject();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Texture2DIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_texture2diterator_getcurrenttexture2d(Lib3MF_Texture2DIterator pTexture2DIterator, Lib3MF_Texture2D * pResource)
{
	IBase* pIBaseClass = (IBase *)pTexture2DIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DIterator, "Texture2DIterator", "GetCurrentTexture2D");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		ITexture2DIterator* pITexture2DIterator = dynamic_cast<ITexture2DIterator*>(pIBaseClass);
		if (!pITexture2DIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pITexture2DIterator->GetCurrentTexture2D();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BaseMaterialGroupIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup(Lib3MF_BaseMaterialGroupIterator pBaseMaterialGroupIterator, Lib3MF_BaseMaterialGroup * pResource)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroupIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroupIterator, "BaseMaterialGroupIterator", "GetCurrentBaseMaterialGroup");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IBaseMaterialGroupIterator* pIBaseMaterialGroupIterator = dynamic_cast<IBaseMaterialGroupIterator*>(pIBaseClass);
		if (!pIBaseMaterialGroupIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIBaseMaterialGroupIterator->GetCurrentBaseMaterialGroup();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ColorGroupIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_colorgroupiterator_getcurrentcolorgroup(Lib3MF_ColorGroupIterator pColorGroupIterator, Lib3MF_ColorGroup * pResource)
{
	IBase* pIBaseClass = (IBase *)pColorGroupIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroupIterator, "ColorGroupIterator", "GetCurrentColorGroup");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IColorGroupIterator* pIColorGroupIterator = dynamic_cast<IColorGroupIterator*>(pIBaseClass);
		if (!pIColorGroupIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIColorGroupIterator->GetCurrentColorGroup();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Texture2DGroupIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup(Lib3MF_Texture2DGroupIterator pTexture2DGroupIterator, Lib3MF_Texture2DGroup * pResource)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroupIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroupIterator, "Texture2DGroupIterator", "GetCurrentTexture2DGroup");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		ITexture2DGroupIterator* pITexture2DGroupIterator = dynamic_cast<ITexture2DGroupIterator*>(pIBaseClass);
		if (!pITexture2DGroupIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pITexture2DGroupIterator->GetCurrentTexture2DGroup();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for CompositeMaterialsIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_compositematerialsiterator_getcurrentcompositematerials(Lib3MF_CompositeMaterialsIterator pCompositeMaterialsIterator, Lib3MF_CompositeMaterials * pResource)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterialsIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterialsIterator, "CompositeMaterialsIterator", "GetCurrentCompositeMaterials");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		ICompositeMaterialsIterator* pICompositeMaterialsIterator = dynamic_cast<ICompositeMaterialsIterator*>(pIBaseClass);
		if (!pICompositeMaterialsIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pICompositeMaterialsIterator->GetCurrentCompositeMaterials();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MultiPropertyGroupIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup(Lib3MF_MultiPropertyGroupIterator pMultiPropertyGroupIterator, Lib3MF_MultiPropertyGroup * pResource)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroupIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroupIterator, "MultiPropertyGroupIterator", "GetCurrentMultiPropertyGroup");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IMultiPropertyGroupIterator* pIMultiPropertyGroupIterator = dynamic_cast<IMultiPropertyGroupIterator*>(pIBaseClass);
		if (!pIMultiPropertyGroupIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIMultiPropertyGroupIterator->GetCurrentMultiPropertyGroup();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Image3DIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_image3diterator_getcurrentimage3d(Lib3MF_Image3DIterator pImage3DIterator, Lib3MF_Image3D * pResource)
{
	IBase* pIBaseClass = (IBase *)pImage3DIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImage3DIterator, "Image3DIterator", "GetCurrentImage3D");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IImage3DIterator* pIImage3DIterator = dynamic_cast<IImage3DIterator*>(pIBaseClass);
		if (!pIImage3DIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIImage3DIterator->GetCurrentImage3D();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarFieldIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfielditerator_getcurrentscalarfield(Lib3MF_ScalarFieldIterator pScalarFieldIterator, Lib3MF_ScalarField * pResource)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldIterator, "ScalarFieldIterator", "GetCurrentScalarField");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IScalarFieldIterator* pIScalarFieldIterator = dynamic_cast<IScalarFieldIterator*>(pIBaseClass);
		if (!pIScalarFieldIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIScalarFieldIterator->GetCurrentScalarField();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for FunctionIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_functioniterator_getcurrentfunction(Lib3MF_FunctionIterator pFunctionIterator, Lib3MF_ImplicitFunction * pResource)
{
	IBase* pIBaseClass = (IBase *)pFunctionIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFunctionIterator, "FunctionIterator", "GetCurrentFunction");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IFunctionIterator* pIFunctionIterator = dynamic_cast<IFunctionIterator*>(pIBaseClass);
		if (!pIFunctionIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIFunctionIterator->GetCurrentFunction();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DFieldIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfielditerator_getcurrentvector3dfield(Lib3MF_Vector3DFieldIterator pVector3DFieldIterator, Lib3MF_Vector3DField * pResource)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldIterator, "Vector3DFieldIterator", "GetCurrentVector3DField");
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IVector3DFieldIterator* pIVector3DFieldIterator = dynamic_cast<IVector3DFieldIterator*>(pIBaseClass);
		if (!pIVector3DFieldIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIVector3DFieldIterator->GetCurrentVector3DField();

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MetaData
**************************************************************************************************************************/
Lib3MFResult lib3mf_metadata_getnamespace(Lib3MF_MetaData pMetaData, const Lib3MF_uint32 nNameSpaceBufferSize, Lib3MF_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetNameSpace");
		}
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr);
		if (isCacheCall) {
			sNameSpace = pIMetaData->GetNameSpace();

			pIMetaData->_setCache (new ParameterCache_1<std::string> (sNameSpace));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIMetaData->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace);
			pIMetaData->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (Lib3MF_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("NameSpace", sNameSpace.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_setnamespace(Lib3MF_MetaData pMetaData, const char * pNameSpace)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "SetNameSpace");
			pJournalEntry->addStringParameter("NameSpace", pNameSpace);
		}
		if (pNameSpace == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaData->SetNameSpace(sNameSpace);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_getname(Lib3MF_MetaData pMetaData, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIMetaData->GetName();

			pIMetaData->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIMetaData->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIMetaData->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_setname(Lib3MF_MetaData pMetaData, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaData->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_getkey(Lib3MF_MetaData pMetaData, const Lib3MF_uint32 nKeyBufferSize, Lib3MF_uint32* pKeyNeededChars, char * pKeyBuffer)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetKey");
		}
		if ( (!pKeyBuffer) && !(pKeyNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sKey("");
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pKeyBuffer == nullptr);
		if (isCacheCall) {
			sKey = pIMetaData->GetKey();

			pIMetaData->_setCache (new ParameterCache_1<std::string> (sKey));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIMetaData->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sKey);
			pIMetaData->_setCache (nullptr);
		}
		
		if (pKeyNeededChars)
			*pKeyNeededChars = (Lib3MF_uint32) (sKey.size()+1);
		if (pKeyBuffer) {
			if (sKey.size() >= nKeyBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iKey = 0; iKey < sKey.size(); iKey++)
				pKeyBuffer[iKey] = sKey[iKey];
			pKeyBuffer[sKey.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Key", sKey.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_getmustpreserve(Lib3MF_MetaData pMetaData, bool * pMustPreserve)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetMustPreserve");
		}
		if (pMustPreserve == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pMustPreserve = pIMetaData->GetMustPreserve();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("MustPreserve", *pMustPreserve);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_setmustpreserve(Lib3MF_MetaData pMetaData, bool bMustPreserve)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "SetMustPreserve");
			pJournalEntry->addBooleanParameter("MustPreserve", bMustPreserve);
		}
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaData->SetMustPreserve(bMustPreserve);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_gettype(Lib3MF_MetaData pMetaData, const Lib3MF_uint32 nTypeBufferSize, Lib3MF_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetType");
		}
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sType("");
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIMetaData->GetType();

			pIMetaData->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIMetaData->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIMetaData->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (Lib3MF_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Type", sType.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_settype(Lib3MF_MetaData pMetaData, const char * pType)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "SetType");
			pJournalEntry->addStringParameter("Type", pType);
		}
		if (pType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sType(pType);
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaData->SetType(sType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_getvalue(Lib3MF_MetaData pMetaData, const Lib3MF_uint32 nValueBufferSize, Lib3MF_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "GetValue");
		}
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sValue("");
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIMetaData->GetValue();

			pIMetaData->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIMetaData->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIMetaData->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (Lib3MF_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Value", sValue.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadata_setvalue(Lib3MF_MetaData pMetaData, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pMetaData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaData, "MetaData", "SetValue");
			pJournalEntry->addStringParameter("Value", pValue);
		}
		if (pValue == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sValue(pValue);
		IMetaData* pIMetaData = dynamic_cast<IMetaData*>(pIBaseClass);
		if (!pIMetaData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaData->SetValue(sValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MetaDataGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_metadatagroup_getmetadatacount(Lib3MF_MetaDataGroup pMetaDataGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "GetMetaDataCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIMetaDataGroup->GetMetaDataCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadatagroup_getmetadata(Lib3MF_MetaDataGroup pMetaDataGroup, Lib3MF_uint32 nIndex, Lib3MF_MetaData * pMetaData)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "GetMetaData");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pMetaData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMetaData(nullptr);
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMetaData = pIMetaDataGroup->GetMetaData(nIndex);

		*pMetaData = (IBase*)(pBaseMetaData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MetaData", *pMetaData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadatagroup_getmetadatabykey(Lib3MF_MetaDataGroup pMetaDataGroup, const char * pNameSpace, const char * pName, Lib3MF_MetaData * pMetaData)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "GetMetaDataByKey");
			pJournalEntry->addStringParameter("NameSpace", pNameSpace);
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pNameSpace == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pMetaData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseMetaData(nullptr);
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMetaData = pIMetaDataGroup->GetMetaDataByKey(sNameSpace, sName);

		*pMetaData = (IBase*)(pBaseMetaData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MetaData", *pMetaData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadatagroup_removemetadatabyindex(Lib3MF_MetaDataGroup pMetaDataGroup, Lib3MF_uint32 nIndex)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "RemoveMetaDataByIndex");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaDataGroup->RemoveMetaDataByIndex(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadatagroup_removemetadata(Lib3MF_MetaDataGroup pMetaDataGroup, Lib3MF_MetaData pTheMetaData)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "RemoveMetaData");
			pJournalEntry->addHandleParameter("TheMetaData", pTheMetaData);
		}
		IBase* pIBaseClassTheMetaData = (IBase *)pTheMetaData;
		IMetaData* pITheMetaData = dynamic_cast<IMetaData*>(pIBaseClassTheMetaData);
		if (!pITheMetaData)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMetaDataGroup->RemoveMetaData(pITheMetaData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_metadatagroup_addmetadata(Lib3MF_MetaDataGroup pMetaDataGroup, const char * pNameSpace, const char * pName, const char * pValue, const char * pType, bool bMustPreserve, Lib3MF_MetaData * pMetaData)
{
	IBase* pIBaseClass = (IBase *)pMetaDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMetaDataGroup, "MetaDataGroup", "AddMetaData");
			pJournalEntry->addStringParameter("NameSpace", pNameSpace);
			pJournalEntry->addStringParameter("Name", pName);
			pJournalEntry->addStringParameter("Value", pValue);
			pJournalEntry->addStringParameter("Type", pType);
			pJournalEntry->addBooleanParameter("MustPreserve", bMustPreserve);
		}
		if (pNameSpace == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pMetaData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		std::string sValue(pValue);
		std::string sType(pType);
		IBase* pBaseMetaData(nullptr);
		IMetaDataGroup* pIMetaDataGroup = dynamic_cast<IMetaDataGroup*>(pIBaseClass);
		if (!pIMetaDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMetaData = pIMetaDataGroup->AddMetaData(sNameSpace, sName, sValue, sType, bMustPreserve);

		*pMetaData = (IBase*)(pBaseMetaData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MetaData", *pMetaData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Object
**************************************************************************************************************************/
Lib3MFResult lib3mf_object_gettype(Lib3MF_Object pObject, eLib3MFObjectType * pObjectType)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetType");
		}
		if (pObjectType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pObjectType = pIObject->GetType();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("ObjectType", "ObjectType", (Lib3MF_int32)(*pObjectType));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_settype(Lib3MF_Object pObject, eLib3MFObjectType eObjectType)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetType");
			pJournalEntry->addEnumParameter("ObjectType", "ObjectType", (Lib3MF_int32)(eObjectType));
		}
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetType(eObjectType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getname(Lib3MF_Object pObject, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIObject->GetName();

			pIObject->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIObject->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIObject->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_setname(Lib3MF_Object pObject, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getpartnumber(Lib3MF_Object pObject, const Lib3MF_uint32 nPartNumberBufferSize, Lib3MF_uint32* pPartNumberNeededChars, char * pPartNumberBuffer)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetPartNumber");
		}
		if ( (!pPartNumberBuffer) && !(pPartNumberNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPartNumber("");
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPartNumberBuffer == nullptr);
		if (isCacheCall) {
			sPartNumber = pIObject->GetPartNumber();

			pIObject->_setCache (new ParameterCache_1<std::string> (sPartNumber));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIObject->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPartNumber);
			pIObject->_setCache (nullptr);
		}
		
		if (pPartNumberNeededChars)
			*pPartNumberNeededChars = (Lib3MF_uint32) (sPartNumber.size()+1);
		if (pPartNumberBuffer) {
			if (sPartNumber.size() >= nPartNumberBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPartNumber = 0; iPartNumber < sPartNumber.size(); iPartNumber++)
				pPartNumberBuffer[iPartNumber] = sPartNumber[iPartNumber];
			pPartNumberBuffer[sPartNumber.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("PartNumber", sPartNumber.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_setpartnumber(Lib3MF_Object pObject, const char * pPartNumber)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetPartNumber");
			pJournalEntry->addStringParameter("PartNumber", pPartNumber);
		}
		if (pPartNumber == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPartNumber(pPartNumber);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetPartNumber(sPartNumber);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_ismeshobject(Lib3MF_Object pObject, bool * pIsMeshObject)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "IsMeshObject");
		}
		if (pIsMeshObject == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsMeshObject = pIObject->IsMeshObject();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsMeshObject", *pIsMeshObject);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_iscomponentsobject(Lib3MF_Object pObject, bool * pIsComponentsObject)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "IsComponentsObject");
		}
		if (pIsComponentsObject == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsComponentsObject = pIObject->IsComponentsObject();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsComponentsObject", *pIsComponentsObject);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_isvalid(Lib3MF_Object pObject, bool * pIsValid)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "IsValid");
		}
		if (pIsValid == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsValid = pIObject->IsValid();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsValid", *pIsValid);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_setattachmentasthumbnail(Lib3MF_Object pObject, Lib3MF_Attachment pAttachment)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetAttachmentAsThumbnail");
			pJournalEntry->addHandleParameter("Attachment", pAttachment);
		}
		IBase* pIBaseClassAttachment = (IBase *)pAttachment;
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClassAttachment);
		if (!pIAttachment)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetAttachmentAsThumbnail(pIAttachment);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getthumbnailattachment(Lib3MF_Object pObject, Lib3MF_Attachment * pAttachment)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetThumbnailAttachment");
		}
		if (pAttachment == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseAttachment(nullptr);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachment = pIObject->GetThumbnailAttachment();

		*pAttachment = (IBase*)(pBaseAttachment);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Attachment", *pAttachment);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_clearthumbnailattachment(Lib3MF_Object pObject)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "ClearThumbnailAttachment");
		}
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->ClearThumbnailAttachment();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getoutbox(Lib3MF_Object pObject, sLib3MFBox * pOutbox)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetOutbox");
		}
		if (pOutbox == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pOutbox = pIObject->GetOutbox();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getuuid(Lib3MF_Object pObject, bool * pHasUUID, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetUUID");
		}
		if (!pHasUUID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIObject->GetUUID(*pHasUUID);

			pIObject->_setCache (new ParameterCache_2<bool, std::string> (*pHasUUID, sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<bool, std::string>*> (pIObject->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pHasUUID, sUUID);
			pIObject->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasUUID", *pHasUUID);
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_setuuid(Lib3MF_Object pObject, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetUUID");
			pJournalEntry->addStringParameter("UUID", pUUID);
		}
		if (pUUID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetUUID(sUUID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getmetadatagroup(Lib3MF_Object pObject, Lib3MF_MetaDataGroup * pMetaDataGroup)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetMetaDataGroup");
		}
		if (pMetaDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMetaDataGroup(nullptr);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMetaDataGroup = pIObject->GetMetaDataGroup();

		*pMetaDataGroup = (IBase*)(pBaseMetaDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MetaDataGroup", *pMetaDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_setslicesmeshresolution(Lib3MF_Object pObject, eLib3MFSlicesMeshResolution eMeshResolution)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "SetSlicesMeshResolution");
			pJournalEntry->addEnumParameter("MeshResolution", "SlicesMeshResolution", (Lib3MF_int32)(eMeshResolution));
		}
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->SetSlicesMeshResolution(eMeshResolution);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getslicesmeshresolution(Lib3MF_Object pObject, eLib3MFSlicesMeshResolution * pMeshResolution)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetSlicesMeshResolution");
		}
		if (pMeshResolution == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pMeshResolution = pIObject->GetSlicesMeshResolution();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("MeshResolution", "SlicesMeshResolution", (Lib3MF_int32)(*pMeshResolution));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_hasslices(Lib3MF_Object pObject, bool bRecursive, bool * pHasSlices)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "HasSlices");
			pJournalEntry->addBooleanParameter("Recursive", bRecursive);
		}
		if (pHasSlices == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasSlices = pIObject->HasSlices(bRecursive);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasSlices", *pHasSlices);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_clearslicestack(Lib3MF_Object pObject)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "ClearSliceStack");
		}
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->ClearSliceStack();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_getslicestack(Lib3MF_Object pObject, Lib3MF_SliceStack * pSliceStackInstance)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "GetSliceStack");
		}
		if (pSliceStackInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseSliceStackInstance(nullptr);
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSliceStackInstance = pIObject->GetSliceStack();

		*pSliceStackInstance = (IBase*)(pBaseSliceStackInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("SliceStackInstance", *pSliceStackInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_object_assignslicestack(Lib3MF_Object pObject, Lib3MF_SliceStack pSliceStackInstance)
{
	IBase* pIBaseClass = (IBase *)pObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pObject, "Object", "AssignSliceStack");
			pJournalEntry->addHandleParameter("SliceStackInstance", pSliceStackInstance);
		}
		IBase* pIBaseClassSliceStackInstance = (IBase *)pSliceStackInstance;
		ISliceStack* pISliceStackInstance = dynamic_cast<ISliceStack*>(pIBaseClassSliceStackInstance);
		if (!pISliceStackInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClass);
		if (!pIObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIObject->AssignSliceStack(pISliceStackInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MeshObject
**************************************************************************************************************************/
Lib3MFResult lib3mf_meshobject_getvertexcount(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 * pVertexCount)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetVertexCount");
		}
		if (pVertexCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pVertexCount = pIMeshObject->GetVertexCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("VertexCount", *pVertexCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_gettrianglecount(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 * pVertexCount)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetTriangleCount");
		}
		if (pVertexCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pVertexCount = pIMeshObject->GetTriangleCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("VertexCount", *pVertexCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_getvertex(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, sLib3MFPosition * pCoordinates)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetVertex");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pCoordinates == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCoordinates = pIMeshObject->GetVertex(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_setvertex(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, const sLib3MFPosition * pCoordinates)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetVertex");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetVertex(nIndex, *pCoordinates);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_addvertex(Lib3MF_MeshObject pMeshObject, const sLib3MFPosition * pCoordinates, Lib3MF_uint32 * pNewIndex)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "AddVertex");
		}
		if (pNewIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pNewIndex = pIMeshObject->AddVertex(*pCoordinates);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("NewIndex", *pNewIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_getvertices(Lib3MF_MeshObject pMeshObject, const Lib3MF_uint64 nVerticesBufferSize, Lib3MF_uint64* pVerticesNeededCount, sLib3MFPosition * pVerticesBuffer)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetVertices");
		}
		if ((!pVerticesBuffer) && !(pVerticesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->GetVertices(nVerticesBufferSize, pVerticesNeededCount, pVerticesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_gettriangle(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, sLib3MFTriangle * pIndices)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetTriangle");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pIndices == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIndices = pIMeshObject->GetTriangle(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_settriangle(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, const sLib3MFTriangle * pIndices)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetTriangle");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetTriangle(nIndex, *pIndices);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_addtriangle(Lib3MF_MeshObject pMeshObject, const sLib3MFTriangle * pIndices, Lib3MF_uint32 * pNewIndex)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "AddTriangle");
		}
		if (pNewIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pNewIndex = pIMeshObject->AddTriangle(*pIndices);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("NewIndex", *pNewIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_gettriangleindices(Lib3MF_MeshObject pMeshObject, const Lib3MF_uint64 nIndicesBufferSize, Lib3MF_uint64* pIndicesNeededCount, sLib3MFTriangle * pIndicesBuffer)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetTriangleIndices");
		}
		if ((!pIndicesBuffer) && !(pIndicesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->GetTriangleIndices(nIndicesBufferSize, pIndicesNeededCount, pIndicesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_setobjectlevelproperty(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nUniqueResourceID, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetObjectLevelProperty");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetObjectLevelProperty(nUniqueResourceID, nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_getobjectlevelproperty(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 * pUniqueResourceID, Lib3MF_uint32 * pPropertyID, bool * pHasObjectLevelProperty)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetObjectLevelProperty");
		}
		if (!pUniqueResourceID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pPropertyID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pHasObjectLevelProperty == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasObjectLevelProperty = pIMeshObject->GetObjectLevelProperty(*pUniqueResourceID, *pPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->addBooleanResult("HasObjectLevelProperty", *pHasObjectLevelProperty);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_settriangleproperties(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, const sLib3MFTriangleProperties * pProperties)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetTriangleProperties");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetTriangleProperties(nIndex, *pProperties);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_gettriangleproperties(Lib3MF_MeshObject pMeshObject, Lib3MF_uint32 nIndex, sLib3MFTriangleProperties * pProperty)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetTriangleProperties");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (!pProperty)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->GetTriangleProperties(nIndex, *pProperty);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_setalltriangleproperties(Lib3MF_MeshObject pMeshObject, Lib3MF_uint64 nPropertiesArrayBufferSize, const sLib3MFTriangleProperties * pPropertiesArrayBuffer)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetAllTriangleProperties");
		}
		if ( (!pPropertiesArrayBuffer) && (nPropertiesArrayBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetAllTriangleProperties(nPropertiesArrayBufferSize, pPropertiesArrayBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_getalltriangleproperties(Lib3MF_MeshObject pMeshObject, const Lib3MF_uint64 nPropertiesArrayBufferSize, Lib3MF_uint64* pPropertiesArrayNeededCount, sLib3MFTriangleProperties * pPropertiesArrayBuffer)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "GetAllTriangleProperties");
		}
		if ((!pPropertiesArrayBuffer) && !(pPropertiesArrayNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->GetAllTriangleProperties(nPropertiesArrayBufferSize, pPropertiesArrayNeededCount, pPropertiesArrayBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_clearallproperties(Lib3MF_MeshObject pMeshObject)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "ClearAllProperties");
		}
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->ClearAllProperties();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_setgeometry(Lib3MF_MeshObject pMeshObject, Lib3MF_uint64 nVerticesBufferSize, const sLib3MFPosition * pVerticesBuffer, Lib3MF_uint64 nIndicesBufferSize, const sLib3MFTriangle * pIndicesBuffer)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "SetGeometry");
		}
		if ( (!pVerticesBuffer) && (nVerticesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pIndicesBuffer) && (nIndicesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMeshObject->SetGeometry(nVerticesBufferSize, pVerticesBuffer, nIndicesBufferSize, pIndicesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_ismanifoldandoriented(Lib3MF_MeshObject pMeshObject, bool * pIsManifoldAndOriented)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "IsManifoldAndOriented");
		}
		if (pIsManifoldAndOriented == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsManifoldAndOriented = pIMeshObject->IsManifoldAndOriented();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsManifoldAndOriented", *pIsManifoldAndOriented);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_beamlattice(Lib3MF_MeshObject pMeshObject, Lib3MF_BeamLattice * pTheBeamLattice)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "BeamLattice");
		}
		if (pTheBeamLattice == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheBeamLattice(nullptr);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheBeamLattice = pIMeshObject->BeamLattice();

		*pTheBeamLattice = (IBase*)(pBaseTheBeamLattice);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheBeamLattice", *pTheBeamLattice);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_meshobject_volumedata(Lib3MF_MeshObject pMeshObject, Lib3MF_VolumeData * pTheVolumeData)
{
	IBase* pIBaseClass = (IBase *)pMeshObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMeshObject, "MeshObject", "VolumeData");
		}
		if (pTheVolumeData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVolumeData(nullptr);
		IMeshObject* pIMeshObject = dynamic_cast<IMeshObject*>(pIBaseClass);
		if (!pIMeshObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVolumeData = pIMeshObject->VolumeData();

		*pTheVolumeData = (IBase*)(pBaseTheVolumeData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVolumeData", *pTheVolumeData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BeamLattice
**************************************************************************************************************************/
Lib3MFResult lib3mf_beamlattice_getminlength(Lib3MF_BeamLattice pBeamLattice, Lib3MF_double * pMinLength)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetMinLength");
		}
		if (pMinLength == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pMinLength = pIBeamLattice->GetMinLength();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("MinLength", *pMinLength);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setminlength(Lib3MF_BeamLattice pBeamLattice, Lib3MF_double dMinLength)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetMinLength");
			pJournalEntry->addDoubleParameter("MinLength", dMinLength);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetMinLength(dMinLength);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getclipping(Lib3MF_BeamLattice pBeamLattice, eLib3MFBeamLatticeClipMode * pClipMode, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetClipping");
		}
		if (!pClipMode)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pUniqueResourceID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->GetClipping(*pClipMode, *pUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("ClipMode", "BeamLatticeClipMode", (Lib3MF_int32)(*pClipMode));
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setclipping(Lib3MF_BeamLattice pBeamLattice, eLib3MFBeamLatticeClipMode eClipMode, Lib3MF_uint32 nUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetClipping");
			pJournalEntry->addEnumParameter("ClipMode", "BeamLatticeClipMode", (Lib3MF_int32)(eClipMode));
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetClipping(eClipMode, nUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getrepresentation(Lib3MF_BeamLattice pBeamLattice, bool * pHasRepresentation, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetRepresentation");
		}
		if (pHasRepresentation == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pUniqueResourceID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasRepresentation = pIBeamLattice->GetRepresentation(*pUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasRepresentation", *pHasRepresentation);
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setrepresentation(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetRepresentation");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetRepresentation(nUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getballoptions(Lib3MF_BeamLattice pBeamLattice, eLib3MFBeamLatticeBallMode * pBallMode, Lib3MF_double * pBallRadius)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBallOptions");
		}
		if (!pBallMode)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pBallRadius)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->GetBallOptions(*pBallMode, *pBallRadius);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("BallMode", "BeamLatticeBallMode", (Lib3MF_int32)(*pBallMode));
			pJournalEntry->addDoubleResult("BallRadius", *pBallRadius);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setballoptions(Lib3MF_BeamLattice pBeamLattice, eLib3MFBeamLatticeBallMode eBallMode, Lib3MF_double dBallRadius)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetBallOptions");
			pJournalEntry->addEnumParameter("BallMode", "BeamLatticeBallMode", (Lib3MF_int32)(eBallMode));
			pJournalEntry->addDoubleParameter("BallRadius", dBallRadius);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetBallOptions(eBallMode, dBallRadius);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getbeamcount(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBeamCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBeamLattice->GetBeamCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getbeam(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nIndex, sLib3MFBeam * pBeamInfo)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBeam");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pBeamInfo == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pBeamInfo = pIBeamLattice->GetBeam(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_addbeam(Lib3MF_BeamLattice pBeamLattice, const sLib3MFBeam * pBeamInfo, Lib3MF_uint32 * pIndex)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "AddBeam");
		}
		if (pIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIndex = pIBeamLattice->AddBeam(*pBeamInfo);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Index", *pIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setbeam(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nIndex, const sLib3MFBeam * pBeamInfo)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetBeam");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetBeam(nIndex, *pBeamInfo);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setbeams(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint64 nBeamInfoBufferSize, const sLib3MFBeam * pBeamInfoBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetBeams");
		}
		if ( (!pBeamInfoBuffer) && (nBeamInfoBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetBeams(nBeamInfoBufferSize, pBeamInfoBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getbeams(Lib3MF_BeamLattice pBeamLattice, const Lib3MF_uint64 nBeamInfoBufferSize, Lib3MF_uint64* pBeamInfoNeededCount, sLib3MFBeam * pBeamInfoBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBeams");
		}
		if ((!pBeamInfoBuffer) && !(pBeamInfoNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->GetBeams(nBeamInfoBufferSize, pBeamInfoNeededCount, pBeamInfoBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getballcount(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBallCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBeamLattice->GetBallCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getball(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nIndex, sLib3MFBall * pBallInfo)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBall");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pBallInfo == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pBallInfo = pIBeamLattice->GetBall(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_addball(Lib3MF_BeamLattice pBeamLattice, const sLib3MFBall * pBallInfo, Lib3MF_uint32 * pIndex)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "AddBall");
		}
		if (pIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIndex = pIBeamLattice->AddBall(*pBallInfo);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Index", *pIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setball(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nIndex, const sLib3MFBall * pBallInfo)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetBall");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetBall(nIndex, *pBallInfo);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_setballs(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint64 nBallInfoBufferSize, const sLib3MFBall * pBallInfoBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "SetBalls");
		}
		if ( (!pBallInfoBuffer) && (nBallInfoBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->SetBalls(nBallInfoBufferSize, pBallInfoBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getballs(Lib3MF_BeamLattice pBeamLattice, const Lib3MF_uint64 nBallInfoBufferSize, Lib3MF_uint64* pBallInfoNeededCount, sLib3MFBall * pBallInfoBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBalls");
		}
		if ((!pBallInfoBuffer) && !(pBallInfoNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamLattice->GetBalls(nBallInfoBufferSize, pBallInfoNeededCount, pBallInfoBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getbeamsetcount(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBeamSetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBeamLattice->GetBeamSetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_addbeamset(Lib3MF_BeamLattice pBeamLattice, Lib3MF_BeamSet * pBeamSet)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "AddBeamSet");
		}
		if (pBeamSet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBeamSet(nullptr);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBeamSet = pIBeamLattice->AddBeamSet();

		*pBeamSet = (IBase*)(pBaseBeamSet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BeamSet", *pBeamSet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamlattice_getbeamset(Lib3MF_BeamLattice pBeamLattice, Lib3MF_uint32 nIndex, Lib3MF_BeamSet * pBeamSet)
{
	IBase* pIBaseClass = (IBase *)pBeamLattice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamLattice, "BeamLattice", "GetBeamSet");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pBeamSet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBeamSet(nullptr);
		IBeamLattice* pIBeamLattice = dynamic_cast<IBeamLattice*>(pIBaseClass);
		if (!pIBeamLattice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBeamSet = pIBeamLattice->GetBeamSet(nIndex);

		*pBeamSet = (IBase*)(pBaseBeamSet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BeamSet", *pBeamSet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarField
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfield_getname(Lib3MF_ScalarField pScalarField, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pScalarField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarField, "ScalarField", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IScalarField* pIScalarField = dynamic_cast<IScalarField*>(pIBaseClass);
		if (!pIScalarField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIScalarField->GetName();

			pIScalarField->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIScalarField->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIScalarField->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfield_setname(Lib3MF_ScalarField pScalarField, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pScalarField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarField, "ScalarField", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IScalarField* pIScalarField = dynamic_cast<IScalarField*>(pIBaseClass);
		if (!pIScalarField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarField->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfield_isfromimage3d(Lib3MF_ScalarField pScalarField, bool * pIsFromImage3D)
{
	IBase* pIBaseClass = (IBase *)pScalarField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarField, "ScalarField", "IsFromImage3D");
		}
		if (pIsFromImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarField* pIScalarField = dynamic_cast<IScalarField*>(pIBaseClass);
		if (!pIScalarField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsFromImage3D = pIScalarField->IsFromImage3D();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsFromImage3D", *pIsFromImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfield_isconstant(Lib3MF_ScalarField pScalarField, bool * pIsConstant)
{
	IBase* pIBaseClass = (IBase *)pScalarField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarField, "ScalarField", "IsConstant");
		}
		if (pIsConstant == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarField* pIScalarField = dynamic_cast<IScalarField*>(pIBaseClass);
		if (!pIScalarField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsConstant = pIScalarField->IsConstant();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsConstant", *pIsConstant);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfield_iscomposed(Lib3MF_ScalarField pScalarField, bool * pIsComposed)
{
	IBase* pIBaseClass = (IBase *)pScalarField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarField, "ScalarField", "IsComposed");
		}
		if (pIsComposed == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarField* pIScalarField = dynamic_cast<IScalarField*>(pIBaseClass);
		if (!pIScalarField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsComposed = pIScalarField->IsComposed();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsComposed", *pIsComposed);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DField
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfield_getname(Lib3MF_Vector3DField pVector3DField, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pVector3DField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DField, "Vector3DField", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IVector3DField* pIVector3DField = dynamic_cast<IVector3DField*>(pIBaseClass);
		if (!pIVector3DField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIVector3DField->GetName();

			pIVector3DField->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIVector3DField->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIVector3DField->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfield_setname(Lib3MF_Vector3DField pVector3DField, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pVector3DField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DField, "Vector3DField", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IVector3DField* pIVector3DField = dynamic_cast<IVector3DField*>(pIBaseClass);
		if (!pIVector3DField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DField->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfield_isfromimage3d(Lib3MF_Vector3DField pVector3DField, bool * pIsFromImage3D)
{
	IBase* pIBaseClass = (IBase *)pVector3DField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DField, "Vector3DField", "IsFromImage3D");
		}
		if (pIsFromImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DField* pIVector3DField = dynamic_cast<IVector3DField*>(pIBaseClass);
		if (!pIVector3DField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsFromImage3D = pIVector3DField->IsFromImage3D();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsFromImage3D", *pIsFromImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfield_isconstant(Lib3MF_Vector3DField pVector3DField, bool * pIsConstant)
{
	IBase* pIBaseClass = (IBase *)pVector3DField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DField, "Vector3DField", "IsConstant");
		}
		if (pIsConstant == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DField* pIVector3DField = dynamic_cast<IVector3DField*>(pIBaseClass);
		if (!pIVector3DField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsConstant = pIVector3DField->IsConstant();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsConstant", *pIsConstant);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfield_iscomposed(Lib3MF_Vector3DField pVector3DField, bool * pIsComposed)
{
	IBase* pIBaseClass = (IBase *)pVector3DField;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DField, "Vector3DField", "IsComposed");
		}
		if (pIsComposed == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DField* pIVector3DField = dynamic_cast<IVector3DField*>(pIBaseClass);
		if (!pIVector3DField)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsComposed = pIVector3DField->IsComposed();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsComposed", *pIsComposed);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarFieldFromImage3D
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfieldfromimage3d_getimage(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_Image3D * pImage3D)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetImage");
		}
		if (pImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseImage3D(nullptr);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseImage3D = pIScalarFieldFromImage3D->GetImage();

		*pImage3D = (IBase*)(pBaseImage3D);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Image3D", *pImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_setimage(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_Image3D pImage3D)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetImage");
			pJournalEntry->addHandleParameter("Image3D", pImage3D);
		}
		IBase* pIBaseClassImage3D = (IBase *)pImage3D;
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClassImage3D);
		if (!pIImage3D)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetImage(pIImage3D);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_setchannel(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFChannelName eName)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetChannel");
			pJournalEntry->addEnumParameter("Name", "ChannelName", (Lib3MF_int32)(eName));
		}
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetChannel(eName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_getchannel(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFChannelName * pName)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetChannel");
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pName = pIScalarFieldFromImage3D->GetChannel();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Name", "ChannelName", (Lib3MF_int32)(*pName));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_setfilter(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFTextureFilter eFilter)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetFilter");
			pJournalEntry->addEnumParameter("Filter", "TextureFilter", (Lib3MF_int32)(eFilter));
		}
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetFilter(eFilter);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_getfilter(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFTextureFilter * pFilter)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetFilter");
		}
		if (pFilter == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFilter = pIScalarFieldFromImage3D->GetFilter();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Filter", "TextureFilter", (Lib3MF_int32)(*pFilter));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_settilestyles(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFTextureTileStyle eTileStyleU, eLib3MFTextureTileStyle eTileStyleV, eLib3MFTextureTileStyle eTileStyleW)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetTileStyles");
			pJournalEntry->addEnumParameter("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(eTileStyleU));
			pJournalEntry->addEnumParameter("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(eTileStyleV));
			pJournalEntry->addEnumParameter("TileStyleW", "TextureTileStyle", (Lib3MF_int32)(eTileStyleW));
		}
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetTileStyles(eTileStyleU, eTileStyleV, eTileStyleW);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_gettilestyles(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, eLib3MFTextureTileStyle * pTileStyleU, eLib3MFTextureTileStyle * pTileStyleV, eLib3MFTextureTileStyle * pTileStyleW)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetTileStyles");
		}
		if (!pTileStyleU)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pTileStyleV)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pTileStyleW)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->GetTileStyles(*pTileStyleU, *pTileStyleV, *pTileStyleW);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleU));
			pJournalEntry->addEnumResult("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleV));
			pJournalEntry->addEnumResult("TileStyleW", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleW));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_getoffset(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_double * pOffset)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetOffset");
		}
		if (pOffset == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pOffset = pIScalarFieldFromImage3D->GetOffset();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Offset", *pOffset);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_setoffset(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_double dOffset)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetOffset");
			pJournalEntry->addDoubleParameter("Offset", dOffset);
		}
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetOffset(dOffset);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_getscale(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_double * pScale)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "GetScale");
		}
		if (pScale == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pScale = pIScalarFieldFromImage3D->GetScale();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Scale", *pScale);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldfromimage3d_setscale(Lib3MF_ScalarFieldFromImage3D pScalarFieldFromImage3D, Lib3MF_double dScale)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldFromImage3D, "ScalarFieldFromImage3D", "SetScale");
			pJournalEntry->addDoubleParameter("Scale", dScale);
		}
		IScalarFieldFromImage3D* pIScalarFieldFromImage3D = dynamic_cast<IScalarFieldFromImage3D*>(pIBaseClass);
		if (!pIScalarFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldFromImage3D->SetScale(dScale);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarFieldConstant
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfieldconstant_getvalue(Lib3MF_ScalarFieldConstant pScalarFieldConstant, Lib3MF_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldConstant, "ScalarFieldConstant", "GetValue");
		}
		if (pValue == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldConstant* pIScalarFieldConstant = dynamic_cast<IScalarFieldConstant*>(pIBaseClass);
		if (!pIScalarFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValue = pIScalarFieldConstant->GetValue();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Value", *pValue);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldconstant_setvalue(Lib3MF_ScalarFieldConstant pScalarFieldConstant, Lib3MF_double dValue)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldConstant, "ScalarFieldConstant", "SetValue");
			pJournalEntry->addDoubleParameter("Value", dValue);
		}
		IScalarFieldConstant* pIScalarFieldConstant = dynamic_cast<IScalarFieldConstant*>(pIBaseClass);
		if (!pIScalarFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldConstant->SetValue(dValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarFieldComposed
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfieldcomposed_setmethod(Lib3MF_ScalarFieldComposed pScalarFieldComposed, eLib3MFCompositionMethod eTheMethod)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "SetMethod");
			pJournalEntry->addEnumParameter("TheMethod", "CompositionMethod", (Lib3MF_int32)(eTheMethod));
		}
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldComposed->SetMethod(eTheMethod);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_getmethod(Lib3MF_ScalarFieldComposed pScalarFieldComposed, eLib3MFCompositionMethod * pTheMethod)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "GetMethod");
		}
		if (pTheMethod == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheMethod = pIScalarFieldComposed->GetMethod();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TheMethod", "CompositionMethod", (Lib3MF_int32)(*pTheMethod));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_getfactor1(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_double * pFactor1)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "GetFactor1");
		}
		if (pFactor1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFactor1 = pIScalarFieldComposed->GetFactor1();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Factor1", *pFactor1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_setfactor1(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_double dFactor1)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "SetFactor1");
			pJournalEntry->addDoubleParameter("Factor1", dFactor1);
		}
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldComposed->SetFactor1(dFactor1);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_getfactor2(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_double * pFactor2)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "GetFactor2");
		}
		if (pFactor2 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFactor2 = pIScalarFieldComposed->GetFactor2();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Factor2", *pFactor2);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_setfactor2(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_double dFactor2)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "SetFactor2");
			pJournalEntry->addDoubleParameter("Factor2", dFactor2);
		}
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldComposed->SetFactor2(dFactor2);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_scalarfieldreference1(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_ScalarFieldReference * pTheScalarFieldReference1)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "ScalarFieldReference1");
		}
		if (pTheScalarFieldReference1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldReference1(nullptr);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldReference1 = pIScalarFieldComposed->ScalarFieldReference1();

		*pTheScalarFieldReference1 = (IBase*)(pBaseTheScalarFieldReference1);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldReference1", *pTheScalarFieldReference1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_scalarfieldreference2(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_ScalarFieldReference * pTheScalarFieldReference1)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "ScalarFieldReference2");
		}
		if (pTheScalarFieldReference1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldReference1(nullptr);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldReference1 = pIScalarFieldComposed->ScalarFieldReference2();

		*pTheScalarFieldReference1 = (IBase*)(pBaseTheScalarFieldReference1);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldReference1", *pTheScalarFieldReference1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_scalarfieldcomposed_scalarfieldreferencemask(Lib3MF_ScalarFieldComposed pScalarFieldComposed, Lib3MF_ScalarFieldReference * pTheScalarFieldReferenceMask)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldComposed, "ScalarFieldComposed", "ScalarFieldReferenceMask");
		}
		if (pTheScalarFieldReferenceMask == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldReferenceMask(nullptr);
		IScalarFieldComposed* pIScalarFieldComposed = dynamic_cast<IScalarFieldComposed*>(pIBaseClass);
		if (!pIScalarFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldReferenceMask = pIScalarFieldComposed->ScalarFieldReferenceMask();

		*pTheScalarFieldReferenceMask = (IBase*)(pBaseTheScalarFieldReferenceMask);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldReferenceMask", *pTheScalarFieldReferenceMask);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DFieldFromImage3D
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfieldfromimage3d_getimage(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_Image3D * pImage3D)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "GetImage");
		}
		if (pImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseImage3D(nullptr);
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseImage3D = pIVector3DFieldFromImage3D->GetImage();

		*pImage3D = (IBase*)(pBaseImage3D);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Image3D", *pImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_setimage(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_Image3D pImage3D)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "SetImage");
			pJournalEntry->addHandleParameter("Image3D", pImage3D);
		}
		IBase* pIBaseClassImage3D = (IBase *)pImage3D;
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClassImage3D);
		if (!pIImage3D)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->SetImage(pIImage3D);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_setfilter(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, eLib3MFTextureFilter eFilter)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "SetFilter");
			pJournalEntry->addEnumParameter("Filter", "TextureFilter", (Lib3MF_int32)(eFilter));
		}
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->SetFilter(eFilter);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_getfilter(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, eLib3MFTextureFilter * pFilter)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "GetFilter");
		}
		if (pFilter == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFilter = pIVector3DFieldFromImage3D->GetFilter();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Filter", "TextureFilter", (Lib3MF_int32)(*pFilter));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_settilestyles(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, eLib3MFTextureTileStyle eTileStyleU, eLib3MFTextureTileStyle eTileStyleV, eLib3MFTextureTileStyle eTileStyleW)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "SetTileStyles");
			pJournalEntry->addEnumParameter("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(eTileStyleU));
			pJournalEntry->addEnumParameter("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(eTileStyleV));
			pJournalEntry->addEnumParameter("TileStyleW", "TextureTileStyle", (Lib3MF_int32)(eTileStyleW));
		}
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->SetTileStyles(eTileStyleU, eTileStyleV, eTileStyleW);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_gettilestyles(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, eLib3MFTextureTileStyle * pTileStyleU, eLib3MFTextureTileStyle * pTileStyleV, eLib3MFTextureTileStyle * pTileStyleW)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "GetTileStyles");
		}
		if (!pTileStyleU)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pTileStyleV)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pTileStyleW)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->GetTileStyles(*pTileStyleU, *pTileStyleV, *pTileStyleW);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleU));
			pJournalEntry->addEnumResult("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleV));
			pJournalEntry->addEnumResult("TileStyleW", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleW));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_getoffset(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_double * pOffset)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "GetOffset");
		}
		if (pOffset == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pOffset = pIVector3DFieldFromImage3D->GetOffset();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Offset", *pOffset);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_setoffset(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_double dOffset)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "SetOffset");
			pJournalEntry->addDoubleParameter("Offset", dOffset);
		}
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->SetOffset(dOffset);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_getscale(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_double * pScale)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "GetScale");
		}
		if (pScale == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pScale = pIVector3DFieldFromImage3D->GetScale();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Scale", *pScale);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldfromimage3d_setscale(Lib3MF_Vector3DFieldFromImage3D pVector3DFieldFromImage3D, Lib3MF_double dScale)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldFromImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldFromImage3D, "Vector3DFieldFromImage3D", "SetScale");
			pJournalEntry->addDoubleParameter("Scale", dScale);
		}
		IVector3DFieldFromImage3D* pIVector3DFieldFromImage3D = dynamic_cast<IVector3DFieldFromImage3D*>(pIBaseClass);
		if (!pIVector3DFieldFromImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldFromImage3D->SetScale(dScale);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DFieldConstant
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfieldconstant_getvaluex(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double * pValueX)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "GetValueX");
		}
		if (pValueX == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValueX = pIVector3DFieldConstant->GetValueX();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("ValueX", *pValueX);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldconstant_setvaluex(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double dValueX)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "SetValueX");
			pJournalEntry->addDoubleParameter("ValueX", dValueX);
		}
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldConstant->SetValueX(dValueX);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldconstant_getvaluey(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double * pValueY)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "GetValueY");
		}
		if (pValueY == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValueY = pIVector3DFieldConstant->GetValueY();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("ValueY", *pValueY);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldconstant_setvaluey(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double dValueY)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "SetValueY");
			pJournalEntry->addDoubleParameter("ValueY", dValueY);
		}
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldConstant->SetValueY(dValueY);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldconstant_getvaluez(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double * pValueZ)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "GetValueZ");
		}
		if (pValueZ == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValueZ = pIVector3DFieldConstant->GetValueZ();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("ValueZ", *pValueZ);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldconstant_setvaluez(Lib3MF_Vector3DFieldConstant pVector3DFieldConstant, Lib3MF_double dValueZ)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldConstant;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldConstant, "Vector3DFieldConstant", "SetValueZ");
			pJournalEntry->addDoubleParameter("ValueZ", dValueZ);
		}
		IVector3DFieldConstant* pIVector3DFieldConstant = dynamic_cast<IVector3DFieldConstant*>(pIBaseClass);
		if (!pIVector3DFieldConstant)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldConstant->SetValueZ(dValueZ);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DFieldComposed
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfieldcomposed_setmethod(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, eLib3MFCompositionMethod eTheMethod)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "SetMethod");
			pJournalEntry->addEnumParameter("TheMethod", "CompositionMethod", (Lib3MF_int32)(eTheMethod));
		}
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldComposed->SetMethod(eTheMethod);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_getmethod(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, eLib3MFCompositionMethod * pTheMethod)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "GetMethod");
		}
		if (pTheMethod == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheMethod = pIVector3DFieldComposed->GetMethod();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TheMethod", "CompositionMethod", (Lib3MF_int32)(*pTheMethod));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_setspace(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, eLib3MFCompositionSpace eTheSpace)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "SetSpace");
			pJournalEntry->addEnumParameter("TheSpace", "CompositionSpace", (Lib3MF_int32)(eTheSpace));
		}
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldComposed->SetSpace(eTheSpace);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_getspace(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, eLib3MFCompositionSpace * pTheSpace)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "GetSpace");
		}
		if (pTheSpace == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheSpace = pIVector3DFieldComposed->GetSpace();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TheSpace", "CompositionSpace", (Lib3MF_int32)(*pTheSpace));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_getfactor1(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_double * pFactor1)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "GetFactor1");
		}
		if (pFactor1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFactor1 = pIVector3DFieldComposed->GetFactor1();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Factor1", *pFactor1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_setfactor1(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_double dFactor1)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "SetFactor1");
			pJournalEntry->addDoubleParameter("Factor1", dFactor1);
		}
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldComposed->SetFactor1(dFactor1);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_getfactor2(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_double * pFactor2)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "GetFactor2");
		}
		if (pFactor2 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFactor2 = pIVector3DFieldComposed->GetFactor2();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Factor2", *pFactor2);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_setfactor2(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_double dFactor2)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "SetFactor2");
			pJournalEntry->addDoubleParameter("Factor2", dFactor2);
		}
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldComposed->SetFactor2(dFactor2);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_vector3dfieldreference1(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_Vector3DFieldReference * pTheVector3DFieldReference1)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "Vector3DFieldReference1");
		}
		if (pTheVector3DFieldReference1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVector3DFieldReference1(nullptr);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVector3DFieldReference1 = pIVector3DFieldComposed->Vector3DFieldReference1();

		*pTheVector3DFieldReference1 = (IBase*)(pBaseTheVector3DFieldReference1);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVector3DFieldReference1", *pTheVector3DFieldReference1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_vector3dfieldreference2(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_Vector3DFieldReference * pTheVector3DFieldReference1)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "Vector3DFieldReference2");
		}
		if (pTheVector3DFieldReference1 == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVector3DFieldReference1(nullptr);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVector3DFieldReference1 = pIVector3DFieldComposed->Vector3DFieldReference2();

		*pTheVector3DFieldReference1 = (IBase*)(pBaseTheVector3DFieldReference1);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVector3DFieldReference1", *pTheVector3DFieldReference1);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_vector3dfieldcomposed_scalarfieldreferencemask(Lib3MF_Vector3DFieldComposed pVector3DFieldComposed, Lib3MF_ScalarFieldReference * pTheScalarFieldReferenceMask)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldComposed;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldComposed, "Vector3DFieldComposed", "ScalarFieldReferenceMask");
		}
		if (pTheScalarFieldReferenceMask == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldReferenceMask(nullptr);
		IVector3DFieldComposed* pIVector3DFieldComposed = dynamic_cast<IVector3DFieldComposed*>(pIBaseClass);
		if (!pIVector3DFieldComposed)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldReferenceMask = pIVector3DFieldComposed->ScalarFieldReferenceMask();

		*pTheScalarFieldReferenceMask = (IBase*)(pBaseTheScalarFieldReferenceMask);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldReferenceMask", *pTheScalarFieldReferenceMask);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for FieldReference
**************************************************************************************************************************/
Lib3MFResult lib3mf_fieldreference_getfieldresourceid(Lib3MF_FieldReference pFieldReference, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFieldReference, "FieldReference", "GetFieldResourceID");
		}
		if (pUniqueResourceID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IFieldReference* pIFieldReference = dynamic_cast<IFieldReference*>(pIBaseClass);
		if (!pIFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUniqueResourceID = pIFieldReference->GetFieldResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_fieldreference_setfieldresourceid(Lib3MF_FieldReference pFieldReference, Lib3MF_uint32 nUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFieldReference, "FieldReference", "SetFieldResourceID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		IFieldReference* pIFieldReference = dynamic_cast<IFieldReference*>(pIBaseClass);
		if (!pIFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIFieldReference->SetFieldResourceID(nUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_fieldreference_gettransform(Lib3MF_FieldReference pFieldReference, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFieldReference, "FieldReference", "GetTransform");
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IFieldReference* pIFieldReference = dynamic_cast<IFieldReference*>(pIBaseClass);
		if (!pIFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTransform = pIFieldReference->GetTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_fieldreference_settransform(Lib3MF_FieldReference pFieldReference, const sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFieldReference, "FieldReference", "SetTransform");
		}
		IFieldReference* pIFieldReference = dynamic_cast<IFieldReference*>(pIBaseClass);
		if (!pIFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIFieldReference->SetTransform(*pTransform);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ScalarFieldReference
**************************************************************************************************************************/
Lib3MFResult lib3mf_scalarfieldreference_setscalarfield(Lib3MF_ScalarFieldReference pScalarFieldReference, Lib3MF_ScalarField pTheScalarField)
{
	IBase* pIBaseClass = (IBase *)pScalarFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pScalarFieldReference, "ScalarFieldReference", "SetScalarField");
			pJournalEntry->addHandleParameter("TheScalarField", pTheScalarField);
		}
		IBase* pIBaseClassTheScalarField = (IBase *)pTheScalarField;
		IScalarField* pITheScalarField = dynamic_cast<IScalarField*>(pIBaseClassTheScalarField);
		if (!pITheScalarField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IScalarFieldReference* pIScalarFieldReference = dynamic_cast<IScalarFieldReference*>(pIBaseClass);
		if (!pIScalarFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIScalarFieldReference->SetScalarField(pITheScalarField);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Vector3DFieldReference
**************************************************************************************************************************/
Lib3MFResult lib3mf_vector3dfieldreference_setvector3dfield(Lib3MF_Vector3DFieldReference pVector3DFieldReference, Lib3MF_Vector3DField pTheVector3DField)
{
	IBase* pIBaseClass = (IBase *)pVector3DFieldReference;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVector3DFieldReference, "Vector3DFieldReference", "SetVector3DField");
			pJournalEntry->addHandleParameter("TheVector3DField", pTheVector3DField);
		}
		IBase* pIBaseClassTheVector3DField = (IBase *)pTheVector3DField;
		IVector3DField* pITheVector3DField = dynamic_cast<IVector3DField*>(pIBaseClassTheVector3DField);
		if (!pITheVector3DField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IVector3DFieldReference* pIVector3DFieldReference = dynamic_cast<IVector3DFieldReference*>(pIBaseClass);
		if (!pIVector3DFieldReference)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVector3DFieldReference->SetVector3DField(pITheVector3DField);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for VolumeDataBoundary
**************************************************************************************************************************/
Lib3MFResult lib3mf_volumedataboundary_getsolidthreshold(Lib3MF_VolumeDataBoundary pVolumeDataBoundary, Lib3MF_double * pTheSolidThreshold)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataBoundary;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataBoundary, "VolumeDataBoundary", "GetSolidThreshold");
		}
		if (pTheSolidThreshold == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVolumeDataBoundary* pIVolumeDataBoundary = dynamic_cast<IVolumeDataBoundary*>(pIBaseClass);
		if (!pIVolumeDataBoundary)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheSolidThreshold = pIVolumeDataBoundary->GetSolidThreshold();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("TheSolidThreshold", *pTheSolidThreshold);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedataboundary_setsolidthreshold(Lib3MF_VolumeDataBoundary pVolumeDataBoundary, Lib3MF_double dTheSolidThreshold)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataBoundary;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataBoundary, "VolumeDataBoundary", "SetSolidThreshold");
			pJournalEntry->addDoubleParameter("TheSolidThreshold", dTheSolidThreshold);
		}
		IVolumeDataBoundary* pIVolumeDataBoundary = dynamic_cast<IVolumeDataBoundary*>(pIBaseClass);
		if (!pIVolumeDataBoundary)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeDataBoundary->SetSolidThreshold(dTheSolidThreshold);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for VolumeDataColor
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for MaterialMapping
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for VolumeDataComposite
**************************************************************************************************************************/
Lib3MFResult lib3mf_volumedatacomposite_getbasematerialgroup(Lib3MF_VolumeDataComposite pVolumeDataComposite, Lib3MF_BaseMaterialGroup * pBaseMaterialGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "GetBaseMaterialGroup");
		}
		if (pBaseMaterialGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBaseMaterialGroupInstance(nullptr);
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBaseMaterialGroupInstance = pIVolumeDataComposite->GetBaseMaterialGroup();

		*pBaseMaterialGroupInstance = (IBase*)(pBaseBaseMaterialGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BaseMaterialGroupInstance", *pBaseMaterialGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedatacomposite_setbasematerialgroup(Lib3MF_VolumeDataComposite pVolumeDataComposite, Lib3MF_BaseMaterialGroup pBaseMaterialGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "SetBaseMaterialGroup");
			pJournalEntry->addHandleParameter("BaseMaterialGroupInstance", pBaseMaterialGroupInstance);
		}
		IBase* pIBaseClassBaseMaterialGroupInstance = (IBase *)pBaseMaterialGroupInstance;
		IBaseMaterialGroup* pIBaseMaterialGroupInstance = dynamic_cast<IBaseMaterialGroup*>(pIBaseClassBaseMaterialGroupInstance);
		if (!pIBaseMaterialGroupInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeDataComposite->SetBaseMaterialGroup(pIBaseMaterialGroupInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedatacomposite_getmaterialmappingcount(Lib3MF_VolumeDataComposite pVolumeDataComposite, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "GetMaterialMappingCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIVolumeDataComposite->GetMaterialMappingCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedatacomposite_getmaterialmapping(Lib3MF_VolumeDataComposite pVolumeDataComposite, Lib3MF_uint32 nIndex, Lib3MF_MaterialMapping * pTheMaterialMapping)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "GetMaterialMapping");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pTheMaterialMapping == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheMaterialMapping(nullptr);
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheMaterialMapping = pIVolumeDataComposite->GetMaterialMapping(nIndex);

		*pTheMaterialMapping = (IBase*)(pBaseTheMaterialMapping);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheMaterialMapping", *pTheMaterialMapping);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedatacomposite_addmaterialmapping(Lib3MF_VolumeDataComposite pVolumeDataComposite, const sLib3MFTransform * pTransform, Lib3MF_MaterialMapping * pTheMaterialMapping)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "AddMaterialMapping");
		}
		if (pTheMaterialMapping == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheMaterialMapping(nullptr);
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheMaterialMapping = pIVolumeDataComposite->AddMaterialMapping(*pTransform);

		*pTheMaterialMapping = (IBase*)(pBaseTheMaterialMapping);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheMaterialMapping", *pTheMaterialMapping);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedatacomposite_removematerialmapping(Lib3MF_VolumeDataComposite pVolumeDataComposite, Lib3MF_uint32 nIndex)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataComposite;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataComposite, "VolumeDataComposite", "RemoveMaterialMapping");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IVolumeDataComposite* pIVolumeDataComposite = dynamic_cast<IVolumeDataComposite*>(pIBaseClass);
		if (!pIVolumeDataComposite)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeDataComposite->RemoveMaterialMapping(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for VolumeDataProperty
**************************************************************************************************************************/
Lib3MFResult lib3mf_volumedataproperty_getname(Lib3MF_VolumeDataProperty pVolumeDataProperty, const Lib3MF_uint32 nPropertyNameBufferSize, Lib3MF_uint32* pPropertyNameNeededChars, char * pPropertyNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataProperty;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataProperty, "VolumeDataProperty", "GetName");
		}
		if ( (!pPropertyNameBuffer) && !(pPropertyNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPropertyName("");
		IVolumeDataProperty* pIVolumeDataProperty = dynamic_cast<IVolumeDataProperty*>(pIBaseClass);
		if (!pIVolumeDataProperty)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyNameBuffer == nullptr);
		if (isCacheCall) {
			sPropertyName = pIVolumeDataProperty->GetName();

			pIVolumeDataProperty->_setCache (new ParameterCache_1<std::string> (sPropertyName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIVolumeDataProperty->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyName);
			pIVolumeDataProperty->_setCache (nullptr);
		}
		
		if (pPropertyNameNeededChars)
			*pPropertyNameNeededChars = (Lib3MF_uint32) (sPropertyName.size()+1);
		if (pPropertyNameBuffer) {
			if (sPropertyName.size() >= nPropertyNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyName = 0; iPropertyName < sPropertyName.size(); iPropertyName++)
				pPropertyNameBuffer[iPropertyName] = sPropertyName[iPropertyName];
			pPropertyNameBuffer[sPropertyName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("PropertyName", sPropertyName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedataproperty_setisrequired(Lib3MF_VolumeDataProperty pVolumeDataProperty, bool bIsRequired)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataProperty;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataProperty, "VolumeDataProperty", "SetIsRequired");
			pJournalEntry->addBooleanParameter("IsRequired", bIsRequired);
		}
		IVolumeDataProperty* pIVolumeDataProperty = dynamic_cast<IVolumeDataProperty*>(pIBaseClass);
		if (!pIVolumeDataProperty)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeDataProperty->SetIsRequired(bIsRequired);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedataproperty_isrequired(Lib3MF_VolumeDataProperty pVolumeDataProperty, bool * pIsRequired)
{
	IBase* pIBaseClass = (IBase *)pVolumeDataProperty;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeDataProperty, "VolumeDataProperty", "IsRequired");
		}
		if (pIsRequired == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVolumeDataProperty* pIVolumeDataProperty = dynamic_cast<IVolumeDataProperty*>(pIBaseClass);
		if (!pIVolumeDataProperty)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsRequired = pIVolumeDataProperty->IsRequired();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsRequired", *pIsRequired);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for VolumeData
**************************************************************************************************************************/
Lib3MFResult lib3mf_volumedata_getboundary(Lib3MF_VolumeData pVolumeData, Lib3MF_VolumeDataBoundary * pTheBoundaryData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "GetBoundary");
		}
		if (pTheBoundaryData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheBoundaryData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheBoundaryData = pIVolumeData->GetBoundary();

		*pTheBoundaryData = (IBase*)(pBaseTheBoundaryData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheBoundaryData", *pTheBoundaryData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_createnewboundary(Lib3MF_VolumeData pVolumeData, Lib3MF_ScalarField pTheScalarField, Lib3MF_VolumeDataBoundary * pTheBoundaryData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "CreateNewBoundary");
			pJournalEntry->addHandleParameter("TheScalarField", pTheScalarField);
		}
		if (pTheBoundaryData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassTheScalarField = (IBase *)pTheScalarField;
		IScalarField* pITheScalarField = dynamic_cast<IScalarField*>(pIBaseClassTheScalarField);
		if (!pITheScalarField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheBoundaryData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheBoundaryData = pIVolumeData->CreateNewBoundary(pITheScalarField);

		*pTheBoundaryData = (IBase*)(pBaseTheBoundaryData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheBoundaryData", *pTheBoundaryData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_removeboundary(Lib3MF_VolumeData pVolumeData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "RemoveBoundary");
		}
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeData->RemoveBoundary();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_getcomposite(Lib3MF_VolumeData pVolumeData, Lib3MF_VolumeDataComposite * pTheCompositeData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "GetComposite");
		}
		if (pTheCompositeData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheCompositeData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheCompositeData = pIVolumeData->GetComposite();

		*pTheCompositeData = (IBase*)(pBaseTheCompositeData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheCompositeData", *pTheCompositeData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_createnewcomposite(Lib3MF_VolumeData pVolumeData, Lib3MF_VolumeDataComposite * pTheCompositeData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "CreateNewComposite");
		}
		if (pTheCompositeData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheCompositeData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheCompositeData = pIVolumeData->CreateNewComposite();

		*pTheCompositeData = (IBase*)(pBaseTheCompositeData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheCompositeData", *pTheCompositeData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_removecomposite(Lib3MF_VolumeData pVolumeData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "RemoveComposite");
		}
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeData->RemoveComposite();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_getcolor(Lib3MF_VolumeData pVolumeData, Lib3MF_VolumeDataColor * pTheColorData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "GetColor");
		}
		if (pTheColorData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheColorData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheColorData = pIVolumeData->GetColor();

		*pTheColorData = (IBase*)(pBaseTheColorData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheColorData", *pTheColorData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_createnewcolor(Lib3MF_VolumeData pVolumeData, Lib3MF_Vector3DField pTheVector3DField, Lib3MF_VolumeDataColor * pTheColorData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "CreateNewColor");
			pJournalEntry->addHandleParameter("TheVector3DField", pTheVector3DField);
		}
		if (pTheColorData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassTheVector3DField = (IBase *)pTheVector3DField;
		IVector3DField* pITheVector3DField = dynamic_cast<IVector3DField*>(pIBaseClassTheVector3DField);
		if (!pITheVector3DField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheColorData(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheColorData = pIVolumeData->CreateNewColor(pITheVector3DField);

		*pTheColorData = (IBase*)(pBaseTheColorData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheColorData", *pTheColorData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_removecolor(Lib3MF_VolumeData pVolumeData)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "RemoveColor");
		}
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeData->RemoveColor();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_getpropertycount(Lib3MF_VolumeData pVolumeData, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "GetPropertyCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIVolumeData->GetPropertyCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_getproperty(Lib3MF_VolumeData pVolumeData, Lib3MF_uint32 nIndex, Lib3MF_VolumeDataProperty * pTheVolumeDataProperty)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "GetProperty");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pTheVolumeDataProperty == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVolumeDataProperty(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVolumeDataProperty = pIVolumeData->GetProperty(nIndex);

		*pTheVolumeDataProperty = (IBase*)(pBaseTheVolumeDataProperty);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVolumeDataProperty", *pTheVolumeDataProperty);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_addpropertyfromscalarfield(Lib3MF_VolumeData pVolumeData, const char * pName, Lib3MF_ScalarField pTheScalarField, Lib3MF_VolumeDataProperty * pTheVolumeDataProperty)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "AddPropertyFromScalarField");
			pJournalEntry->addStringParameter("Name", pName);
			pJournalEntry->addHandleParameter("TheScalarField", pTheScalarField);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pTheVolumeDataProperty == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassTheScalarField = (IBase *)pTheScalarField;
		IScalarField* pITheScalarField = dynamic_cast<IScalarField*>(pIBaseClassTheScalarField);
		if (!pITheScalarField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheVolumeDataProperty(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVolumeDataProperty = pIVolumeData->AddPropertyFromScalarField(sName, pITheScalarField);

		*pTheVolumeDataProperty = (IBase*)(pBaseTheVolumeDataProperty);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVolumeDataProperty", *pTheVolumeDataProperty);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_addpropertyfromvector3dfield(Lib3MF_VolumeData pVolumeData, const char * pName, Lib3MF_Vector3DField pTheVector3DField, Lib3MF_VolumeDataProperty * pTheVolumeDataProperty)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "AddPropertyFromVector3DField");
			pJournalEntry->addStringParameter("Name", pName);
			pJournalEntry->addHandleParameter("TheVector3DField", pTheVector3DField);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pTheVolumeDataProperty == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassTheVector3DField = (IBase *)pTheVector3DField;
		IVector3DField* pITheVector3DField = dynamic_cast<IVector3DField*>(pIBaseClassTheVector3DField);
		if (!pITheVector3DField)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheVolumeDataProperty(nullptr);
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVolumeDataProperty = pIVolumeData->AddPropertyFromVector3DField(sName, pITheVector3DField);

		*pTheVolumeDataProperty = (IBase*)(pBaseTheVolumeDataProperty);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVolumeDataProperty", *pTheVolumeDataProperty);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_volumedata_removeproperty(Lib3MF_VolumeData pVolumeData, Lib3MF_uint32 nIndex)
{
	IBase* pIBaseClass = (IBase *)pVolumeData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pVolumeData, "VolumeData", "RemoveProperty");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		IVolumeData* pIVolumeData = dynamic_cast<IVolumeData*>(pIBaseClass);
		if (!pIVolumeData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIVolumeData->RemoveProperty(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Component
**************************************************************************************************************************/
Lib3MFResult lib3mf_component_getobjectresource(Lib3MF_Component pComponent, Lib3MF_Object * pObjectResource)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "GetObjectResource");
		}
		if (pObjectResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseObjectResource(nullptr);
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseObjectResource = pIComponent->GetObjectResource();

		*pObjectResource = (IBase*)(pBaseObjectResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ObjectResource", *pObjectResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_getobjectresourceid(Lib3MF_Component pComponent, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "GetObjectResourceID");
		}
		if (pUniqueResourceID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUniqueResourceID = pIComponent->GetObjectResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_getuuid(Lib3MF_Component pComponent, bool * pHasUUID, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "GetUUID");
		}
		if (!pHasUUID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIComponent->GetUUID(*pHasUUID);

			pIComponent->_setCache (new ParameterCache_2<bool, std::string> (*pHasUUID, sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<bool, std::string>*> (pIComponent->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pHasUUID, sUUID);
			pIComponent->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasUUID", *pHasUUID);
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_setuuid(Lib3MF_Component pComponent, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "SetUUID");
			pJournalEntry->addStringParameter("UUID", pUUID);
		}
		if (pUUID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIComponent->SetUUID(sUUID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_hastransform(Lib3MF_Component pComponent, bool * pHasTransform)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "HasTransform");
		}
		if (pHasTransform == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasTransform = pIComponent->HasTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasTransform", *pHasTransform);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_gettransform(Lib3MF_Component pComponent, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "GetTransform");
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTransform = pIComponent->GetTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_component_settransform(Lib3MF_Component pComponent, const sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pComponent;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponent, "Component", "SetTransform");
		}
		IComponent* pIComponent = dynamic_cast<IComponent*>(pIBaseClass);
		if (!pIComponent)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIComponent->SetTransform(*pTransform);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ComponentsObject
**************************************************************************************************************************/
Lib3MFResult lib3mf_componentsobject_addcomponent(Lib3MF_ComponentsObject pComponentsObject, Lib3MF_Object pObjectResource, const sLib3MFTransform * pTransform, Lib3MF_Component * pComponentInstance)
{
	IBase* pIBaseClass = (IBase *)pComponentsObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponentsObject, "ComponentsObject", "AddComponent");
			pJournalEntry->addHandleParameter("ObjectResource", pObjectResource);
		}
		if (pComponentInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassObjectResource = (IBase *)pObjectResource;
		IObject* pIObjectResource = dynamic_cast<IObject*>(pIBaseClassObjectResource);
		if (!pIObjectResource)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseComponentInstance(nullptr);
		IComponentsObject* pIComponentsObject = dynamic_cast<IComponentsObject*>(pIBaseClass);
		if (!pIComponentsObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseComponentInstance = pIComponentsObject->AddComponent(pIObjectResource, *pTransform);

		*pComponentInstance = (IBase*)(pBaseComponentInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ComponentInstance", *pComponentInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_componentsobject_getcomponent(Lib3MF_ComponentsObject pComponentsObject, Lib3MF_uint32 nIndex, Lib3MF_Component * pComponentInstance)
{
	IBase* pIBaseClass = (IBase *)pComponentsObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponentsObject, "ComponentsObject", "GetComponent");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pComponentInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseComponentInstance(nullptr);
		IComponentsObject* pIComponentsObject = dynamic_cast<IComponentsObject*>(pIBaseClass);
		if (!pIComponentsObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseComponentInstance = pIComponentsObject->GetComponent(nIndex);

		*pComponentInstance = (IBase*)(pBaseComponentInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ComponentInstance", *pComponentInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_componentsobject_getcomponentcount(Lib3MF_ComponentsObject pComponentsObject, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pComponentsObject;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pComponentsObject, "ComponentsObject", "GetComponentCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IComponentsObject* pIComponentsObject = dynamic_cast<IComponentsObject*>(pIBaseClass);
		if (!pIComponentsObject)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIComponentsObject->GetComponentCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BeamSet
**************************************************************************************************************************/
Lib3MFResult lib3mf_beamset_setname(Lib3MF_BeamSet pBeamSet, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getname(Lib3MF_BeamSet pBeamSet, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBeamSet->GetName();

			pIBeamSet->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBeamSet->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBeamSet->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_setidentifier(Lib3MF_BeamSet pBeamSet, const char * pIdentifier)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "SetIdentifier");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->SetIdentifier(sIdentifier);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getidentifier(Lib3MF_BeamSet pBeamSet, const Lib3MF_uint32 nIdentifierBufferSize, Lib3MF_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetIdentifier");
		}
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIBeamSet->GetIdentifier();

			pIBeamSet->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBeamSet->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIBeamSet->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (Lib3MF_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Identifier", sIdentifier.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getreferencecount(Lib3MF_BeamSet pBeamSet, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetReferenceCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBeamSet->GetReferenceCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_setreferences(Lib3MF_BeamSet pBeamSet, Lib3MF_uint64 nReferencesBufferSize, const Lib3MF_uint32 * pReferencesBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "SetReferences");
		}
		if ( (!pReferencesBuffer) && (nReferencesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->SetReferences(nReferencesBufferSize, pReferencesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getreferences(Lib3MF_BeamSet pBeamSet, const Lib3MF_uint64 nReferencesBufferSize, Lib3MF_uint64* pReferencesNeededCount, Lib3MF_uint32 * pReferencesBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetReferences");
		}
		if ((!pReferencesBuffer) && !(pReferencesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->GetReferences(nReferencesBufferSize, pReferencesNeededCount, pReferencesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getballreferencecount(Lib3MF_BeamSet pBeamSet, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetBallReferenceCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBeamSet->GetBallReferenceCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_setballreferences(Lib3MF_BeamSet pBeamSet, Lib3MF_uint64 nBallReferencesBufferSize, const Lib3MF_uint32 * pBallReferencesBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "SetBallReferences");
		}
		if ( (!pBallReferencesBuffer) && (nBallReferencesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->SetBallReferences(nBallReferencesBufferSize, pBallReferencesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_beamset_getballreferences(Lib3MF_BeamSet pBeamSet, const Lib3MF_uint64 nBallReferencesBufferSize, Lib3MF_uint64* pBallReferencesNeededCount, Lib3MF_uint32 * pBallReferencesBuffer)
{
	IBase* pIBaseClass = (IBase *)pBeamSet;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBeamSet, "BeamSet", "GetBallReferences");
		}
		if ((!pBallReferencesBuffer) && !(pBallReferencesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBeamSet* pIBeamSet = dynamic_cast<IBeamSet*>(pIBaseClass);
		if (!pIBeamSet)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBeamSet->GetBallReferences(nBallReferencesBufferSize, pBallReferencesNeededCount, pBallReferencesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BaseMaterialGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_basematerialgroup_getcount(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "GetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBaseMaterialGroup->GetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_getallpropertyids(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "GetAllPropertyIDs");
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBaseMaterialGroup->GetAllPropertyIDs(nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_addmaterial(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, const char * pName, const sLib3MFColor * pDisplayColor, Lib3MF_uint32 * pPropertyID)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "AddMaterial");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPropertyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pPropertyID = pIBaseMaterialGroup->AddMaterial(sName, *pDisplayColor);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_removematerial(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "RemoveMaterial");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBaseMaterialGroup->RemoveMaterial(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_getname(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 nPropertyID, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "GetName");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBaseMaterialGroup->GetName(nPropertyID);

			pIBaseMaterialGroup->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBaseMaterialGroup->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBaseMaterialGroup->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_setname(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 nPropertyID, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "SetName");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBaseMaterialGroup->SetName(nPropertyID, sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_setdisplaycolor(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 nPropertyID, const sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "SetDisplayColor");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBaseMaterialGroup->SetDisplayColor(nPropertyID, *pTheColor);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_basematerialgroup_getdisplaycolor(Lib3MF_BaseMaterialGroup pBaseMaterialGroup, Lib3MF_uint32 nPropertyID, sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = (IBase *)pBaseMaterialGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBaseMaterialGroup, "BaseMaterialGroup", "GetDisplayColor");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if (pTheColor == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBaseMaterialGroup* pIBaseMaterialGroup = dynamic_cast<IBaseMaterialGroup*>(pIBaseClass);
		if (!pIBaseMaterialGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheColor = pIBaseMaterialGroup->GetDisplayColor(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ColorGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_colorgroup_getcount(Lib3MF_ColorGroup pColorGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "GetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIColorGroup->GetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colorgroup_getallpropertyids(Lib3MF_ColorGroup pColorGroup, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "GetAllPropertyIDs");
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIColorGroup->GetAllPropertyIDs(nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colorgroup_addcolor(Lib3MF_ColorGroup pColorGroup, const sLib3MFColor * pTheColor, Lib3MF_uint32 * pPropertyID)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "AddColor");
		}
		if (pPropertyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pPropertyID = pIColorGroup->AddColor(*pTheColor);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colorgroup_removecolor(Lib3MF_ColorGroup pColorGroup, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "RemoveColor");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIColorGroup->RemoveColor(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colorgroup_setcolor(Lib3MF_ColorGroup pColorGroup, Lib3MF_uint32 nPropertyID, const sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "SetColor");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIColorGroup->SetColor(nPropertyID, *pTheColor);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colorgroup_getcolor(Lib3MF_ColorGroup pColorGroup, Lib3MF_uint32 nPropertyID, sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = (IBase *)pColorGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pColorGroup, "ColorGroup", "GetColor");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if (pTheColor == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IColorGroup* pIColorGroup = dynamic_cast<IColorGroup*>(pIBaseClass);
		if (!pIColorGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheColor = pIColorGroup->GetColor(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Texture2DGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_texture2dgroup_getcount(Lib3MF_Texture2DGroup pTexture2DGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "GetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pITexture2DGroup->GetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2dgroup_getallpropertyids(Lib3MF_Texture2DGroup pTexture2DGroup, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "GetAllPropertyIDs");
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2DGroup->GetAllPropertyIDs(nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2dgroup_addtex2coord(Lib3MF_Texture2DGroup pTexture2DGroup, const sLib3MFTex2Coord * pUVCoordinate, Lib3MF_uint32 * pPropertyID)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "AddTex2Coord");
		}
		if (pPropertyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pPropertyID = pITexture2DGroup->AddTex2Coord(*pUVCoordinate);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2dgroup_gettex2coord(Lib3MF_Texture2DGroup pTexture2DGroup, Lib3MF_uint32 nPropertyID, sLib3MFTex2Coord * pUVCoordinate)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "GetTex2Coord");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if (pUVCoordinate == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUVCoordinate = pITexture2DGroup->GetTex2Coord(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2dgroup_removetex2coord(Lib3MF_Texture2DGroup pTexture2DGroup, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "RemoveTex2Coord");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2DGroup->RemoveTex2Coord(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2dgroup_gettexture2d(Lib3MF_Texture2DGroup pTexture2DGroup, Lib3MF_Texture2D * pTexture2DInstance)
{
	IBase* pIBaseClass = (IBase *)pTexture2DGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2DGroup, "Texture2DGroup", "GetTexture2D");
		}
		if (pTexture2DInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTexture2DInstance(nullptr);
		ITexture2DGroup* pITexture2DGroup = dynamic_cast<ITexture2DGroup*>(pIBaseClass);
		if (!pITexture2DGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTexture2DInstance = pITexture2DGroup->GetTexture2D();

		*pTexture2DInstance = (IBase*)(pBaseTexture2DInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Texture2DInstance", *pTexture2DInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for CompositeMaterials
**************************************************************************************************************************/
Lib3MFResult lib3mf_compositematerials_getcount(Lib3MF_CompositeMaterials pCompositeMaterials, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "GetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pICompositeMaterials->GetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_compositematerials_getallpropertyids(Lib3MF_CompositeMaterials pCompositeMaterials, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "GetAllPropertyIDs");
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pICompositeMaterials->GetAllPropertyIDs(nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_compositematerials_getbasematerialgroup(Lib3MF_CompositeMaterials pCompositeMaterials, Lib3MF_BaseMaterialGroup * pBaseMaterialGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "GetBaseMaterialGroup");
		}
		if (pBaseMaterialGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBaseMaterialGroupInstance(nullptr);
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBaseMaterialGroupInstance = pICompositeMaterials->GetBaseMaterialGroup();

		*pBaseMaterialGroupInstance = (IBase*)(pBaseBaseMaterialGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BaseMaterialGroupInstance", *pBaseMaterialGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_compositematerials_addcomposite(Lib3MF_CompositeMaterials pCompositeMaterials, Lib3MF_uint64 nCompositeBufferSize, const sLib3MFCompositeConstituent * pCompositeBuffer, Lib3MF_uint32 * pPropertyID)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "AddComposite");
		}
		if ( (!pCompositeBuffer) && (nCompositeBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPropertyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pPropertyID = pICompositeMaterials->AddComposite(nCompositeBufferSize, pCompositeBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_compositematerials_removecomposite(Lib3MF_CompositeMaterials pCompositeMaterials, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "RemoveComposite");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pICompositeMaterials->RemoveComposite(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_compositematerials_getcomposite(Lib3MF_CompositeMaterials pCompositeMaterials, Lib3MF_uint32 nPropertyID, const Lib3MF_uint64 nCompositeBufferSize, Lib3MF_uint64* pCompositeNeededCount, sLib3MFCompositeConstituent * pCompositeBuffer)
{
	IBase* pIBaseClass = (IBase *)pCompositeMaterials;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCompositeMaterials, "CompositeMaterials", "GetComposite");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if ((!pCompositeBuffer) && !(pCompositeNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ICompositeMaterials* pICompositeMaterials = dynamic_cast<ICompositeMaterials*>(pIBaseClass);
		if (!pICompositeMaterials)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pICompositeMaterials->GetComposite(nPropertyID, nCompositeBufferSize, pCompositeNeededCount, pCompositeBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for MultiPropertyGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_multipropertygroup_getcount(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "GetCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIMultiPropertyGroup->GetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_getallpropertyids(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "GetAllPropertyIDs");
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMultiPropertyGroup->GetAllPropertyIDs(nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_addmultiproperty(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint64 nPropertyIDsBufferSize, const Lib3MF_uint32 * pPropertyIDsBuffer, Lib3MF_uint32 * pPropertyID)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "AddMultiProperty");
		}
		if ( (!pPropertyIDsBuffer) && (nPropertyIDsBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPropertyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pPropertyID = pIMultiPropertyGroup->AddMultiProperty(nPropertyIDsBufferSize, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("PropertyID", *pPropertyID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_setmultiproperty(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 nPropertyID, Lib3MF_uint64 nPropertyIDsBufferSize, const Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "SetMultiProperty");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if ( (!pPropertyIDsBuffer) && (nPropertyIDsBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMultiPropertyGroup->SetMultiProperty(nPropertyID, nPropertyIDsBufferSize, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_getmultiproperty(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 nPropertyID, const Lib3MF_uint64 nPropertyIDsBufferSize, Lib3MF_uint64* pPropertyIDsNeededCount, Lib3MF_uint32 * pPropertyIDsBuffer)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "GetMultiProperty");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		if ((!pPropertyIDsBuffer) && !(pPropertyIDsNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMultiPropertyGroup->GetMultiProperty(nPropertyID, nPropertyIDsBufferSize, pPropertyIDsNeededCount, pPropertyIDsBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_removemultiproperty(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 nPropertyID)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "RemoveMultiProperty");
			pJournalEntry->addUInt32Parameter("PropertyID", nPropertyID);
		}
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMultiPropertyGroup->RemoveMultiProperty(nPropertyID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_getlayercount(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "GetLayerCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIMultiPropertyGroup->GetLayerCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_addlayer(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, const sLib3MFMultiPropertyLayer * pTheLayer, Lib3MF_uint32 * pLayerIndex)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "AddLayer");
		}
		if (pLayerIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pLayerIndex = pIMultiPropertyGroup->AddLayer(*pTheLayer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("LayerIndex", *pLayerIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_getlayer(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 nLayerIndex, sLib3MFMultiPropertyLayer * pTheLayer)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "GetLayer");
			pJournalEntry->addUInt32Parameter("LayerIndex", nLayerIndex);
		}
		if (pTheLayer == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTheLayer = pIMultiPropertyGroup->GetLayer(nLayerIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_multipropertygroup_removelayer(Lib3MF_MultiPropertyGroup pMultiPropertyGroup, Lib3MF_uint32 nLayerIndex)
{
	IBase* pIBaseClass = (IBase *)pMultiPropertyGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pMultiPropertyGroup, "MultiPropertyGroup", "RemoveLayer");
			pJournalEntry->addUInt32Parameter("LayerIndex", nLayerIndex);
		}
		IMultiPropertyGroup* pIMultiPropertyGroup = dynamic_cast<IMultiPropertyGroup*>(pIBaseClass);
		if (!pIMultiPropertyGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIMultiPropertyGroup->RemoveLayer(nLayerIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Image3D
**************************************************************************************************************************/
Lib3MFResult lib3mf_image3d_getname(Lib3MF_Image3D pImage3D, const Lib3MF_uint32 nNameBufferSize, Lib3MF_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImage3D, "Image3D", "GetName");
		}
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName("");
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClass);
		if (!pIImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIImage3D->GetName();

			pIImage3D->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImage3D->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIImage3D->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (Lib3MF_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Name", sName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_image3d_setname(Lib3MF_Image3D pImage3D, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImage3D, "Image3D", "SetName");
			pJournalEntry->addStringParameter("Name", pName);
		}
		if (pName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClass);
		if (!pIImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImage3D->SetName(sName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_image3d_isimagestack(Lib3MF_Image3D pImage3D, bool * pIsImageStack)
{
	IBase* pIBaseClass = (IBase *)pImage3D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImage3D, "Image3D", "IsImageStack");
		}
		if (pIsImageStack == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClass);
		if (!pIImage3D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIsImageStack = pIImage3D->IsImageStack();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsImageStack", *pIsImageStack);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ImageStack
**************************************************************************************************************************/
Lib3MFResult lib3mf_imagestack_getrowcount(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 * pRowCount)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "GetRowCount");
		}
		if (pRowCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pRowCount = pIImageStack->GetRowCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("RowCount", *pRowCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_setrowcount(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nRowCount)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "SetRowCount");
			pJournalEntry->addUInt32Parameter("RowCount", nRowCount);
		}
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImageStack->SetRowCount(nRowCount);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_getcolumncount(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 * pColumnCount)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "GetColumnCount");
		}
		if (pColumnCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pColumnCount = pIImageStack->GetColumnCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("ColumnCount", *pColumnCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_setcolumncount(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nColumnCount)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "SetColumnCount");
			pJournalEntry->addUInt32Parameter("ColumnCount", nColumnCount);
		}
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImageStack->SetColumnCount(nColumnCount);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_getsheetcount(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 * pSheetCount)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "GetSheetCount");
		}
		if (pSheetCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pSheetCount = pIImageStack->GetSheetCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("SheetCount", *pSheetCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_getsheet(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nIndex, Lib3MF_Attachment * pSheet)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "GetSheet");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pSheet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseSheet(nullptr);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSheet = pIImageStack->GetSheet(nIndex);

		*pSheet = (IBase*)(pBaseSheet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Sheet", *pSheet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_setsheet(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nIndex, Lib3MF_Attachment pSheet)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "SetSheet");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
			pJournalEntry->addHandleParameter("Sheet", pSheet);
		}
		IBase* pIBaseClassSheet = (IBase *)pSheet;
		IAttachment* pISheet = dynamic_cast<IAttachment*>(pIBaseClassSheet);
		if (!pISheet)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImageStack->SetSheet(nIndex, pISheet);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_createemptysheet(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nIndex, const char * pPath, Lib3MF_Attachment * pSheet)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "CreateEmptySheet");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pSheet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		IBase* pBaseSheet(nullptr);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSheet = pIImageStack->CreateEmptySheet(nIndex, sPath);

		*pSheet = (IBase*)(pBaseSheet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Sheet", *pSheet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_createsheetfrombuffer(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nIndex, const char * pPath, Lib3MF_uint64 nDataBufferSize, const Lib3MF_uint8 * pDataBuffer, Lib3MF_Attachment * pSheet)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "CreateSheetFromBuffer");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pDataBuffer) && (nDataBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pSheet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		IBase* pBaseSheet(nullptr);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSheet = pIImageStack->CreateSheetFromBuffer(nIndex, sPath, nDataBufferSize, pDataBuffer);

		*pSheet = (IBase*)(pBaseSheet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Sheet", *pSheet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_imagestack_createsheetfromfile(Lib3MF_ImageStack pImageStack, Lib3MF_uint32 nIndex, const char * pPath, const char * pFileName, Lib3MF_Attachment * pSheet)
{
	IBase* pIBaseClass = (IBase *)pImageStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImageStack, "ImageStack", "CreateSheetFromFile");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
			pJournalEntry->addStringParameter("Path", pPath);
			pJournalEntry->addStringParameter("FileName", pFileName);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pFileName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pSheet == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		std::string sFileName(pFileName);
		IBase* pBaseSheet(nullptr);
		IImageStack* pIImageStack = dynamic_cast<IImageStack*>(pIBaseClass);
		if (!pIImageStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSheet = pIImageStack->CreateSheetFromFile(nIndex, sPath, sFileName);

		*pSheet = (IBase*)(pBaseSheet);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Sheet", *pSheet);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Attachment
**************************************************************************************************************************/
Lib3MFResult lib3mf_attachment_getpath(Lib3MF_Attachment pAttachment, const Lib3MF_uint32 nPathBufferSize, Lib3MF_uint32* pPathNeededChars, char * pPathBuffer)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "GetPath");
		}
		if ( (!pPathBuffer) && !(pPathNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath("");
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPathBuffer == nullptr);
		if (isCacheCall) {
			sPath = pIAttachment->GetPath();

			pIAttachment->_setCache (new ParameterCache_1<std::string> (sPath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAttachment->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPath);
			pIAttachment->_setCache (nullptr);
		}
		
		if (pPathNeededChars)
			*pPathNeededChars = (Lib3MF_uint32) (sPath.size()+1);
		if (pPathBuffer) {
			if (sPath.size() >= nPathBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPath = 0; iPath < sPath.size(); iPath++)
				pPathBuffer[iPath] = sPath[iPath];
			pPathBuffer[sPath.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Path", sPath.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_setpath(Lib3MF_Attachment pAttachment, const char * pPath)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "SetPath");
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->SetPath(sPath);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_packagepart(Lib3MF_Attachment pAttachment, Lib3MF_PackagePart * pPackagePart)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "PackagePart");
		}
		if (pPackagePart == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBasePackagePart(nullptr);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePackagePart = pIAttachment->PackagePart();

		*pPackagePart = (IBase*)(pBasePackagePart);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("PackagePart", *pPackagePart);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_getrelationshiptype(Lib3MF_Attachment pAttachment, const Lib3MF_uint32 nPathBufferSize, Lib3MF_uint32* pPathNeededChars, char * pPathBuffer)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "GetRelationShipType");
		}
		if ( (!pPathBuffer) && !(pPathNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath("");
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPathBuffer == nullptr);
		if (isCacheCall) {
			sPath = pIAttachment->GetRelationShipType();

			pIAttachment->_setCache (new ParameterCache_1<std::string> (sPath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAttachment->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPath);
			pIAttachment->_setCache (nullptr);
		}
		
		if (pPathNeededChars)
			*pPathNeededChars = (Lib3MF_uint32) (sPath.size()+1);
		if (pPathBuffer) {
			if (sPath.size() >= nPathBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPath = 0; iPath < sPath.size(); iPath++)
				pPathBuffer[iPath] = sPath[iPath];
			pPathBuffer[sPath.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Path", sPath.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_setrelationshiptype(Lib3MF_Attachment pAttachment, const char * pPath)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "SetRelationShipType");
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->SetRelationShipType(sPath);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_writetofile(Lib3MF_Attachment pAttachment, const char * pFileName)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "WriteToFile");
			pJournalEntry->addStringParameter("FileName", pFileName);
		}
		if (pFileName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->WriteToFile(sFileName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_readfromfile(Lib3MF_Attachment pAttachment, const char * pFileName)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "ReadFromFile");
			pJournalEntry->addStringParameter("FileName", pFileName);
		}
		if (pFileName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->ReadFromFile(sFileName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_readfromcallback(Lib3MF_Attachment pAttachment, Lib3MFReadCallback pTheReadCallback, Lib3MF_uint64 nStreamSize, Lib3MFSeekCallback pTheSeekCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "ReadFromCallback");
			pJournalEntry->addUInt64Parameter("StreamSize", nStreamSize);
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->ReadFromCallback(pTheReadCallback, nStreamSize, pTheSeekCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_getstreamsize(Lib3MF_Attachment pAttachment, Lib3MF_uint64 * pStreamSize)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "GetStreamSize");
		}
		if (pStreamSize == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pStreamSize = pIAttachment->GetStreamSize();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("StreamSize", *pStreamSize);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_writetobuffer(Lib3MF_Attachment pAttachment, const Lib3MF_uint64 nBufferBufferSize, Lib3MF_uint64* pBufferNeededCount, Lib3MF_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "WriteToBuffer");
		}
		if ((!pBufferBuffer) && !(pBufferNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->WriteToBuffer(nBufferBufferSize, pBufferNeededCount, pBufferBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_attachment_readfrombuffer(Lib3MF_Attachment pAttachment, Lib3MF_uint64 nBufferBufferSize, const Lib3MF_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pAttachment;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAttachment, "Attachment", "ReadFromBuffer");
		}
		if ( (!pBufferBuffer) && (nBufferBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClass);
		if (!pIAttachment)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIAttachment->ReadFromBuffer(nBufferBufferSize, pBufferBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Texture2D
**************************************************************************************************************************/
Lib3MFResult lib3mf_texture2d_getattachment(Lib3MF_Texture2D pTexture2D, Lib3MF_Attachment * pAttachment)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "GetAttachment");
		}
		if (pAttachment == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseAttachment(nullptr);
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachment = pITexture2D->GetAttachment();

		*pAttachment = (IBase*)(pBaseAttachment);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Attachment", *pAttachment);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_setattachment(Lib3MF_Texture2D pTexture2D, Lib3MF_Attachment pAttachment)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "SetAttachment");
			pJournalEntry->addHandleParameter("Attachment", pAttachment);
		}
		IBase* pIBaseClassAttachment = (IBase *)pAttachment;
		IAttachment* pIAttachment = dynamic_cast<IAttachment*>(pIBaseClassAttachment);
		if (!pIAttachment)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2D->SetAttachment(pIAttachment);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_getcontenttype(Lib3MF_Texture2D pTexture2D, eLib3MFTextureType * pContentType)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "GetContentType");
		}
		if (pContentType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pContentType = pITexture2D->GetContentType();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("ContentType", "TextureType", (Lib3MF_int32)(*pContentType));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_setcontenttype(Lib3MF_Texture2D pTexture2D, eLib3MFTextureType eContentType)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "SetContentType");
			pJournalEntry->addEnumParameter("ContentType", "TextureType", (Lib3MF_int32)(eContentType));
		}
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2D->SetContentType(eContentType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_gettilestyleuv(Lib3MF_Texture2D pTexture2D, eLib3MFTextureTileStyle * pTileStyleU, eLib3MFTextureTileStyle * pTileStyleV)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "GetTileStyleUV");
		}
		if (!pTileStyleU)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pTileStyleV)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2D->GetTileStyleUV(*pTileStyleU, *pTileStyleV);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleU));
			pJournalEntry->addEnumResult("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(*pTileStyleV));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_settilestyleuv(Lib3MF_Texture2D pTexture2D, eLib3MFTextureTileStyle eTileStyleU, eLib3MFTextureTileStyle eTileStyleV)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "SetTileStyleUV");
			pJournalEntry->addEnumParameter("TileStyleU", "TextureTileStyle", (Lib3MF_int32)(eTileStyleU));
			pJournalEntry->addEnumParameter("TileStyleV", "TextureTileStyle", (Lib3MF_int32)(eTileStyleV));
		}
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2D->SetTileStyleUV(eTileStyleU, eTileStyleV);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_getfilter(Lib3MF_Texture2D pTexture2D, eLib3MFTextureFilter * pFilter)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "GetFilter");
		}
		if (pFilter == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pFilter = pITexture2D->GetFilter();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Filter", "TextureFilter", (Lib3MF_int32)(*pFilter));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_texture2d_setfilter(Lib3MF_Texture2D pTexture2D, eLib3MFTextureFilter eFilter)
{
	IBase* pIBaseClass = (IBase *)pTexture2D;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pTexture2D, "Texture2D", "SetFilter");
			pJournalEntry->addEnumParameter("Filter", "TextureFilter", (Lib3MF_int32)(eFilter));
		}
		ITexture2D* pITexture2D = dynamic_cast<ITexture2D*>(pIBaseClass);
		if (!pITexture2D)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pITexture2D->SetFilter(eFilter);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ImplicitPort
**************************************************************************************************************************/
Lib3MFResult lib3mf_implicitport_getidentifier(Lib3MF_ImplicitPort pImplicitPort, const Lib3MF_uint32 nIdentifierBufferSize, Lib3MF_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "GetIdentifier");
		}
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIImplicitPort->GetIdentifier();

			pIImplicitPort->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitPort->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIImplicitPort->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (Lib3MF_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Identifier", sIdentifier.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_setidentifier(Lib3MF_ImplicitPort pImplicitPort, const char * pIdentifier)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "SetIdentifier");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitPort->SetIdentifier(sIdentifier);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_getdisplayname(Lib3MF_ImplicitPort pImplicitPort, const Lib3MF_uint32 nDisplayNameBufferSize, Lib3MF_uint32* pDisplayNameNeededChars, char * pDisplayNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "GetDisplayName");
		}
		if ( (!pDisplayNameBuffer) && !(pDisplayNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName("");
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDisplayNameBuffer == nullptr);
		if (isCacheCall) {
			sDisplayName = pIImplicitPort->GetDisplayName();

			pIImplicitPort->_setCache (new ParameterCache_1<std::string> (sDisplayName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitPort->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sDisplayName);
			pIImplicitPort->_setCache (nullptr);
		}
		
		if (pDisplayNameNeededChars)
			*pDisplayNameNeededChars = (Lib3MF_uint32) (sDisplayName.size()+1);
		if (pDisplayNameBuffer) {
			if (sDisplayName.size() >= nDisplayNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iDisplayName = 0; iDisplayName < sDisplayName.size(); iDisplayName++)
				pDisplayNameBuffer[iDisplayName] = sDisplayName[iDisplayName];
			pDisplayNameBuffer[sDisplayName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("DisplayName", sDisplayName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_setdisplayname(Lib3MF_ImplicitPort pImplicitPort, const char * pDisplayName)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "SetDisplayName");
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName(pDisplayName);
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitPort->SetDisplayName(sDisplayName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_settype(Lib3MF_ImplicitPort pImplicitPort, eLib3MFImplicitPortType eImplicitPortType)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "SetType");
			pJournalEntry->addEnumParameter("ImplicitPortType", "ImplicitPortType", (Lib3MF_int32)(eImplicitPortType));
		}
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitPort->SetType(eImplicitPortType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_gettype(Lib3MF_ImplicitPort pImplicitPort, eLib3MFImplicitPortType * pImplicitPortType)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "GetType");
		}
		if (pImplicitPortType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pImplicitPortType = pIImplicitPort->GetType();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("ImplicitPortType", "ImplicitPortType", (Lib3MF_int32)(*pImplicitPortType));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_getreference(Lib3MF_ImplicitPort pImplicitPort, const Lib3MF_uint32 nReferenceBufferSize, Lib3MF_uint32* pReferenceNeededChars, char * pReferenceBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "GetReference");
		}
		if ( (!pReferenceBuffer) && !(pReferenceNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sReference("");
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pReferenceBuffer == nullptr);
		if (isCacheCall) {
			sReference = pIImplicitPort->GetReference();

			pIImplicitPort->_setCache (new ParameterCache_1<std::string> (sReference));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitPort->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sReference);
			pIImplicitPort->_setCache (nullptr);
		}
		
		if (pReferenceNeededChars)
			*pReferenceNeededChars = (Lib3MF_uint32) (sReference.size()+1);
		if (pReferenceBuffer) {
			if (sReference.size() >= nReferenceBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iReference = 0; iReference < sReference.size(); iReference++)
				pReferenceBuffer[iReference] = sReference[iReference];
			pReferenceBuffer[sReference.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Reference", sReference.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitport_setreference(Lib3MF_ImplicitPort pImplicitPort, const char * pReference)
{
	IBase* pIBaseClass = (IBase *)pImplicitPort;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPort, "ImplicitPort", "SetReference");
			pJournalEntry->addStringParameter("Reference", pReference);
		}
		if (pReference == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sReference(pReference);
		IImplicitPort* pIImplicitPort = dynamic_cast<IImplicitPort*>(pIBaseClass);
		if (!pIImplicitPort)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitPort->SetReference(sReference);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_iterator_movenext(Lib3MF_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pIterator, "Iterator", "MoveNext");
		}
		if (pHasNext == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasNext", *pHasNext);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_iterator_moveprevious(Lib3MF_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pIterator, "Iterator", "MovePrevious");
		}
		if (pHasPrevious == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasPrevious", *pHasPrevious);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_iterator_count(Lib3MF_Iterator pIterator, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pIterator, "Iterator", "Count");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ImplicitPortIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_implicitportiterator_getcurrent(Lib3MF_ImplicitPortIterator pImplicitPortIterator, Lib3MF_ImplicitPort * pPort)
{
	IBase* pIBaseClass = (IBase *)pImplicitPortIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitPortIterator, "ImplicitPortIterator", "GetCurrent");
		}
		if (pPort == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBasePort(nullptr);
		IImplicitPortIterator* pIImplicitPortIterator = dynamic_cast<IImplicitPortIterator*>(pIBaseClass);
		if (!pIImplicitPortIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePort = pIImplicitPortIterator->GetCurrent();

		*pPort = (IBase*)(pBasePort);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Port", *pPort);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ImplicitNode
**************************************************************************************************************************/
Lib3MFResult lib3mf_implicitnode_getidentifier(Lib3MF_ImplicitNode pImplicitNode, const Lib3MF_uint32 nIdentifierBufferSize, Lib3MF_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetIdentifier");
		}
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIImplicitNode->GetIdentifier();

			pIImplicitNode->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitNode->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIImplicitNode->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (Lib3MF_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Identifier", sIdentifier.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_setidentifier(Lib3MF_ImplicitNode pImplicitNode, const char * pIdentifier)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "SetIdentifier");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitNode->SetIdentifier(sIdentifier);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getdisplayname(Lib3MF_ImplicitNode pImplicitNode, const Lib3MF_uint32 nDisplayNameBufferSize, Lib3MF_uint32* pDisplayNameNeededChars, char * pDisplayNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetDisplayName");
		}
		if ( (!pDisplayNameBuffer) && !(pDisplayNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName("");
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDisplayNameBuffer == nullptr);
		if (isCacheCall) {
			sDisplayName = pIImplicitNode->GetDisplayName();

			pIImplicitNode->_setCache (new ParameterCache_1<std::string> (sDisplayName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitNode->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sDisplayName);
			pIImplicitNode->_setCache (nullptr);
		}
		
		if (pDisplayNameNeededChars)
			*pDisplayNameNeededChars = (Lib3MF_uint32) (sDisplayName.size()+1);
		if (pDisplayNameBuffer) {
			if (sDisplayName.size() >= nDisplayNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iDisplayName = 0; iDisplayName < sDisplayName.size(); iDisplayName++)
				pDisplayNameBuffer[iDisplayName] = sDisplayName[iDisplayName];
			pDisplayNameBuffer[sDisplayName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("DisplayName", sDisplayName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_setdisplayname(Lib3MF_ImplicitNode pImplicitNode, const char * pDisplayName)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "SetDisplayName");
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName(pDisplayName);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitNode->SetDisplayName(sDisplayName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getnodetype(Lib3MF_ImplicitNode pImplicitNode, eLib3MFImplicitNodeType * pType)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetNodeType");
		}
		if (pType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pType = pIImplicitNode->GetNodeType();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Type", "ImplicitNodeType", (Lib3MF_int32)(*pType));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_addinput(Lib3MF_ImplicitNode pImplicitNode, const char * pIdentifier, const char * pDisplayName, Lib3MF_ImplicitPort * pPort)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "AddInput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPort == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDisplayName(pDisplayName);
		IBase* pBasePort(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePort = pIImplicitNode->AddInput(sIdentifier, sDisplayName);

		*pPort = (IBase*)(pBasePort);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Port", *pPort);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getinputs(Lib3MF_ImplicitNode pImplicitNode, Lib3MF_ImplicitPortIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetInputs");
		}
		if (pIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseIterator = pIImplicitNode->GetInputs();

		*pIterator = (IBase*)(pBaseIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Iterator", *pIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_addoutput(Lib3MF_ImplicitNode pImplicitNode, const char * pIdentifier, const char * pDisplayName, Lib3MF_ImplicitPort * pPort)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "AddOutput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPort == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDisplayName(pDisplayName);
		IBase* pBasePort(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePort = pIImplicitNode->AddOutput(sIdentifier, sDisplayName);

		*pPort = (IBase*)(pBasePort);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Port", *pPort);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getoutputs(Lib3MF_ImplicitNode pImplicitNode, Lib3MF_ImplicitPortIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetOutputs");
		}
		if (pIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseIterator = pIImplicitNode->GetOutputs();

		*pIterator = (IBase*)(pBaseIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Iterator", *pIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_findinput(Lib3MF_ImplicitNode pImplicitNode, const char * pIdentifier, Lib3MF_ImplicitPort * pInput)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "FindInput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pInput == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseInput(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseInput = pIImplicitNode->FindInput(sIdentifier);

		*pInput = (IBase*)(pBaseInput);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Input", *pInput);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_findoutput(Lib3MF_ImplicitNode pImplicitNode, const char * pIdentifier, Lib3MF_ImplicitPort * pOutput)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "FindOutput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pOutput == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseOutput(nullptr);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseOutput = pIImplicitNode->FindOutput(sIdentifier);

		*pOutput = (IBase*)(pBaseOutput);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Output", *pOutput);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_setconstant(Lib3MF_ImplicitNode pImplicitNode, Lib3MF_double dValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "SetConstant");
			pJournalEntry->addDoubleParameter("Value", dValue);
		}
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitNode->SetConstant(dValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getconstant(Lib3MF_ImplicitNode pImplicitNode, Lib3MF_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetConstant");
		}
		if (pValue == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValue = pIImplicitNode->GetConstant();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Value", *pValue);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_setvector(Lib3MF_ImplicitNode pImplicitNode, const sLib3MFVector * pValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "SetVector");
		}
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitNode->SetVector(*pValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getvector(Lib3MF_ImplicitNode pImplicitNode, sLib3MFVector * pValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetVector");
		}
		if (pValue == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValue = pIImplicitNode->GetVector();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_setmatrix(Lib3MF_ImplicitNode pImplicitNode, const sLib3MFMatrix4x4 * pValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "SetMatrix");
		}
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitNode->SetMatrix(*pValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitnode_getmatrix(Lib3MF_ImplicitNode pImplicitNode, sLib3MFMatrix4x4 * pValue)
{
	IBase* pIBaseClass = (IBase *)pImplicitNode;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitNode, "ImplicitNode", "GetMatrix");
		}
		if (pValue == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IImplicitNode* pIImplicitNode = dynamic_cast<IImplicitNode*>(pIBaseClass);
		if (!pIImplicitNode)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pValue = pIImplicitNode->GetMatrix();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for NodeIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_nodeiterator_getcurrent(Lib3MF_NodeIterator pNodeIterator, Lib3MF_ImplicitNode * pNode)
{
	IBase* pIBaseClass = (IBase *)pNodeIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pNodeIterator, "NodeIterator", "GetCurrent");
		}
		if (pNode == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseNode(nullptr);
		INodeIterator* pINodeIterator = dynamic_cast<INodeIterator*>(pIBaseClass);
		if (!pINodeIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseNode = pINodeIterator->GetCurrent();

		*pNode = (IBase*)(pBaseNode);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Node", *pNode);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ImplicitFunction
**************************************************************************************************************************/
Lib3MFResult lib3mf_implicitfunction_getidentifier(Lib3MF_ImplicitFunction pImplicitFunction, const Lib3MF_uint32 nIdentifierBufferSize, Lib3MF_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "GetIdentifier");
		}
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIImplicitFunction->GetIdentifier();

			pIImplicitFunction->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitFunction->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIImplicitFunction->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (Lib3MF_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Identifier", sIdentifier.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_setidentifier(Lib3MF_ImplicitFunction pImplicitFunction, const char * pIdentifier)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "SetIdentifier");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->SetIdentifier(sIdentifier);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_getdisplayname(Lib3MF_ImplicitFunction pImplicitFunction, const Lib3MF_uint32 nDisplayNameBufferSize, Lib3MF_uint32* pDisplayNameNeededChars, char * pDisplayNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "GetDisplayName");
		}
		if ( (!pDisplayNameBuffer) && !(pDisplayNameNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName("");
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDisplayNameBuffer == nullptr);
		if (isCacheCall) {
			sDisplayName = pIImplicitFunction->GetDisplayName();

			pIImplicitFunction->_setCache (new ParameterCache_1<std::string> (sDisplayName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIImplicitFunction->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sDisplayName);
			pIImplicitFunction->_setCache (nullptr);
		}
		
		if (pDisplayNameNeededChars)
			*pDisplayNameNeededChars = (Lib3MF_uint32) (sDisplayName.size()+1);
		if (pDisplayNameBuffer) {
			if (sDisplayName.size() >= nDisplayNameBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iDisplayName = 0; iDisplayName < sDisplayName.size(); iDisplayName++)
				pDisplayNameBuffer[iDisplayName] = sDisplayName[iDisplayName];
			pDisplayNameBuffer[sDisplayName.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("DisplayName", sDisplayName.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_setdisplayname(Lib3MF_ImplicitFunction pImplicitFunction, const char * pDisplayName)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "SetDisplayName");
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sDisplayName(pDisplayName);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->SetDisplayName(sDisplayName);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_addnode(Lib3MF_ImplicitFunction pImplicitFunction, eLib3MFImplicitNodeType eNodeType, const char * pIdentifier, const char * pDisplayName, Lib3MF_ImplicitNode * pNode)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "AddNode");
			pJournalEntry->addEnumParameter("NodeType", "ImplicitNodeType", (Lib3MF_int32)(eNodeType));
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pNode == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDisplayName(pDisplayName);
		IBase* pBaseNode(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseNode = pIImplicitFunction->AddNode(eNodeType, sIdentifier, sDisplayName);

		*pNode = (IBase*)(pBaseNode);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Node", *pNode);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_getnodes(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_NodeIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "GetNodes");
		}
		if (pIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseIterator = pIImplicitFunction->GetNodes();

		*pIterator = (IBase*)(pBaseIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Iterator", *pIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_removenode(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitNode pNode)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "RemoveNode");
			pJournalEntry->addHandleParameter("Node", pNode);
		}
		IBase* pIBaseClassNode = (IBase *)pNode;
		IImplicitNode* pINode = dynamic_cast<IImplicitNode*>(pIBaseClassNode);
		if (!pINode)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->RemoveNode(pINode);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_addinput(Lib3MF_ImplicitFunction pImplicitFunction, const char * pIdentifier, const char * pDisplayName, eLib3MFImplicitPortType eType, Lib3MF_ImplicitPort * pPort)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "AddInput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
			pJournalEntry->addEnumParameter("Type", "ImplicitPortType", (Lib3MF_int32)(eType));
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPort == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDisplayName(pDisplayName);
		IBase* pBasePort(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePort = pIImplicitFunction->AddInput(sIdentifier, sDisplayName, eType);

		*pPort = (IBase*)(pBasePort);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Port", *pPort);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_getinputs(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitPortIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "GetInputs");
		}
		if (pIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseIterator = pIImplicitFunction->GetInputs();

		*pIterator = (IBase*)(pBaseIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Iterator", *pIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_removeinput(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitPort pInput)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "RemoveInput");
			pJournalEntry->addHandleParameter("Input", pInput);
		}
		IBase* pIBaseClassInput = (IBase *)pInput;
		IImplicitPort* pIInput = dynamic_cast<IImplicitPort*>(pIBaseClassInput);
		if (!pIInput)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->RemoveInput(pIInput);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_addoutput(Lib3MF_ImplicitFunction pImplicitFunction, const char * pIdentifier, const char * pDisplayName, eLib3MFImplicitPortType eType, Lib3MF_ImplicitPort * pPort)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "AddOutput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
			pJournalEntry->addStringParameter("DisplayName", pDisplayName);
			pJournalEntry->addEnumParameter("Type", "ImplicitPortType", (Lib3MF_int32)(eType));
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pDisplayName == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pPort == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDisplayName(pDisplayName);
		IBase* pBasePort(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePort = pIImplicitFunction->AddOutput(sIdentifier, sDisplayName, eType);

		*pPort = (IBase*)(pBasePort);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Port", *pPort);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_getoutputs(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitPortIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "GetOutputs");
		}
		if (pIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseIterator = pIImplicitFunction->GetOutputs();

		*pIterator = (IBase*)(pBaseIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Iterator", *pIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_removeoutput(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitPort pOutput)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "RemoveOutput");
			pJournalEntry->addHandleParameter("Output", pOutput);
		}
		IBase* pIBaseClassOutput = (IBase *)pOutput;
		IImplicitPort* pIOutput = dynamic_cast<IImplicitPort*>(pIBaseClassOutput);
		if (!pIOutput)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->RemoveOutput(pIOutput);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_addlink(Lib3MF_ImplicitFunction pImplicitFunction, Lib3MF_ImplicitPort pSource, Lib3MF_ImplicitPort pTarget)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "AddLink");
			pJournalEntry->addHandleParameter("Source", pSource);
			pJournalEntry->addHandleParameter("Target", pTarget);
		}
		IBase* pIBaseClassSource = (IBase *)pSource;
		IImplicitPort* pISource = dynamic_cast<IImplicitPort*>(pIBaseClassSource);
		if (!pISource)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pIBaseClassTarget = (IBase *)pTarget;
		IImplicitPort* pITarget = dynamic_cast<IImplicitPort*>(pIBaseClassTarget);
		if (!pITarget)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->AddLink(pISource, pITarget);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_findinput(Lib3MF_ImplicitFunction pImplicitFunction, const char * pIdentifier, Lib3MF_ImplicitPort * pInput)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "FindInput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pInput == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseInput(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseInput = pIImplicitFunction->FindInput(sIdentifier);

		*pInput = (IBase*)(pBaseInput);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Input", *pInput);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_findoutput(Lib3MF_ImplicitFunction pImplicitFunction, const char * pIdentifier, Lib3MF_ImplicitPort * pOutput)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "FindOutput");
			pJournalEntry->addStringParameter("Identifier", pIdentifier);
		}
		if (pIdentifier == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pOutput == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseOutput(nullptr);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseOutput = pIImplicitFunction->FindOutput(sIdentifier);

		*pOutput = (IBase*)(pBaseOutput);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Output", *pOutput);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_implicitfunction_addlinkbynames(Lib3MF_ImplicitFunction pImplicitFunction, const char * pSource, const char * pTarget)
{
	IBase* pIBaseClass = (IBase *)pImplicitFunction;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pImplicitFunction, "ImplicitFunction", "AddLinkByNames");
			pJournalEntry->addStringParameter("Source", pSource);
			pJournalEntry->addStringParameter("Target", pTarget);
		}
		if (pSource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pTarget == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sSource(pSource);
		std::string sTarget(pTarget);
		IImplicitFunction* pIImplicitFunction = dynamic_cast<IImplicitFunction*>(pIBaseClass);
		if (!pIImplicitFunction)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIImplicitFunction->AddLinkByNames(sSource, sTarget);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BuildItem
**************************************************************************************************************************/
Lib3MFResult lib3mf_builditem_getobjectresource(Lib3MF_BuildItem pBuildItem, Lib3MF_Object * pObjectResource)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetObjectResource");
		}
		if (pObjectResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseObjectResource(nullptr);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseObjectResource = pIBuildItem->GetObjectResource();

		*pObjectResource = (IBase*)(pBaseObjectResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ObjectResource", *pObjectResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getuuid(Lib3MF_BuildItem pBuildItem, bool * pHasUUID, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetUUID");
		}
		if (!pHasUUID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildItem->GetUUID(*pHasUUID);

			pIBuildItem->_setCache (new ParameterCache_2<bool, std::string> (*pHasUUID, sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<bool, std::string>*> (pIBuildItem->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pHasUUID, sUUID);
			pIBuildItem->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasUUID", *pHasUUID);
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_setuuid(Lib3MF_BuildItem pBuildItem, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "SetUUID");
			pJournalEntry->addStringParameter("UUID", pUUID);
		}
		if (pUUID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBuildItem->SetUUID(sUUID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getobjectresourceid(Lib3MF_BuildItem pBuildItem, Lib3MF_uint32 * pUniqueResourceID)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetObjectResourceID");
		}
		if (pUniqueResourceID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUniqueResourceID = pIBuildItem->GetObjectResourceID();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("UniqueResourceID", *pUniqueResourceID);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_hasobjecttransform(Lib3MF_BuildItem pBuildItem, bool * pHasTransform)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "HasObjectTransform");
		}
		if (pHasTransform == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasTransform = pIBuildItem->HasObjectTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasTransform", *pHasTransform);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getobjecttransform(Lib3MF_BuildItem pBuildItem, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetObjectTransform");
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pTransform = pIBuildItem->GetObjectTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_setobjecttransform(Lib3MF_BuildItem pBuildItem, const sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "SetObjectTransform");
		}
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBuildItem->SetObjectTransform(*pTransform);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getpartnumber(Lib3MF_BuildItem pBuildItem, const Lib3MF_uint32 nPartNumberBufferSize, Lib3MF_uint32* pPartNumberNeededChars, char * pPartNumberBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetPartNumber");
		}
		if ( (!pPartNumberBuffer) && !(pPartNumberNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPartNumber("");
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPartNumberBuffer == nullptr);
		if (isCacheCall) {
			sPartNumber = pIBuildItem->GetPartNumber();

			pIBuildItem->_setCache (new ParameterCache_1<std::string> (sPartNumber));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildItem->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPartNumber);
			pIBuildItem->_setCache (nullptr);
		}
		
		if (pPartNumberNeededChars)
			*pPartNumberNeededChars = (Lib3MF_uint32) (sPartNumber.size()+1);
		if (pPartNumberBuffer) {
			if (sPartNumber.size() >= nPartNumberBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPartNumber = 0; iPartNumber < sPartNumber.size(); iPartNumber++)
				pPartNumberBuffer[iPartNumber] = sPartNumber[iPartNumber];
			pPartNumberBuffer[sPartNumber.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("PartNumber", sPartNumber.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_setpartnumber(Lib3MF_BuildItem pBuildItem, const char * pSetPartnumber)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "SetPartNumber");
			pJournalEntry->addStringParameter("SetPartnumber", pSetPartnumber);
		}
		if (pSetPartnumber == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sSetPartnumber(pSetPartnumber);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIBuildItem->SetPartNumber(sSetPartnumber);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getmetadatagroup(Lib3MF_BuildItem pBuildItem, Lib3MF_MetaDataGroup * pMetaDataGroup)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetMetaDataGroup");
		}
		if (pMetaDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMetaDataGroup(nullptr);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMetaDataGroup = pIBuildItem->GetMetaDataGroup();

		*pMetaDataGroup = (IBase*)(pBaseMetaDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MetaDataGroup", *pMetaDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditem_getoutbox(Lib3MF_BuildItem pBuildItem, sLib3MFBox * pOutbox)
{
	IBase* pIBaseClass = (IBase *)pBuildItem;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItem, "BuildItem", "GetOutbox");
		}
		if (pOutbox == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItem* pIBuildItem = dynamic_cast<IBuildItem*>(pIBaseClass);
		if (!pIBuildItem)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pOutbox = pIBuildItem->GetOutbox();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for BuildItemIterator
**************************************************************************************************************************/
Lib3MFResult lib3mf_builditemiterator_movenext(Lib3MF_BuildItemIterator pBuildItemIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pBuildItemIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItemIterator, "BuildItemIterator", "MoveNext");
		}
		if (pHasNext == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItemIterator* pIBuildItemIterator = dynamic_cast<IBuildItemIterator*>(pIBaseClass);
		if (!pIBuildItemIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasNext = pIBuildItemIterator->MoveNext();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasNext", *pHasNext);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditemiterator_moveprevious(Lib3MF_BuildItemIterator pBuildItemIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pBuildItemIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItemIterator, "BuildItemIterator", "MovePrevious");
		}
		if (pHasPrevious == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItemIterator* pIBuildItemIterator = dynamic_cast<IBuildItemIterator*>(pIBaseClass);
		if (!pIBuildItemIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIBuildItemIterator->MovePrevious();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasPrevious", *pHasPrevious);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditemiterator_getcurrent(Lib3MF_BuildItemIterator pBuildItemIterator, Lib3MF_BuildItem * pBuildItem)
{
	IBase* pIBaseClass = (IBase *)pBuildItemIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItemIterator, "BuildItemIterator", "GetCurrent");
		}
		if (pBuildItem == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBuildItem(nullptr);
		IBuildItemIterator* pIBuildItemIterator = dynamic_cast<IBuildItemIterator*>(pIBaseClass);
		if (!pIBuildItemIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBuildItem = pIBuildItemIterator->GetCurrent();

		*pBuildItem = (IBase*)(pBaseBuildItem);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BuildItem", *pBuildItem);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditemiterator_clone(Lib3MF_BuildItemIterator pBuildItemIterator, Lib3MF_BuildItemIterator * pOutBuildItemIterator)
{
	IBase* pIBaseClass = (IBase *)pBuildItemIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItemIterator, "BuildItemIterator", "Clone");
		}
		if (pOutBuildItemIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseOutBuildItemIterator(nullptr);
		IBuildItemIterator* pIBuildItemIterator = dynamic_cast<IBuildItemIterator*>(pIBaseClass);
		if (!pIBuildItemIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseOutBuildItemIterator = pIBuildItemIterator->Clone();

		*pOutBuildItemIterator = (IBase*)(pBaseOutBuildItemIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("OutBuildItemIterator", *pOutBuildItemIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_builditemiterator_count(Lib3MF_BuildItemIterator pBuildItemIterator, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pBuildItemIterator;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pBuildItemIterator, "BuildItemIterator", "Count");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBuildItemIterator* pIBuildItemIterator = dynamic_cast<IBuildItemIterator*>(pIBaseClass);
		if (!pIBuildItemIterator)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIBuildItemIterator->Count();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Slice
**************************************************************************************************************************/
Lib3MFResult lib3mf_slice_setvertices(Lib3MF_Slice pSlice, Lib3MF_uint64 nVerticesBufferSize, const sLib3MFPosition2D * pVerticesBuffer)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "SetVertices");
		}
		if ( (!pVerticesBuffer) && (nVerticesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISlice->SetVertices(nVerticesBufferSize, pVerticesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getvertices(Lib3MF_Slice pSlice, const Lib3MF_uint64 nVerticesBufferSize, Lib3MF_uint64* pVerticesNeededCount, sLib3MFPosition2D * pVerticesBuffer)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetVertices");
		}
		if ((!pVerticesBuffer) && !(pVerticesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISlice->GetVertices(nVerticesBufferSize, pVerticesNeededCount, pVerticesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getvertexcount(Lib3MF_Slice pSlice, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetVertexCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pISlice->GetVertexCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_addpolygon(Lib3MF_Slice pSlice, Lib3MF_uint64 nIndicesBufferSize, const Lib3MF_uint32 * pIndicesBuffer, Lib3MF_uint64 * pIndex)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "AddPolygon");
		}
		if ( (!pIndicesBuffer) && (nIndicesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pIndex == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pIndex = pISlice->AddPolygon(nIndicesBufferSize, pIndicesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Index", *pIndex);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getpolygoncount(Lib3MF_Slice pSlice, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetPolygonCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pISlice->GetPolygonCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_setpolygonindices(Lib3MF_Slice pSlice, Lib3MF_uint64 nIndex, Lib3MF_uint64 nIndicesBufferSize, const Lib3MF_uint32 * pIndicesBuffer)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "SetPolygonIndices");
			pJournalEntry->addUInt64Parameter("Index", nIndex);
		}
		if ( (!pIndicesBuffer) && (nIndicesBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISlice->SetPolygonIndices(nIndex, nIndicesBufferSize, pIndicesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getpolygonindices(Lib3MF_Slice pSlice, Lib3MF_uint64 nIndex, const Lib3MF_uint64 nIndicesBufferSize, Lib3MF_uint64* pIndicesNeededCount, Lib3MF_uint32 * pIndicesBuffer)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetPolygonIndices");
			pJournalEntry->addUInt64Parameter("Index", nIndex);
		}
		if ((!pIndicesBuffer) && !(pIndicesNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISlice->GetPolygonIndices(nIndex, nIndicesBufferSize, pIndicesNeededCount, pIndicesBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getpolygonindexcount(Lib3MF_Slice pSlice, Lib3MF_uint64 nIndex, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetPolygonIndexCount");
			pJournalEntry->addUInt64Parameter("Index", nIndex);
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pISlice->GetPolygonIndexCount(nIndex);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slice_getztop(Lib3MF_Slice pSlice, Lib3MF_double * pZTop)
{
	IBase* pIBaseClass = (IBase *)pSlice;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSlice, "Slice", "GetZTop");
		}
		if (pZTop == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISlice* pISlice = dynamic_cast<ISlice*>(pIBaseClass);
		if (!pISlice)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pZTop = pISlice->GetZTop();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("ZTop", *pZTop);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for SliceStack
**************************************************************************************************************************/
Lib3MFResult lib3mf_slicestack_getbottomz(Lib3MF_SliceStack pSliceStack, Lib3MF_double * pZBottom)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetBottomZ");
		}
		if (pZBottom == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pZBottom = pISliceStack->GetBottomZ();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("ZBottom", *pZBottom);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_getslicecount(Lib3MF_SliceStack pSliceStack, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetSliceCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pISliceStack->GetSliceCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_getslice(Lib3MF_SliceStack pSliceStack, Lib3MF_uint64 nSliceIndex, Lib3MF_Slice * pTheSlice)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetSlice");
			pJournalEntry->addUInt64Parameter("SliceIndex", nSliceIndex);
		}
		if (pTheSlice == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheSlice(nullptr);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheSlice = pISliceStack->GetSlice(nSliceIndex);

		*pTheSlice = (IBase*)(pBaseTheSlice);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheSlice", *pTheSlice);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_addslice(Lib3MF_SliceStack pSliceStack, Lib3MF_double dZTop, Lib3MF_Slice * pTheSlice)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "AddSlice");
			pJournalEntry->addDoubleParameter("ZTop", dZTop);
		}
		if (pTheSlice == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheSlice(nullptr);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheSlice = pISliceStack->AddSlice(dZTop);

		*pTheSlice = (IBase*)(pBaseTheSlice);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheSlice", *pTheSlice);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_getslicerefcount(Lib3MF_SliceStack pSliceStack, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetSliceRefCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pISliceStack->GetSliceRefCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_addslicestackreference(Lib3MF_SliceStack pSliceStack, Lib3MF_SliceStack pTheSliceStack)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "AddSliceStackReference");
			pJournalEntry->addHandleParameter("TheSliceStack", pTheSliceStack);
		}
		IBase* pIBaseClassTheSliceStack = (IBase *)pTheSliceStack;
		ISliceStack* pITheSliceStack = dynamic_cast<ISliceStack*>(pIBaseClassTheSliceStack);
		if (!pITheSliceStack)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISliceStack->AddSliceStackReference(pITheSliceStack);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_getslicestackreference(Lib3MF_SliceStack pSliceStack, Lib3MF_uint64 nSliceRefIndex, Lib3MF_SliceStack * pTheSliceStack)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetSliceStackReference");
			pJournalEntry->addUInt64Parameter("SliceRefIndex", nSliceRefIndex);
		}
		if (pTheSliceStack == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheSliceStack(nullptr);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheSliceStack = pISliceStack->GetSliceStackReference(nSliceRefIndex);

		*pTheSliceStack = (IBase*)(pBaseTheSliceStack);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheSliceStack", *pTheSliceStack);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_collapseslicereferences(Lib3MF_SliceStack pSliceStack)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "CollapseSliceReferences");
		}
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISliceStack->CollapseSliceReferences();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_setownpath(Lib3MF_SliceStack pSliceStack, const char * pPath)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "SetOwnPath");
			pJournalEntry->addStringParameter("Path", pPath);
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath(pPath);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pISliceStack->SetOwnPath(sPath);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_slicestack_getownpath(Lib3MF_SliceStack pSliceStack, const Lib3MF_uint32 nPathBufferSize, Lib3MF_uint32* pPathNeededChars, char * pPathBuffer)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSliceStack, "SliceStack", "GetOwnPath");
		}
		if ( (!pPathBuffer) && !(pPathNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPath("");
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPathBuffer == nullptr);
		if (isCacheCall) {
			sPath = pISliceStack->GetOwnPath();

			pISliceStack->_setCache (new ParameterCache_1<std::string> (sPath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISliceStack->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sPath);
			pISliceStack->_setCache (nullptr);
		}
		
		if (pPathNeededChars)
			*pPathNeededChars = (Lib3MF_uint32) (sPath.size()+1);
		if (pPathBuffer) {
			if (sPath.size() >= nPathBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPath = 0; iPath < sPath.size(); iPath++)
				pPathBuffer[iPath] = sPath[iPath];
			pPathBuffer[sPath.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Path", sPath.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Consumer
**************************************************************************************************************************/
Lib3MFResult lib3mf_consumer_getconsumerid(Lib3MF_Consumer pConsumer, const Lib3MF_uint32 nConsumerIDBufferSize, Lib3MF_uint32* pConsumerIDNeededChars, char * pConsumerIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pConsumer;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pConsumer, "Consumer", "GetConsumerID");
		}
		if ( (!pConsumerIDBuffer) && !(pConsumerIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sConsumerID("");
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClass);
		if (!pIConsumer)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pConsumerIDBuffer == nullptr);
		if (isCacheCall) {
			sConsumerID = pIConsumer->GetConsumerID();

			pIConsumer->_setCache (new ParameterCache_1<std::string> (sConsumerID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIConsumer->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sConsumerID);
			pIConsumer->_setCache (nullptr);
		}
		
		if (pConsumerIDNeededChars)
			*pConsumerIDNeededChars = (Lib3MF_uint32) (sConsumerID.size()+1);
		if (pConsumerIDBuffer) {
			if (sConsumerID.size() >= nConsumerIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iConsumerID = 0; iConsumerID < sConsumerID.size(); iConsumerID++)
				pConsumerIDBuffer[iConsumerID] = sConsumerID[iConsumerID];
			pConsumerIDBuffer[sConsumerID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("ConsumerID", sConsumerID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_consumer_getkeyid(Lib3MF_Consumer pConsumer, const Lib3MF_uint32 nKeyIDBufferSize, Lib3MF_uint32* pKeyIDNeededChars, char * pKeyIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pConsumer;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pConsumer, "Consumer", "GetKeyID");
		}
		if ( (!pKeyIDBuffer) && !(pKeyIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sKeyID("");
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClass);
		if (!pIConsumer)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pKeyIDBuffer == nullptr);
		if (isCacheCall) {
			sKeyID = pIConsumer->GetKeyID();

			pIConsumer->_setCache (new ParameterCache_1<std::string> (sKeyID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIConsumer->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sKeyID);
			pIConsumer->_setCache (nullptr);
		}
		
		if (pKeyIDNeededChars)
			*pKeyIDNeededChars = (Lib3MF_uint32) (sKeyID.size()+1);
		if (pKeyIDBuffer) {
			if (sKeyID.size() >= nKeyIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iKeyID = 0; iKeyID < sKeyID.size(); iKeyID++)
				pKeyIDBuffer[iKeyID] = sKeyID[iKeyID];
			pKeyIDBuffer[sKeyID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("KeyID", sKeyID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_consumer_getkeyvalue(Lib3MF_Consumer pConsumer, const Lib3MF_uint32 nKeyValueBufferSize, Lib3MF_uint32* pKeyValueNeededChars, char * pKeyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pConsumer;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pConsumer, "Consumer", "GetKeyValue");
		}
		if ( (!pKeyValueBuffer) && !(pKeyValueNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sKeyValue("");
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClass);
		if (!pIConsumer)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pKeyValueBuffer == nullptr);
		if (isCacheCall) {
			sKeyValue = pIConsumer->GetKeyValue();

			pIConsumer->_setCache (new ParameterCache_1<std::string> (sKeyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIConsumer->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sKeyValue);
			pIConsumer->_setCache (nullptr);
		}
		
		if (pKeyValueNeededChars)
			*pKeyValueNeededChars = (Lib3MF_uint32) (sKeyValue.size()+1);
		if (pKeyValueBuffer) {
			if (sKeyValue.size() >= nKeyValueBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iKeyValue = 0; iKeyValue < sKeyValue.size(); iKeyValue++)
				pKeyValueBuffer[iKeyValue] = sKeyValue[iKeyValue];
			pKeyValueBuffer[sKeyValue.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("KeyValue", sKeyValue.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for AccessRight
**************************************************************************************************************************/
Lib3MFResult lib3mf_accessright_getconsumer(Lib3MF_AccessRight pAccessRight, Lib3MF_Consumer * pConsumer)
{
	IBase* pIBaseClass = (IBase *)pAccessRight;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAccessRight, "AccessRight", "GetConsumer");
		}
		if (pConsumer == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseConsumer(nullptr);
		IAccessRight* pIAccessRight = dynamic_cast<IAccessRight*>(pIBaseClass);
		if (!pIAccessRight)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseConsumer = pIAccessRight->GetConsumer();

		*pConsumer = (IBase*)(pBaseConsumer);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Consumer", *pConsumer);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_accessright_getwrappingalgorithm(Lib3MF_AccessRight pAccessRight, eLib3MFWrappingAlgorithm * pAlgorithm)
{
	IBase* pIBaseClass = (IBase *)pAccessRight;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAccessRight, "AccessRight", "GetWrappingAlgorithm");
		}
		if (pAlgorithm == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAccessRight* pIAccessRight = dynamic_cast<IAccessRight*>(pIBaseClass);
		if (!pIAccessRight)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pAlgorithm = pIAccessRight->GetWrappingAlgorithm();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Algorithm", "WrappingAlgorithm", (Lib3MF_int32)(*pAlgorithm));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_accessright_getmgfalgorithm(Lib3MF_AccessRight pAccessRight, eLib3MFMgfAlgorithm * pAlgorithm)
{
	IBase* pIBaseClass = (IBase *)pAccessRight;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAccessRight, "AccessRight", "GetMgfAlgorithm");
		}
		if (pAlgorithm == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAccessRight* pIAccessRight = dynamic_cast<IAccessRight*>(pIBaseClass);
		if (!pIAccessRight)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pAlgorithm = pIAccessRight->GetMgfAlgorithm();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Algorithm", "MgfAlgorithm", (Lib3MF_int32)(*pAlgorithm));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_accessright_getdigestmethod(Lib3MF_AccessRight pAccessRight, eLib3MFDigestMethod * pAlgorithm)
{
	IBase* pIBaseClass = (IBase *)pAccessRight;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pAccessRight, "AccessRight", "GetDigestMethod");
		}
		if (pAlgorithm == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IAccessRight* pIAccessRight = dynamic_cast<IAccessRight*>(pIBaseClass);
		if (!pIAccessRight)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pAlgorithm = pIAccessRight->GetDigestMethod();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Algorithm", "DigestMethod", (Lib3MF_int32)(*pAlgorithm));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ContentEncryptionParams
**************************************************************************************************************************/
Lib3MFResult lib3mf_contentencryptionparams_getencryptionalgorithm(Lib3MF_ContentEncryptionParams pContentEncryptionParams, eLib3MFEncryptionAlgorithm * pAlgorithm)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetEncryptionAlgorithm");
		}
		if (pAlgorithm == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pAlgorithm = pIContentEncryptionParams->GetEncryptionAlgorithm();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Algorithm", "EncryptionAlgorithm", (Lib3MF_int32)(*pAlgorithm));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getkey(Lib3MF_ContentEncryptionParams pContentEncryptionParams, const Lib3MF_uint64 nByteDataBufferSize, Lib3MF_uint64* pByteDataNeededCount, Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetKey");
		}
		if ((!pByteDataBuffer) && !(pByteDataNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIContentEncryptionParams->GetKey(nByteDataBufferSize, pByteDataNeededCount, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getinitializationvector(Lib3MF_ContentEncryptionParams pContentEncryptionParams, const Lib3MF_uint64 nByteDataBufferSize, Lib3MF_uint64* pByteDataNeededCount, Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetInitializationVector");
		}
		if ((!pByteDataBuffer) && !(pByteDataNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIContentEncryptionParams->GetInitializationVector(nByteDataBufferSize, pByteDataNeededCount, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getauthenticationtag(Lib3MF_ContentEncryptionParams pContentEncryptionParams, const Lib3MF_uint64 nByteDataBufferSize, Lib3MF_uint64* pByteDataNeededCount, Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetAuthenticationTag");
		}
		if ((!pByteDataBuffer) && !(pByteDataNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIContentEncryptionParams->GetAuthenticationTag(nByteDataBufferSize, pByteDataNeededCount, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_setauthenticationtag(Lib3MF_ContentEncryptionParams pContentEncryptionParams, Lib3MF_uint64 nByteDataBufferSize, const Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "SetAuthenticationTag");
		}
		if ( (!pByteDataBuffer) && (nByteDataBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIContentEncryptionParams->SetAuthenticationTag(nByteDataBufferSize, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getadditionalauthenticationdata(Lib3MF_ContentEncryptionParams pContentEncryptionParams, const Lib3MF_uint64 nByteDataBufferSize, Lib3MF_uint64* pByteDataNeededCount, Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetAdditionalAuthenticationData");
		}
		if ((!pByteDataBuffer) && !(pByteDataNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIContentEncryptionParams->GetAdditionalAuthenticationData(nByteDataBufferSize, pByteDataNeededCount, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getdescriptor(Lib3MF_ContentEncryptionParams pContentEncryptionParams, Lib3MF_uint64 * pDescriptor)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetDescriptor");
		}
		if (pDescriptor == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pDescriptor = pIContentEncryptionParams->GetDescriptor();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Descriptor", *pDescriptor);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_contentencryptionparams_getkeyuuid(Lib3MF_ContentEncryptionParams pContentEncryptionParams, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pContentEncryptionParams;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pContentEncryptionParams, "ContentEncryptionParams", "GetKeyUUID");
		}
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IContentEncryptionParams* pIContentEncryptionParams = dynamic_cast<IContentEncryptionParams*>(pIBaseClass);
		if (!pIContentEncryptionParams)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIContentEncryptionParams->GetKeyUUID();

			pIContentEncryptionParams->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIContentEncryptionParams->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIContentEncryptionParams->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ResourceData
**************************************************************************************************************************/
Lib3MFResult lib3mf_resourcedata_getpath(Lib3MF_ResourceData pResourceData, Lib3MF_PackagePart * pPath)
{
	IBase* pIBaseClass = (IBase *)pResourceData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceData, "ResourceData", "GetPath");
		}
		if (pPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBasePath(nullptr);
		IResourceData* pIResourceData = dynamic_cast<IResourceData*>(pIBaseClass);
		if (!pIResourceData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBasePath = pIResourceData->GetPath();

		*pPath = (IBase*)(pBasePath);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Path", *pPath);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedata_getencryptionalgorithm(Lib3MF_ResourceData pResourceData, eLib3MFEncryptionAlgorithm * pEncryptionAlgorithm)
{
	IBase* pIBaseClass = (IBase *)pResourceData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceData, "ResourceData", "GetEncryptionAlgorithm");
		}
		if (pEncryptionAlgorithm == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceData* pIResourceData = dynamic_cast<IResourceData*>(pIBaseClass);
		if (!pIResourceData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pEncryptionAlgorithm = pIResourceData->GetEncryptionAlgorithm();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("EncryptionAlgorithm", "EncryptionAlgorithm", (Lib3MF_int32)(*pEncryptionAlgorithm));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedata_getcompression(Lib3MF_ResourceData pResourceData, eLib3MFCompression * pCompression)
{
	IBase* pIBaseClass = (IBase *)pResourceData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceData, "ResourceData", "GetCompression");
		}
		if (pCompression == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceData* pIResourceData = dynamic_cast<IResourceData*>(pIBaseClass);
		if (!pIResourceData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCompression = pIResourceData->GetCompression();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Compression", "Compression", (Lib3MF_int32)(*pCompression));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedata_getadditionalauthenticationdata(Lib3MF_ResourceData pResourceData, const Lib3MF_uint64 nByteDataBufferSize, Lib3MF_uint64* pByteDataNeededCount, Lib3MF_uint8 * pByteDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pResourceData;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceData, "ResourceData", "GetAdditionalAuthenticationData");
		}
		if ((!pByteDataBuffer) && !(pByteDataNeededCount))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IResourceData* pIResourceData = dynamic_cast<IResourceData*>(pIBaseClass);
		if (!pIResourceData)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIResourceData->GetAdditionalAuthenticationData(nByteDataBufferSize, pByteDataNeededCount, pByteDataBuffer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for ResourceDataGroup
**************************************************************************************************************************/
Lib3MFResult lib3mf_resourcedatagroup_getkeyuuid(Lib3MF_ResourceDataGroup pResourceDataGroup, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pResourceDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceDataGroup, "ResourceDataGroup", "GetKeyUUID");
		}
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClass);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIResourceDataGroup->GetKeyUUID();

			pIResourceDataGroup->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIResourceDataGroup->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIResourceDataGroup->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedatagroup_addaccessright(Lib3MF_ResourceDataGroup pResourceDataGroup, Lib3MF_Consumer pConsumer, eLib3MFWrappingAlgorithm eWrappingAlgorithm, eLib3MFMgfAlgorithm eMgfAlgorithm, eLib3MFDigestMethod eDigestMethod, Lib3MF_AccessRight * pTheAccessRight)
{
	IBase* pIBaseClass = (IBase *)pResourceDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceDataGroup, "ResourceDataGroup", "AddAccessRight");
			pJournalEntry->addHandleParameter("Consumer", pConsumer);
			pJournalEntry->addEnumParameter("WrappingAlgorithm", "WrappingAlgorithm", (Lib3MF_int32)(eWrappingAlgorithm));
			pJournalEntry->addEnumParameter("MgfAlgorithm", "MgfAlgorithm", (Lib3MF_int32)(eMgfAlgorithm));
			pJournalEntry->addEnumParameter("DigestMethod", "DigestMethod", (Lib3MF_int32)(eDigestMethod));
		}
		if (pTheAccessRight == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassConsumer = (IBase *)pConsumer;
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClassConsumer);
		if (!pIConsumer)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheAccessRight(nullptr);
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClass);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheAccessRight = pIResourceDataGroup->AddAccessRight(pIConsumer, eWrappingAlgorithm, eMgfAlgorithm, eDigestMethod);

		*pTheAccessRight = (IBase*)(pBaseTheAccessRight);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheAccessRight", *pTheAccessRight);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedatagroup_findaccessrightbyconsumer(Lib3MF_ResourceDataGroup pResourceDataGroup, Lib3MF_Consumer pConsumer, Lib3MF_AccessRight * pTheAccessRight)
{
	IBase* pIBaseClass = (IBase *)pResourceDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceDataGroup, "ResourceDataGroup", "FindAccessRightByConsumer");
			pJournalEntry->addHandleParameter("Consumer", pConsumer);
		}
		if (pTheAccessRight == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassConsumer = (IBase *)pConsumer;
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClassConsumer);
		if (!pIConsumer)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheAccessRight(nullptr);
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClass);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheAccessRight = pIResourceDataGroup->FindAccessRightByConsumer(pIConsumer);

		*pTheAccessRight = (IBase*)(pBaseTheAccessRight);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheAccessRight", *pTheAccessRight);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_resourcedatagroup_removeaccessright(Lib3MF_ResourceDataGroup pResourceDataGroup, Lib3MF_Consumer pConsumer)
{
	IBase* pIBaseClass = (IBase *)pResourceDataGroup;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pResourceDataGroup, "ResourceDataGroup", "RemoveAccessRight");
			pJournalEntry->addHandleParameter("Consumer", pConsumer);
		}
		IBase* pIBaseClassConsumer = (IBase *)pConsumer;
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClassConsumer);
		if (!pIConsumer)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClass);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIResourceDataGroup->RemoveAccessRight(pIConsumer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for KeyStore
**************************************************************************************************************************/
Lib3MFResult lib3mf_keystore_addconsumer(Lib3MF_KeyStore pKeyStore, const char * pConsumerID, const char * pKeyID, const char * pKeyValue, Lib3MF_Consumer * pConsumer)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "AddConsumer");
			pJournalEntry->addStringParameter("ConsumerID", pConsumerID);
			pJournalEntry->addStringParameter("KeyID", pKeyID);
			pJournalEntry->addStringParameter("KeyValue", pKeyValue);
		}
		if (pConsumerID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pKeyID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pKeyValue == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pConsumer == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sConsumerID(pConsumerID);
		std::string sKeyID(pKeyID);
		std::string sKeyValue(pKeyValue);
		IBase* pBaseConsumer(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseConsumer = pIKeyStore->AddConsumer(sConsumerID, sKeyID, sKeyValue);

		*pConsumer = (IBase*)(pBaseConsumer);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Consumer", *pConsumer);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getconsumercount(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetConsumerCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIKeyStore->GetConsumerCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getconsumer(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 nConsumerIndex, Lib3MF_Consumer * pConsumer)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetConsumer");
			pJournalEntry->addUInt64Parameter("ConsumerIndex", nConsumerIndex);
		}
		if (pConsumer == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseConsumer(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseConsumer = pIKeyStore->GetConsumer(nConsumerIndex);

		*pConsumer = (IBase*)(pBaseConsumer);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Consumer", *pConsumer);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_removeconsumer(Lib3MF_KeyStore pKeyStore, Lib3MF_Consumer pConsumer)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "RemoveConsumer");
			pJournalEntry->addHandleParameter("Consumer", pConsumer);
		}
		IBase* pIBaseClassConsumer = (IBase *)pConsumer;
		IConsumer* pIConsumer = dynamic_cast<IConsumer*>(pIBaseClassConsumer);
		if (!pIConsumer)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIKeyStore->RemoveConsumer(pIConsumer);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_findconsumer(Lib3MF_KeyStore pKeyStore, const char * pConsumerID, Lib3MF_Consumer * pConsumer)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "FindConsumer");
			pJournalEntry->addStringParameter("ConsumerID", pConsumerID);
		}
		if (pConsumerID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pConsumer == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sConsumerID(pConsumerID);
		IBase* pBaseConsumer(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseConsumer = pIKeyStore->FindConsumer(sConsumerID);

		*pConsumer = (IBase*)(pBaseConsumer);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Consumer", *pConsumer);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getresourcedatagroupcount(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetResourceDataGroupCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIKeyStore->GetResourceDataGroupCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_addresourcedatagroup(Lib3MF_KeyStore pKeyStore, Lib3MF_ResourceDataGroup * pResourceDataGroup)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "AddResourceDataGroup");
		}
		if (pResourceDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceDataGroup(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceDataGroup = pIKeyStore->AddResourceDataGroup();

		*pResourceDataGroup = (IBase*)(pBaseResourceDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceDataGroup", *pResourceDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getresourcedatagroup(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 nResourceDataIndex, Lib3MF_ResourceDataGroup * pResourceDataGroup)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetResourceDataGroup");
			pJournalEntry->addUInt64Parameter("ResourceDataIndex", nResourceDataIndex);
		}
		if (pResourceDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceDataGroup(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceDataGroup = pIKeyStore->GetResourceDataGroup(nResourceDataIndex);

		*pResourceDataGroup = (IBase*)(pBaseResourceDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceDataGroup", *pResourceDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_removeresourcedatagroup(Lib3MF_KeyStore pKeyStore, Lib3MF_ResourceDataGroup pResourceDataGroup)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "RemoveResourceDataGroup");
			pJournalEntry->addHandleParameter("ResourceDataGroup", pResourceDataGroup);
		}
		IBase* pIBaseClassResourceDataGroup = (IBase *)pResourceDataGroup;
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClassResourceDataGroup);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIKeyStore->RemoveResourceDataGroup(pIResourceDataGroup);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_findresourcedatagroup(Lib3MF_KeyStore pKeyStore, Lib3MF_PackagePart pPartPath, Lib3MF_ResourceDataGroup * pResourceDataGroup)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "FindResourceDataGroup");
			pJournalEntry->addHandleParameter("PartPath", pPartPath);
		}
		if (pResourceDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassPartPath = (IBase *)pPartPath;
		IPackagePart* pIPartPath = dynamic_cast<IPackagePart*>(pIBaseClassPartPath);
		if (!pIPartPath)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseResourceDataGroup(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceDataGroup = pIKeyStore->FindResourceDataGroup(pIPartPath);

		*pResourceDataGroup = (IBase*)(pBaseResourceDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceDataGroup", *pResourceDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_addresourcedata(Lib3MF_KeyStore pKeyStore, Lib3MF_ResourceDataGroup pResourceDataGroup, Lib3MF_PackagePart pPartPath, eLib3MFEncryptionAlgorithm eAlgorithm, eLib3MFCompression eCompression, Lib3MF_uint64 nAdditionalAuthenticationDataBufferSize, const Lib3MF_uint8 * pAdditionalAuthenticationDataBuffer, Lib3MF_ResourceData * pResourceData)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "AddResourceData");
			pJournalEntry->addHandleParameter("ResourceDataGroup", pResourceDataGroup);
			pJournalEntry->addHandleParameter("PartPath", pPartPath);
			pJournalEntry->addEnumParameter("Algorithm", "EncryptionAlgorithm", (Lib3MF_int32)(eAlgorithm));
			pJournalEntry->addEnumParameter("Compression", "Compression", (Lib3MF_int32)(eCompression));
		}
		if ( (!pAdditionalAuthenticationDataBuffer) && (nAdditionalAuthenticationDataBufferSize>0))
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pResourceData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassResourceDataGroup = (IBase *)pResourceDataGroup;
		IResourceDataGroup* pIResourceDataGroup = dynamic_cast<IResourceDataGroup*>(pIBaseClassResourceDataGroup);
		if (!pIResourceDataGroup)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pIBaseClassPartPath = (IBase *)pPartPath;
		IPackagePart* pIPartPath = dynamic_cast<IPackagePart*>(pIBaseClassPartPath);
		if (!pIPartPath)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseResourceData(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceData = pIKeyStore->AddResourceData(pIResourceDataGroup, pIPartPath, eAlgorithm, eCompression, nAdditionalAuthenticationDataBufferSize, pAdditionalAuthenticationDataBuffer);

		*pResourceData = (IBase*)(pBaseResourceData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceData", *pResourceData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_removeresourcedata(Lib3MF_KeyStore pKeyStore, Lib3MF_ResourceData pResourceData)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "RemoveResourceData");
			pJournalEntry->addHandleParameter("ResourceData", pResourceData);
		}
		IBase* pIBaseClassResourceData = (IBase *)pResourceData;
		IResourceData* pIResourceData = dynamic_cast<IResourceData*>(pIBaseClassResourceData);
		if (!pIResourceData)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIKeyStore->RemoveResourceData(pIResourceData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_findresourcedata(Lib3MF_KeyStore pKeyStore, Lib3MF_PackagePart pResourcePath, Lib3MF_ResourceData * pResourceData)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "FindResourceData");
			pJournalEntry->addHandleParameter("ResourcePath", pResourcePath);
		}
		if (pResourceData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassResourcePath = (IBase *)pResourcePath;
		IPackagePart* pIResourcePath = dynamic_cast<IPackagePart*>(pIBaseClassResourcePath);
		if (!pIResourcePath)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseResourceData(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceData = pIKeyStore->FindResourceData(pIResourcePath);

		*pResourceData = (IBase*)(pBaseResourceData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceData", *pResourceData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getresourcedatacount(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetResourceDataCount");
		}
		if (pCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pCount = pIKeyStore->GetResourceDataCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result("Count", *pCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getresourcedata(Lib3MF_KeyStore pKeyStore, Lib3MF_uint64 nResourceDataIndex, Lib3MF_ResourceData * pResourceData)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetResourceData");
			pJournalEntry->addUInt64Parameter("ResourceDataIndex", nResourceDataIndex);
		}
		if (pResourceData == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceData(nullptr);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceData = pIKeyStore->GetResourceData(nResourceDataIndex);

		*pResourceData = (IBase*)(pBaseResourceData);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceData", *pResourceData);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_getuuid(Lib3MF_KeyStore pKeyStore, bool * pHasUUID, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "GetUUID");
		}
		if (!pHasUUID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIKeyStore->GetUUID(*pHasUUID);

			pIKeyStore->_setCache (new ParameterCache_2<bool, std::string> (*pHasUUID, sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<bool, std::string>*> (pIKeyStore->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pHasUUID, sUUID);
			pIKeyStore->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasUUID", *pHasUUID);
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_keystore_setuuid(Lib3MF_KeyStore pKeyStore, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pKeyStore;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pKeyStore, "KeyStore", "SetUUID");
			pJournalEntry->addStringParameter("UUID", pUUID);
		}
		if (pUUID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IKeyStore* pIKeyStore = dynamic_cast<IKeyStore*>(pIBaseClass);
		if (!pIKeyStore)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIKeyStore->SetUUID(sUUID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


/*************************************************************************************************************************
 Class implementation for Model
**************************************************************************************************************************/
Lib3MFResult lib3mf_model_rootmodelpart(Lib3MF_Model pModel, Lib3MF_PackagePart * pRootModelPart)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "RootModelPart");
		}
		if (pRootModelPart == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseRootModelPart(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseRootModelPart = pIModel->RootModelPart();

		*pRootModelPart = (IBase*)(pBaseRootModelPart);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("RootModelPart", *pRootModelPart);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_findorcreatepackagepart(Lib3MF_Model pModel, const char * pAbsolutePath, Lib3MF_PackagePart * pModelPart)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "FindOrCreatePackagePart");
			pJournalEntry->addStringParameter("AbsolutePath", pAbsolutePath);
		}
		if (pAbsolutePath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pModelPart == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sAbsolutePath(pAbsolutePath);
		IBase* pBaseModelPart(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseModelPart = pIModel->FindOrCreatePackagePart(sAbsolutePath);

		*pModelPart = (IBase*)(pBaseModelPart);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ModelPart", *pModelPart);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_setunit(Lib3MF_Model pModel, eLib3MFModelUnit eUnit)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "SetUnit");
			pJournalEntry->addEnumParameter("Unit", "ModelUnit", (Lib3MF_int32)(eUnit));
		}
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->SetUnit(eUnit);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getunit(Lib3MF_Model pModel, eLib3MFModelUnit * pUnit)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetUnit");
		}
		if (pUnit == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pUnit = pIModel->GetUnit();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("Unit", "ModelUnit", (Lib3MF_int32)(*pUnit));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getlanguage(Lib3MF_Model pModel, const Lib3MF_uint32 nLanguageBufferSize, Lib3MF_uint32* pLanguageNeededChars, char * pLanguageBuffer)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetLanguage");
		}
		if ( (!pLanguageBuffer) && !(pLanguageNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sLanguage("");
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pLanguageBuffer == nullptr);
		if (isCacheCall) {
			sLanguage = pIModel->GetLanguage();

			pIModel->_setCache (new ParameterCache_1<std::string> (sLanguage));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIModel->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (sLanguage);
			pIModel->_setCache (nullptr);
		}
		
		if (pLanguageNeededChars)
			*pLanguageNeededChars = (Lib3MF_uint32) (sLanguage.size()+1);
		if (pLanguageBuffer) {
			if (sLanguage.size() >= nLanguageBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguage = 0; iLanguage < sLanguage.size(); iLanguage++)
				pLanguageBuffer[iLanguage] = sLanguage[iLanguage];
			pLanguageBuffer[sLanguage.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Language", sLanguage.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_setlanguage(Lib3MF_Model pModel, const char * pLanguage)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "SetLanguage");
			pJournalEntry->addStringParameter("Language", pLanguage);
		}
		if (pLanguage == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sLanguage(pLanguage);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->SetLanguage(sLanguage);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_querywriter(Lib3MF_Model pModel, const char * pWriterClass, Lib3MF_Writer * pWriterInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "QueryWriter");
			pJournalEntry->addStringParameter("WriterClass", pWriterClass);
		}
		if (pWriterClass == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pWriterInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sWriterClass(pWriterClass);
		IBase* pBaseWriterInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseWriterInstance = pIModel->QueryWriter(sWriterClass);

		*pWriterInstance = (IBase*)(pBaseWriterInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("WriterInstance", *pWriterInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_queryreader(Lib3MF_Model pModel, const char * pReaderClass, Lib3MF_Reader * pReaderInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "QueryReader");
			pJournalEntry->addStringParameter("ReaderClass", pReaderClass);
		}
		if (pReaderClass == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pReaderInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sReaderClass(pReaderClass);
		IBase* pBaseReaderInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseReaderInstance = pIModel->QueryReader(sReaderClass);

		*pReaderInstance = (IBase*)(pBaseReaderInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ReaderInstance", *pReaderInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getresourcebyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Resource * pResource)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetResourceByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pResource == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResource(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResource = pIModel->GetResourceByID(nUniqueResourceID);

		*pResource = (IBase*)(pBaseResource);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Resource", *pResource);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_gettexture2dbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Texture2D * pTextureInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetTexture2DByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pTextureInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTextureInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTextureInstance = pIModel->GetTexture2DByID(nUniqueResourceID);

		*pTextureInstance = (IBase*)(pBaseTextureInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TextureInstance", *pTextureInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getpropertytypebyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, eLib3MFPropertyType * pThePropertyType)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetPropertyTypeByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pThePropertyType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pThePropertyType = pIModel->GetPropertyTypeByID(nUniqueResourceID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addEnumResult("ThePropertyType", "PropertyType", (Lib3MF_int32)(*pThePropertyType));
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getbasematerialgroupbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_BaseMaterialGroup * pBaseMaterialGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetBaseMaterialGroupByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pBaseMaterialGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBaseMaterialGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBaseMaterialGroupInstance = pIModel->GetBaseMaterialGroupByID(nUniqueResourceID);

		*pBaseMaterialGroupInstance = (IBase*)(pBaseBaseMaterialGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BaseMaterialGroupInstance", *pBaseMaterialGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_gettexture2dgroupbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Texture2DGroup * pTexture2DGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetTexture2DGroupByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pTexture2DGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTexture2DGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTexture2DGroupInstance = pIModel->GetTexture2DGroupByID(nUniqueResourceID);

		*pTexture2DGroupInstance = (IBase*)(pBaseTexture2DGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Texture2DGroupInstance", *pTexture2DGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcompositematerialsbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_CompositeMaterials * pCompositeMaterialsInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetCompositeMaterialsByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pCompositeMaterialsInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseCompositeMaterialsInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseCompositeMaterialsInstance = pIModel->GetCompositeMaterialsByID(nUniqueResourceID);

		*pCompositeMaterialsInstance = (IBase*)(pBaseCompositeMaterialsInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("CompositeMaterialsInstance", *pCompositeMaterialsInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getmultipropertygroupbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_MultiPropertyGroup * pMultiPropertyGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetMultiPropertyGroupByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pMultiPropertyGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMultiPropertyGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMultiPropertyGroupInstance = pIModel->GetMultiPropertyGroupByID(nUniqueResourceID);

		*pMultiPropertyGroupInstance = (IBase*)(pBaseMultiPropertyGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MultiPropertyGroupInstance", *pMultiPropertyGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getmeshobjectbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_MeshObject * pMeshObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetMeshObjectByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pMeshObjectInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMeshObjectInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMeshObjectInstance = pIModel->GetMeshObjectByID(nUniqueResourceID);

		*pMeshObjectInstance = (IBase*)(pBaseMeshObjectInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MeshObjectInstance", *pMeshObjectInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcomponentsobjectbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ComponentsObject * pComponentsObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetComponentsObjectByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pComponentsObjectInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseComponentsObjectInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseComponentsObjectInstance = pIModel->GetComponentsObjectByID(nUniqueResourceID);

		*pComponentsObjectInstance = (IBase*)(pBaseComponentsObjectInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ComponentsObjectInstance", *pComponentsObjectInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcolorgroupbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ColorGroup * pColorGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetColorGroupByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pColorGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseColorGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseColorGroupInstance = pIModel->GetColorGroupByID(nUniqueResourceID);

		*pColorGroupInstance = (IBase*)(pBaseColorGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ColorGroupInstance", *pColorGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getslicestackbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_SliceStack * pSliceStacInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetSliceStackByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pSliceStacInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseSliceStacInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSliceStacInstance = pIModel->GetSliceStackByID(nUniqueResourceID);

		*pSliceStacInstance = (IBase*)(pBaseSliceStacInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("SliceStacInstance", *pSliceStacInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getbuilduuid(Lib3MF_Model pModel, bool * pHasUUID, const Lib3MF_uint32 nUUIDBufferSize, Lib3MF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetBuildUUID");
		}
		if (!pHasUUID)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIModel->GetBuildUUID(*pHasUUID);

			pIModel->_setCache (new ParameterCache_2<bool, std::string> (*pHasUUID, sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<bool, std::string>*> (pIModel->_getCache ());
			if (cache == nullptr)
				throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
			cache->retrieveData (*pHasUUID, sUUID);
			pIModel->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (Lib3MF_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasUUID", *pHasUUID);
			pJournalEntry->addStringResult("UUID", sUUID.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_setbuilduuid(Lib3MF_Model pModel, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "SetBuildUUID");
			pJournalEntry->addStringParameter("UUID", pUUID);
		}
		if (pUUID == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->SetBuildUUID(sUUID);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getbuilditems(Lib3MF_Model pModel, Lib3MF_BuildItemIterator * pBuildItemIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetBuildItems");
		}
		if (pBuildItemIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBuildItemIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBuildItemIterator = pIModel->GetBuildItems();

		*pBuildItemIterator = (IBase*)(pBaseBuildItemIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BuildItemIterator", *pBuildItemIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getoutbox(Lib3MF_Model pModel, sLib3MFBox * pOutbox)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetOutbox");
		}
		if (pOutbox == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pOutbox = pIModel->GetOutbox();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getresources(Lib3MF_Model pModel, Lib3MF_ResourceIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetResources");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetResources();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getobjects(Lib3MF_Model pModel, Lib3MF_ObjectIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetObjects");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetObjects();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getmeshobjects(Lib3MF_Model pModel, Lib3MF_MeshObjectIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetMeshObjects");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetMeshObjects();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcomponentsobjects(Lib3MF_Model pModel, Lib3MF_ComponentsObjectIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetComponentsObjects");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetComponentsObjects();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_gettexture2ds(Lib3MF_Model pModel, Lib3MF_Texture2DIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetTexture2Ds");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetTexture2Ds();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getbasematerialgroups(Lib3MF_Model pModel, Lib3MF_BaseMaterialGroupIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetBaseMaterialGroups");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetBaseMaterialGroups();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcolorgroups(Lib3MF_Model pModel, Lib3MF_ColorGroupIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetColorGroups");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetColorGroups();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_gettexture2dgroups(Lib3MF_Model pModel, Lib3MF_Texture2DGroupIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetTexture2DGroups");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetTexture2DGroups();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getcompositematerials(Lib3MF_Model pModel, Lib3MF_CompositeMaterialsIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetCompositeMaterials");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetCompositeMaterials();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getmultipropertygroups(Lib3MF_Model pModel, Lib3MF_MultiPropertyGroupIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetMultiPropertyGroups");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetMultiPropertyGroups();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getslicestacks(Lib3MF_Model pModel, Lib3MF_SliceStackIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetSliceStacks");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetSliceStacks();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getimage3ds(Lib3MF_Model pModel, Lib3MF_Image3DIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetImage3Ds");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetImage3Ds();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getscalarfields(Lib3MF_Model pModel, Lib3MF_ScalarFieldIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetScalarFields");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetScalarFields();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getvector3dfields(Lib3MF_Model pModel, Lib3MF_Vector3DFieldIterator * pResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetVector3DFields");
		}
		if (pResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseResourceIterator = pIModel->GetVector3DFields();

		*pResourceIterator = (IBase*)(pBaseResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ResourceIterator", *pResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_mergetomodel(Lib3MF_Model pModel, Lib3MF_Model * pMergedModelInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "MergeToModel");
		}
		if (pMergedModelInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMergedModelInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMergedModelInstance = pIModel->MergeToModel();

		*pMergedModelInstance = (IBase*)(pBaseMergedModelInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MergedModelInstance", *pMergedModelInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addmeshobject(Lib3MF_Model pModel, Lib3MF_MeshObject * pMeshObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddMeshObject");
		}
		if (pMeshObjectInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMeshObjectInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMeshObjectInstance = pIModel->AddMeshObject();

		*pMeshObjectInstance = (IBase*)(pBaseMeshObjectInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MeshObjectInstance", *pMeshObjectInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addcomponentsobject(Lib3MF_Model pModel, Lib3MF_ComponentsObject * pComponentsObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddComponentsObject");
		}
		if (pComponentsObjectInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseComponentsObjectInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseComponentsObjectInstance = pIModel->AddComponentsObject();

		*pComponentsObjectInstance = (IBase*)(pBaseComponentsObjectInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ComponentsObjectInstance", *pComponentsObjectInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addslicestack(Lib3MF_Model pModel, Lib3MF_double dZBottom, Lib3MF_SliceStack * pSliceStackInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddSliceStack");
			pJournalEntry->addDoubleParameter("ZBottom", dZBottom);
		}
		if (pSliceStackInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseSliceStackInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseSliceStackInstance = pIModel->AddSliceStack(dZBottom);

		*pSliceStackInstance = (IBase*)(pBaseSliceStackInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("SliceStackInstance", *pSliceStackInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addtexture2dfromattachment(Lib3MF_Model pModel, Lib3MF_Attachment pTextureAttachment, Lib3MF_Texture2D * pTexture2DInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddTexture2DFromAttachment");
			pJournalEntry->addHandleParameter("TextureAttachment", pTextureAttachment);
		}
		if (pTexture2DInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassTextureAttachment = (IBase *)pTextureAttachment;
		IAttachment* pITextureAttachment = dynamic_cast<IAttachment*>(pIBaseClassTextureAttachment);
		if (!pITextureAttachment)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTexture2DInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTexture2DInstance = pIModel->AddTexture2DFromAttachment(pITextureAttachment);

		*pTexture2DInstance = (IBase*)(pBaseTexture2DInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Texture2DInstance", *pTexture2DInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addbasematerialgroup(Lib3MF_Model pModel, Lib3MF_BaseMaterialGroup * pBaseMaterialGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddBaseMaterialGroup");
		}
		if (pBaseMaterialGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseBaseMaterialGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBaseMaterialGroupInstance = pIModel->AddBaseMaterialGroup();

		*pBaseMaterialGroupInstance = (IBase*)(pBaseBaseMaterialGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BaseMaterialGroupInstance", *pBaseMaterialGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addcolorgroup(Lib3MF_Model pModel, Lib3MF_ColorGroup * pColorGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddColorGroup");
		}
		if (pColorGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseColorGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseColorGroupInstance = pIModel->AddColorGroup();

		*pColorGroupInstance = (IBase*)(pBaseColorGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ColorGroupInstance", *pColorGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addtexture2dgroup(Lib3MF_Model pModel, Lib3MF_Texture2D pTexture2DInstance, Lib3MF_Texture2DGroup * pTexture2DGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddTexture2DGroup");
			pJournalEntry->addHandleParameter("Texture2DInstance", pTexture2DInstance);
		}
		if (pTexture2DGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassTexture2DInstance = (IBase *)pTexture2DInstance;
		ITexture2D* pITexture2DInstance = dynamic_cast<ITexture2D*>(pIBaseClassTexture2DInstance);
		if (!pITexture2DInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTexture2DGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTexture2DGroupInstance = pIModel->AddTexture2DGroup(pITexture2DInstance);

		*pTexture2DGroupInstance = (IBase*)(pBaseTexture2DGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Texture2DGroupInstance", *pTexture2DGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addcompositematerials(Lib3MF_Model pModel, Lib3MF_BaseMaterialGroup pBaseMaterialGroupInstance, Lib3MF_CompositeMaterials * pCompositeMaterialsInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddCompositeMaterials");
			pJournalEntry->addHandleParameter("BaseMaterialGroupInstance", pBaseMaterialGroupInstance);
		}
		if (pCompositeMaterialsInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassBaseMaterialGroupInstance = (IBase *)pBaseMaterialGroupInstance;
		IBaseMaterialGroup* pIBaseMaterialGroupInstance = dynamic_cast<IBaseMaterialGroup*>(pIBaseClassBaseMaterialGroupInstance);
		if (!pIBaseMaterialGroupInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseCompositeMaterialsInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseCompositeMaterialsInstance = pIModel->AddCompositeMaterials(pIBaseMaterialGroupInstance);

		*pCompositeMaterialsInstance = (IBase*)(pBaseCompositeMaterialsInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("CompositeMaterialsInstance", *pCompositeMaterialsInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addmultipropertygroup(Lib3MF_Model pModel, Lib3MF_MultiPropertyGroup * pMultiPropertyGroupInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddMultiPropertyGroup");
		}
		if (pMultiPropertyGroupInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseMultiPropertyGroupInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseMultiPropertyGroupInstance = pIModel->AddMultiPropertyGroup();

		*pMultiPropertyGroupInstance = (IBase*)(pBaseMultiPropertyGroupInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("MultiPropertyGroupInstance", *pMultiPropertyGroupInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addimagestack(Lib3MF_Model pModel, Lib3MF_uint32 nColumnCount, Lib3MF_uint32 nRowCount, Lib3MF_uint32 nSheetCount, Lib3MF_ImageStack * pInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddImageStack");
			pJournalEntry->addUInt32Parameter("ColumnCount", nColumnCount);
			pJournalEntry->addUInt32Parameter("RowCount", nRowCount);
			pJournalEntry->addUInt32Parameter("SheetCount", nSheetCount);
		}
		if (pInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseInstance = pIModel->AddImageStack(nColumnCount, nRowCount, nSheetCount);

		*pInstance = (IBase*)(pBaseInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Instance", *pInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getimagestackbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ImageStack * pImageStackInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetImageStackByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pImageStackInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseImageStackInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseImageStackInstance = pIModel->GetImageStackByID(nUniqueResourceID);

		*pImageStackInstance = (IBase*)(pBaseImageStackInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ImageStackInstance", *pImageStackInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addscalarfieldfromimage3d(Lib3MF_Model pModel, Lib3MF_Image3D pImage3D, Lib3MF_ScalarFieldFromImage3D * pTheScalarFieldFromImage3D)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddScalarFieldFromImage3D");
			pJournalEntry->addHandleParameter("Image3D", pImage3D);
		}
		if (pTheScalarFieldFromImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassImage3D = (IBase *)pImage3D;
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClassImage3D);
		if (!pIImage3D)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheScalarFieldFromImage3D(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldFromImage3D = pIModel->AddScalarFieldFromImage3D(pIImage3D);

		*pTheScalarFieldFromImage3D = (IBase*)(pBaseTheScalarFieldFromImage3D);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldFromImage3D", *pTheScalarFieldFromImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addscalarfieldcomposed(Lib3MF_Model pModel, Lib3MF_ScalarFieldComposed * pTheScalarFieldComposed)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddScalarFieldComposed");
		}
		if (pTheScalarFieldComposed == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldComposed(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldComposed = pIModel->AddScalarFieldComposed();

		*pTheScalarFieldComposed = (IBase*)(pBaseTheScalarFieldComposed);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldComposed", *pTheScalarFieldComposed);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addscalarfieldconstant(Lib3MF_Model pModel, Lib3MF_ScalarFieldConstant * pTheScalarFieldConstant)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddScalarFieldConstant");
		}
		if (pTheScalarFieldConstant == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheScalarFieldConstant(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheScalarFieldConstant = pIModel->AddScalarFieldConstant();

		*pTheScalarFieldConstant = (IBase*)(pBaseTheScalarFieldConstant);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheScalarFieldConstant", *pTheScalarFieldConstant);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getscalarfieldbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ScalarField * pScalarFieldInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetScalarFieldByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pScalarFieldInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseScalarFieldInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseScalarFieldInstance = pIModel->GetScalarFieldByID(nUniqueResourceID);

		*pScalarFieldInstance = (IBase*)(pBaseScalarFieldInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ScalarFieldInstance", *pScalarFieldInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getscalarfieldfromimage3dbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ScalarFieldFromImage3D * pScalarFieldFromImage3DInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetScalarFieldFromImage3DByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pScalarFieldFromImage3DInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseScalarFieldFromImage3DInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseScalarFieldFromImage3DInstance = pIModel->GetScalarFieldFromImage3DByID(nUniqueResourceID);

		*pScalarFieldFromImage3DInstance = (IBase*)(pBaseScalarFieldFromImage3DInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ScalarFieldFromImage3DInstance", *pScalarFieldFromImage3DInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getscalarfieldcomposedbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ScalarFieldComposed * pScalarFieldComposedInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetScalarFieldComposedByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pScalarFieldComposedInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseScalarFieldComposedInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseScalarFieldComposedInstance = pIModel->GetScalarFieldComposedByID(nUniqueResourceID);

		*pScalarFieldComposedInstance = (IBase*)(pBaseScalarFieldComposedInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ScalarFieldComposedInstance", *pScalarFieldComposedInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getscalarfieldconstantbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_ScalarFieldConstant * pScalarFieldConstantInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetScalarFieldConstantByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pScalarFieldConstantInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseScalarFieldConstantInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseScalarFieldConstantInstance = pIModel->GetScalarFieldConstantByID(nUniqueResourceID);

		*pScalarFieldConstantInstance = (IBase*)(pBaseScalarFieldConstantInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ScalarFieldConstantInstance", *pScalarFieldConstantInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addvector3dfieldfromimage3d(Lib3MF_Model pModel, Lib3MF_Image3D pImage3D, Lib3MF_Vector3DFieldFromImage3D * pTheVector3DFieldFromImage3D)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddVector3DFieldFromImage3D");
			pJournalEntry->addHandleParameter("Image3D", pImage3D);
		}
		if (pTheVector3DFieldFromImage3D == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassImage3D = (IBase *)pImage3D;
		IImage3D* pIImage3D = dynamic_cast<IImage3D*>(pIBaseClassImage3D);
		if (!pIImage3D)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseTheVector3DFieldFromImage3D(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVector3DFieldFromImage3D = pIModel->AddVector3DFieldFromImage3D(pIImage3D);

		*pTheVector3DFieldFromImage3D = (IBase*)(pBaseTheVector3DFieldFromImage3D);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVector3DFieldFromImage3D", *pTheVector3DFieldFromImage3D);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addvector3dfieldcomposed(Lib3MF_Model pModel, Lib3MF_Vector3DFieldComposed * pTheVector3DFieldComposed)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddVector3DFieldComposed");
		}
		if (pTheVector3DFieldComposed == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVector3DFieldComposed(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVector3DFieldComposed = pIModel->AddVector3DFieldComposed();

		*pTheVector3DFieldComposed = (IBase*)(pBaseTheVector3DFieldComposed);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVector3DFieldComposed", *pTheVector3DFieldComposed);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addvector3dfieldconstant(Lib3MF_Model pModel, Lib3MF_Vector3DFieldConstant * pTheVector3DFieldConstant)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddVector3DFieldConstant");
		}
		if (pTheVector3DFieldConstant == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheVector3DFieldConstant(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheVector3DFieldConstant = pIModel->AddVector3DFieldConstant();

		*pTheVector3DFieldConstant = (IBase*)(pBaseTheVector3DFieldConstant);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheVector3DFieldConstant", *pTheVector3DFieldConstant);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getvector3dfieldbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Vector3DField * pVector3DFieldInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetVector3DFieldByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pVector3DFieldInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseVector3DFieldInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseVector3DFieldInstance = pIModel->GetVector3DFieldByID(nUniqueResourceID);

		*pVector3DFieldInstance = (IBase*)(pBaseVector3DFieldInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Vector3DFieldInstance", *pVector3DFieldInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getvector3dfieldfromimage3dbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Vector3DFieldFromImage3D * pVector3DFieldFromImage3DInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetVector3DFieldFromImage3DByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pVector3DFieldFromImage3DInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseVector3DFieldFromImage3DInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseVector3DFieldFromImage3DInstance = pIModel->GetVector3DFieldFromImage3DByID(nUniqueResourceID);

		*pVector3DFieldFromImage3DInstance = (IBase*)(pBaseVector3DFieldFromImage3DInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Vector3DFieldFromImage3DInstance", *pVector3DFieldFromImage3DInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getvector3dfieldcomposedbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Vector3DFieldComposed * pVector3DFieldComposedInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetVector3DFieldComposedByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pVector3DFieldComposedInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseVector3DFieldComposedInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseVector3DFieldComposedInstance = pIModel->GetVector3DFieldComposedByID(nUniqueResourceID);

		*pVector3DFieldComposedInstance = (IBase*)(pBaseVector3DFieldComposedInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Vector3DFieldComposedInstance", *pVector3DFieldComposedInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getvector3dfieldconstantbyid(Lib3MF_Model pModel, Lib3MF_uint32 nUniqueResourceID, Lib3MF_Vector3DFieldConstant * pVector3DFieldConstantInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetVector3DFieldConstantByID");
			pJournalEntry->addUInt32Parameter("UniqueResourceID", nUniqueResourceID);
		}
		if (pVector3DFieldConstantInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseVector3DFieldConstantInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseVector3DFieldConstantInstance = pIModel->GetVector3DFieldConstantByID(nUniqueResourceID);

		*pVector3DFieldConstantInstance = (IBase*)(pBaseVector3DFieldConstantInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Vector3DFieldConstantInstance", *pVector3DFieldConstantInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addbuilditem(Lib3MF_Model pModel, Lib3MF_Object pObject, const sLib3MFTransform * pTransform, Lib3MF_BuildItem * pBuildItemInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddBuildItem");
			pJournalEntry->addHandleParameter("Object", pObject);
		}
		if (pBuildItemInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassObject = (IBase *)pObject;
		IObject* pIObject = dynamic_cast<IObject*>(pIBaseClassObject);
		if (!pIObject)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IBase* pBaseBuildItemInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseBuildItemInstance = pIModel->AddBuildItem(pIObject, *pTransform);

		*pBuildItemInstance = (IBase*)(pBaseBuildItemInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("BuildItemInstance", *pBuildItemInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_removebuilditem(Lib3MF_Model pModel, Lib3MF_BuildItem pBuildItemInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "RemoveBuildItem");
			pJournalEntry->addHandleParameter("BuildItemInstance", pBuildItemInstance);
		}
		IBase* pIBaseClassBuildItemInstance = (IBase *)pBuildItemInstance;
		IBuildItem* pIBuildItemInstance = dynamic_cast<IBuildItem*>(pIBaseClassBuildItemInstance);
		if (!pIBuildItemInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->RemoveBuildItem(pIBuildItemInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getmetadatagroup(Lib3MF_Model pModel, Lib3MF_MetaDataGroup * pTheMetaDataGroup)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetMetaDataGroup");
		}
		if (pTheMetaDataGroup == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheMetaDataGroup(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheMetaDataGroup = pIModel->GetMetaDataGroup();

		*pTheMetaDataGroup = (IBase*)(pBaseTheMetaDataGroup);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheMetaDataGroup", *pTheMetaDataGroup);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addattachment(Lib3MF_Model pModel, const char * pURI, const char * pRelationShipType, Lib3MF_Attachment * pAttachmentInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddAttachment");
			pJournalEntry->addStringParameter("URI", pURI);
			pJournalEntry->addStringParameter("RelationShipType", pRelationShipType);
		}
		if (pURI == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pRelationShipType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pAttachmentInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sURI(pURI);
		std::string sRelationShipType(pRelationShipType);
		IBase* pBaseAttachmentInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachmentInstance = pIModel->AddAttachment(sURI, sRelationShipType);

		*pAttachmentInstance = (IBase*)(pBaseAttachmentInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("AttachmentInstance", *pAttachmentInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_removeattachment(Lib3MF_Model pModel, Lib3MF_Attachment pAttachmentInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "RemoveAttachment");
			pJournalEntry->addHandleParameter("AttachmentInstance", pAttachmentInstance);
		}
		IBase* pIBaseClassAttachmentInstance = (IBase *)pAttachmentInstance;
		IAttachment* pIAttachmentInstance = dynamic_cast<IAttachment*>(pIBaseClassAttachmentInstance);
		if (!pIAttachmentInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->RemoveAttachment(pIAttachmentInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getattachment(Lib3MF_Model pModel, Lib3MF_uint32 nIndex, Lib3MF_Attachment * pAttachmentInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetAttachment");
			pJournalEntry->addUInt32Parameter("Index", nIndex);
		}
		if (pAttachmentInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseAttachmentInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachmentInstance = pIModel->GetAttachment(nIndex);

		*pAttachmentInstance = (IBase*)(pBaseAttachmentInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("AttachmentInstance", *pAttachmentInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_findattachment(Lib3MF_Model pModel, const char * pURI, Lib3MF_Attachment * pAttachmentInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "FindAttachment");
			pJournalEntry->addStringParameter("URI", pURI);
		}
		if (pURI == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pAttachmentInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sURI(pURI);
		IBase* pBaseAttachmentInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachmentInstance = pIModel->FindAttachment(sURI);

		*pAttachmentInstance = (IBase*)(pBaseAttachmentInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("AttachmentInstance", *pAttachmentInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getattachmentcount(Lib3MF_Model pModel, Lib3MF_uint32 * pAttachmentCount)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetAttachmentCount");
		}
		if (pAttachmentCount == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pAttachmentCount = pIModel->GetAttachmentCount();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("AttachmentCount", *pAttachmentCount);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_haspackagethumbnailattachment(Lib3MF_Model pModel, bool * pHasThumbnail)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "HasPackageThumbnailAttachment");
		}
		if (pHasThumbnail == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		*pHasThumbnail = pIModel->HasPackageThumbnailAttachment();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasThumbnail", *pHasThumbnail);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_createpackagethumbnailattachment(Lib3MF_Model pModel, Lib3MF_Attachment * pAttachment)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "CreatePackageThumbnailAttachment");
		}
		if (pAttachment == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseAttachment(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachment = pIModel->CreatePackageThumbnailAttachment();

		*pAttachment = (IBase*)(pBaseAttachment);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Attachment", *pAttachment);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getpackagethumbnailattachment(Lib3MF_Model pModel, Lib3MF_Attachment * pAttachment)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetPackageThumbnailAttachment");
		}
		if (pAttachment == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseAttachment(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseAttachment = pIModel->GetPackageThumbnailAttachment();

		*pAttachment = (IBase*)(pBaseAttachment);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Attachment", *pAttachment);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_removepackagethumbnailattachment(Lib3MF_Model pModel)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "RemovePackageThumbnailAttachment");
		}
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->RemovePackageThumbnailAttachment();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addcustomcontenttype(Lib3MF_Model pModel, const char * pExtension, const char * pContentType)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddCustomContentType");
			pJournalEntry->addStringParameter("Extension", pExtension);
			pJournalEntry->addStringParameter("ContentType", pContentType);
		}
		if (pExtension == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pContentType == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sExtension(pExtension);
		std::string sContentType(pContentType);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->AddCustomContentType(sExtension, sContentType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_removecustomcontenttype(Lib3MF_Model pModel, const char * pExtension)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "RemoveCustomContentType");
			pJournalEntry->addStringParameter("Extension", pExtension);
		}
		if (pExtension == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sExtension(pExtension);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->RemoveCustomContentType(sExtension);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_setrandomnumbercallback(Lib3MF_Model pModel, Lib3MFRandomNumberCallback pTheCallback, Lib3MF_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "SetRandomNumberCallback");
			pJournalEntry->addPointerParameter("UserData", pUserData);
		}
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pIModel->SetRandomNumberCallback(pTheCallback, pUserData);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getkeystore(Lib3MF_Model pModel, Lib3MF_KeyStore * pKeyStore)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetKeyStore");
		}
		if (pKeyStore == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseKeyStore(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseKeyStore = pIModel->GetKeyStore();

		*pKeyStore = (IBase*)(pBaseKeyStore);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("KeyStore", *pKeyStore);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_getfunctions(Lib3MF_Model pModel, Lib3MF_FunctionIterator * pTheResourceIterator)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "GetFunctions");
		}
		if (pTheResourceIterator == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseTheResourceIterator(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseTheResourceIterator = pIModel->GetFunctions();

		*pTheResourceIterator = (IBase*)(pBaseTheResourceIterator);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("TheResourceIterator", *pTheResourceIterator);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_model_addfunction(Lib3MF_Model pModel, Lib3MF_ImplicitFunction * pFunctionInstance)
{
	IBase* pIBaseClass = (IBase *)pModel;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pModel, "Model", "AddFunction");
		}
		if (pFunctionInstance == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseFunctionInstance(nullptr);
		IModel* pIModel = dynamic_cast<IModel*>(pIBaseClass);
		if (!pIModel)
			throw ELib3MFInterfaceException(LIB3MF_ERROR_INVALIDCAST);
		
		pBaseFunctionInstance = pIModel->AddFunction();

		*pFunctionInstance = (IBase*)(pBaseFunctionInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("FunctionInstance", *pFunctionInstance);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

Lib3MFResult Lib3MF::Impl::Lib3MF_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIB3MF_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIB3MF_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "lib3mf_base_classtypeid") 
		*ppProcAddress = (void*) &lib3mf_base_classtypeid;
	if (sProcName == "lib3mf_writer_writetofile") 
		*ppProcAddress = (void*) &lib3mf_writer_writetofile;
	if (sProcName == "lib3mf_writer_getstreamsize") 
		*ppProcAddress = (void*) &lib3mf_writer_getstreamsize;
	if (sProcName == "lib3mf_writer_writetobuffer") 
		*ppProcAddress = (void*) &lib3mf_writer_writetobuffer;
	if (sProcName == "lib3mf_writer_writetocallback") 
		*ppProcAddress = (void*) &lib3mf_writer_writetocallback;
	if (sProcName == "lib3mf_writer_setprogresscallback") 
		*ppProcAddress = (void*) &lib3mf_writer_setprogresscallback;
	if (sProcName == "lib3mf_writer_getdecimalprecision") 
		*ppProcAddress = (void*) &lib3mf_writer_getdecimalprecision;
	if (sProcName == "lib3mf_writer_setdecimalprecision") 
		*ppProcAddress = (void*) &lib3mf_writer_setdecimalprecision;
	if (sProcName == "lib3mf_writer_setstrictmodeactive") 
		*ppProcAddress = (void*) &lib3mf_writer_setstrictmodeactive;
	if (sProcName == "lib3mf_writer_getstrictmodeactive") 
		*ppProcAddress = (void*) &lib3mf_writer_getstrictmodeactive;
	if (sProcName == "lib3mf_writer_getwarning") 
		*ppProcAddress = (void*) &lib3mf_writer_getwarning;
	if (sProcName == "lib3mf_writer_getwarningcount") 
		*ppProcAddress = (void*) &lib3mf_writer_getwarningcount;
	if (sProcName == "lib3mf_writer_addkeywrappingcallback") 
		*ppProcAddress = (void*) &lib3mf_writer_addkeywrappingcallback;
	if (sProcName == "lib3mf_writer_setcontentencryptioncallback") 
		*ppProcAddress = (void*) &lib3mf_writer_setcontentencryptioncallback;
	if (sProcName == "lib3mf_reader_readfromfile") 
		*ppProcAddress = (void*) &lib3mf_reader_readfromfile;
	if (sProcName == "lib3mf_reader_readfrombuffer") 
		*ppProcAddress = (void*) &lib3mf_reader_readfrombuffer;
	if (sProcName == "lib3mf_reader_readfromcallback") 
		*ppProcAddress = (void*) &lib3mf_reader_readfromcallback;
	if (sProcName == "lib3mf_reader_setprogresscallback") 
		*ppProcAddress = (void*) &lib3mf_reader_setprogresscallback;
	if (sProcName == "lib3mf_reader_addrelationtoread") 
		*ppProcAddress = (void*) &lib3mf_reader_addrelationtoread;
	if (sProcName == "lib3mf_reader_removerelationtoread") 
		*ppProcAddress = (void*) &lib3mf_reader_removerelationtoread;
	if (sProcName == "lib3mf_reader_setstrictmodeactive") 
		*ppProcAddress = (void*) &lib3mf_reader_setstrictmodeactive;
	if (sProcName == "lib3mf_reader_getstrictmodeactive") 
		*ppProcAddress = (void*) &lib3mf_reader_getstrictmodeactive;
	if (sProcName == "lib3mf_reader_getwarning") 
		*ppProcAddress = (void*) &lib3mf_reader_getwarning;
	if (sProcName == "lib3mf_reader_getwarningcount") 
		*ppProcAddress = (void*) &lib3mf_reader_getwarningcount;
	if (sProcName == "lib3mf_reader_addkeywrappingcallback") 
		*ppProcAddress = (void*) &lib3mf_reader_addkeywrappingcallback;
	if (sProcName == "lib3mf_reader_setcontentencryptioncallback") 
		*ppProcAddress = (void*) &lib3mf_reader_setcontentencryptioncallback;
	if (sProcName == "lib3mf_packagepart_getpath") 
		*ppProcAddress = (void*) &lib3mf_packagepart_getpath;
	if (sProcName == "lib3mf_packagepart_setpath") 
		*ppProcAddress = (void*) &lib3mf_packagepart_setpath;
	if (sProcName == "lib3mf_resource_getresourceid") 
		*ppProcAddress = (void*) &lib3mf_resource_getresourceid;
	if (sProcName == "lib3mf_resource_getuniqueresourceid") 
		*ppProcAddress = (void*) &lib3mf_resource_getuniqueresourceid;
	if (sProcName == "lib3mf_resource_packagepart") 
		*ppProcAddress = (void*) &lib3mf_resource_packagepart;
	if (sProcName == "lib3mf_resource_setpackagepart") 
		*ppProcAddress = (void*) &lib3mf_resource_setpackagepart;
	if (sProcName == "lib3mf_resource_getmodelresourceid") 
		*ppProcAddress = (void*) &lib3mf_resource_getmodelresourceid;
	if (sProcName == "lib3mf_resourceiterator_movenext") 
		*ppProcAddress = (void*) &lib3mf_resourceiterator_movenext;
	if (sProcName == "lib3mf_resourceiterator_moveprevious") 
		*ppProcAddress = (void*) &lib3mf_resourceiterator_moveprevious;
	if (sProcName == "lib3mf_resourceiterator_getcurrent") 
		*ppProcAddress = (void*) &lib3mf_resourceiterator_getcurrent;
	if (sProcName == "lib3mf_resourceiterator_clone") 
		*ppProcAddress = (void*) &lib3mf_resourceiterator_clone;
	if (sProcName == "lib3mf_resourceiterator_count") 
		*ppProcAddress = (void*) &lib3mf_resourceiterator_count;
	if (sProcName == "lib3mf_slicestackiterator_getcurrentslicestack") 
		*ppProcAddress = (void*) &lib3mf_slicestackiterator_getcurrentslicestack;
	if (sProcName == "lib3mf_objectiterator_getcurrentobject") 
		*ppProcAddress = (void*) &lib3mf_objectiterator_getcurrentobject;
	if (sProcName == "lib3mf_meshobjectiterator_getcurrentmeshobject") 
		*ppProcAddress = (void*) &lib3mf_meshobjectiterator_getcurrentmeshobject;
	if (sProcName == "lib3mf_componentsobjectiterator_getcurrentcomponentsobject") 
		*ppProcAddress = (void*) &lib3mf_componentsobjectiterator_getcurrentcomponentsobject;
	if (sProcName == "lib3mf_texture2diterator_getcurrenttexture2d") 
		*ppProcAddress = (void*) &lib3mf_texture2diterator_getcurrenttexture2d;
	if (sProcName == "lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup;
	if (sProcName == "lib3mf_colorgroupiterator_getcurrentcolorgroup") 
		*ppProcAddress = (void*) &lib3mf_colorgroupiterator_getcurrentcolorgroup;
	if (sProcName == "lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup;
	if (sProcName == "lib3mf_compositematerialsiterator_getcurrentcompositematerials") 
		*ppProcAddress = (void*) &lib3mf_compositematerialsiterator_getcurrentcompositematerials;
	if (sProcName == "lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup;
	if (sProcName == "lib3mf_image3diterator_getcurrentimage3d") 
		*ppProcAddress = (void*) &lib3mf_image3diterator_getcurrentimage3d;
	if (sProcName == "lib3mf_scalarfielditerator_getcurrentscalarfield") 
		*ppProcAddress = (void*) &lib3mf_scalarfielditerator_getcurrentscalarfield;
	if (sProcName == "lib3mf_functioniterator_getcurrentfunction") 
		*ppProcAddress = (void*) &lib3mf_functioniterator_getcurrentfunction;
	if (sProcName == "lib3mf_vector3dfielditerator_getcurrentvector3dfield") 
		*ppProcAddress = (void*) &lib3mf_vector3dfielditerator_getcurrentvector3dfield;
	if (sProcName == "lib3mf_metadata_getnamespace") 
		*ppProcAddress = (void*) &lib3mf_metadata_getnamespace;
	if (sProcName == "lib3mf_metadata_setnamespace") 
		*ppProcAddress = (void*) &lib3mf_metadata_setnamespace;
	if (sProcName == "lib3mf_metadata_getname") 
		*ppProcAddress = (void*) &lib3mf_metadata_getname;
	if (sProcName == "lib3mf_metadata_setname") 
		*ppProcAddress = (void*) &lib3mf_metadata_setname;
	if (sProcName == "lib3mf_metadata_getkey") 
		*ppProcAddress = (void*) &lib3mf_metadata_getkey;
	if (sProcName == "lib3mf_metadata_getmustpreserve") 
		*ppProcAddress = (void*) &lib3mf_metadata_getmustpreserve;
	if (sProcName == "lib3mf_metadata_setmustpreserve") 
		*ppProcAddress = (void*) &lib3mf_metadata_setmustpreserve;
	if (sProcName == "lib3mf_metadata_gettype") 
		*ppProcAddress = (void*) &lib3mf_metadata_gettype;
	if (sProcName == "lib3mf_metadata_settype") 
		*ppProcAddress = (void*) &lib3mf_metadata_settype;
	if (sProcName == "lib3mf_metadata_getvalue") 
		*ppProcAddress = (void*) &lib3mf_metadata_getvalue;
	if (sProcName == "lib3mf_metadata_setvalue") 
		*ppProcAddress = (void*) &lib3mf_metadata_setvalue;
	if (sProcName == "lib3mf_metadatagroup_getmetadatacount") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_getmetadatacount;
	if (sProcName == "lib3mf_metadatagroup_getmetadata") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_getmetadata;
	if (sProcName == "lib3mf_metadatagroup_getmetadatabykey") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_getmetadatabykey;
	if (sProcName == "lib3mf_metadatagroup_removemetadatabyindex") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_removemetadatabyindex;
	if (sProcName == "lib3mf_metadatagroup_removemetadata") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_removemetadata;
	if (sProcName == "lib3mf_metadatagroup_addmetadata") 
		*ppProcAddress = (void*) &lib3mf_metadatagroup_addmetadata;
	if (sProcName == "lib3mf_object_gettype") 
		*ppProcAddress = (void*) &lib3mf_object_gettype;
	if (sProcName == "lib3mf_object_settype") 
		*ppProcAddress = (void*) &lib3mf_object_settype;
	if (sProcName == "lib3mf_object_getname") 
		*ppProcAddress = (void*) &lib3mf_object_getname;
	if (sProcName == "lib3mf_object_setname") 
		*ppProcAddress = (void*) &lib3mf_object_setname;
	if (sProcName == "lib3mf_object_getpartnumber") 
		*ppProcAddress = (void*) &lib3mf_object_getpartnumber;
	if (sProcName == "lib3mf_object_setpartnumber") 
		*ppProcAddress = (void*) &lib3mf_object_setpartnumber;
	if (sProcName == "lib3mf_object_ismeshobject") 
		*ppProcAddress = (void*) &lib3mf_object_ismeshobject;
	if (sProcName == "lib3mf_object_iscomponentsobject") 
		*ppProcAddress = (void*) &lib3mf_object_iscomponentsobject;
	if (sProcName == "lib3mf_object_isvalid") 
		*ppProcAddress = (void*) &lib3mf_object_isvalid;
	if (sProcName == "lib3mf_object_setattachmentasthumbnail") 
		*ppProcAddress = (void*) &lib3mf_object_setattachmentasthumbnail;
	if (sProcName == "lib3mf_object_getthumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_object_getthumbnailattachment;
	if (sProcName == "lib3mf_object_clearthumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_object_clearthumbnailattachment;
	if (sProcName == "lib3mf_object_getoutbox") 
		*ppProcAddress = (void*) &lib3mf_object_getoutbox;
	if (sProcName == "lib3mf_object_getuuid") 
		*ppProcAddress = (void*) &lib3mf_object_getuuid;
	if (sProcName == "lib3mf_object_setuuid") 
		*ppProcAddress = (void*) &lib3mf_object_setuuid;
	if (sProcName == "lib3mf_object_getmetadatagroup") 
		*ppProcAddress = (void*) &lib3mf_object_getmetadatagroup;
	if (sProcName == "lib3mf_object_setslicesmeshresolution") 
		*ppProcAddress = (void*) &lib3mf_object_setslicesmeshresolution;
	if (sProcName == "lib3mf_object_getslicesmeshresolution") 
		*ppProcAddress = (void*) &lib3mf_object_getslicesmeshresolution;
	if (sProcName == "lib3mf_object_hasslices") 
		*ppProcAddress = (void*) &lib3mf_object_hasslices;
	if (sProcName == "lib3mf_object_clearslicestack") 
		*ppProcAddress = (void*) &lib3mf_object_clearslicestack;
	if (sProcName == "lib3mf_object_getslicestack") 
		*ppProcAddress = (void*) &lib3mf_object_getslicestack;
	if (sProcName == "lib3mf_object_assignslicestack") 
		*ppProcAddress = (void*) &lib3mf_object_assignslicestack;
	if (sProcName == "lib3mf_meshobject_getvertexcount") 
		*ppProcAddress = (void*) &lib3mf_meshobject_getvertexcount;
	if (sProcName == "lib3mf_meshobject_gettrianglecount") 
		*ppProcAddress = (void*) &lib3mf_meshobject_gettrianglecount;
	if (sProcName == "lib3mf_meshobject_getvertex") 
		*ppProcAddress = (void*) &lib3mf_meshobject_getvertex;
	if (sProcName == "lib3mf_meshobject_setvertex") 
		*ppProcAddress = (void*) &lib3mf_meshobject_setvertex;
	if (sProcName == "lib3mf_meshobject_addvertex") 
		*ppProcAddress = (void*) &lib3mf_meshobject_addvertex;
	if (sProcName == "lib3mf_meshobject_getvertices") 
		*ppProcAddress = (void*) &lib3mf_meshobject_getvertices;
	if (sProcName == "lib3mf_meshobject_gettriangle") 
		*ppProcAddress = (void*) &lib3mf_meshobject_gettriangle;
	if (sProcName == "lib3mf_meshobject_settriangle") 
		*ppProcAddress = (void*) &lib3mf_meshobject_settriangle;
	if (sProcName == "lib3mf_meshobject_addtriangle") 
		*ppProcAddress = (void*) &lib3mf_meshobject_addtriangle;
	if (sProcName == "lib3mf_meshobject_gettriangleindices") 
		*ppProcAddress = (void*) &lib3mf_meshobject_gettriangleindices;
	if (sProcName == "lib3mf_meshobject_setobjectlevelproperty") 
		*ppProcAddress = (void*) &lib3mf_meshobject_setobjectlevelproperty;
	if (sProcName == "lib3mf_meshobject_getobjectlevelproperty") 
		*ppProcAddress = (void*) &lib3mf_meshobject_getobjectlevelproperty;
	if (sProcName == "lib3mf_meshobject_settriangleproperties") 
		*ppProcAddress = (void*) &lib3mf_meshobject_settriangleproperties;
	if (sProcName == "lib3mf_meshobject_gettriangleproperties") 
		*ppProcAddress = (void*) &lib3mf_meshobject_gettriangleproperties;
	if (sProcName == "lib3mf_meshobject_setalltriangleproperties") 
		*ppProcAddress = (void*) &lib3mf_meshobject_setalltriangleproperties;
	if (sProcName == "lib3mf_meshobject_getalltriangleproperties") 
		*ppProcAddress = (void*) &lib3mf_meshobject_getalltriangleproperties;
	if (sProcName == "lib3mf_meshobject_clearallproperties") 
		*ppProcAddress = (void*) &lib3mf_meshobject_clearallproperties;
	if (sProcName == "lib3mf_meshobject_setgeometry") 
		*ppProcAddress = (void*) &lib3mf_meshobject_setgeometry;
	if (sProcName == "lib3mf_meshobject_ismanifoldandoriented") 
		*ppProcAddress = (void*) &lib3mf_meshobject_ismanifoldandoriented;
	if (sProcName == "lib3mf_meshobject_beamlattice") 
		*ppProcAddress = (void*) &lib3mf_meshobject_beamlattice;
	if (sProcName == "lib3mf_meshobject_volumedata") 
		*ppProcAddress = (void*) &lib3mf_meshobject_volumedata;
	if (sProcName == "lib3mf_beamlattice_getminlength") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getminlength;
	if (sProcName == "lib3mf_beamlattice_setminlength") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setminlength;
	if (sProcName == "lib3mf_beamlattice_getclipping") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getclipping;
	if (sProcName == "lib3mf_beamlattice_setclipping") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setclipping;
	if (sProcName == "lib3mf_beamlattice_getrepresentation") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getrepresentation;
	if (sProcName == "lib3mf_beamlattice_setrepresentation") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setrepresentation;
	if (sProcName == "lib3mf_beamlattice_getballoptions") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getballoptions;
	if (sProcName == "lib3mf_beamlattice_setballoptions") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setballoptions;
	if (sProcName == "lib3mf_beamlattice_getbeamcount") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getbeamcount;
	if (sProcName == "lib3mf_beamlattice_getbeam") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getbeam;
	if (sProcName == "lib3mf_beamlattice_addbeam") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_addbeam;
	if (sProcName == "lib3mf_beamlattice_setbeam") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setbeam;
	if (sProcName == "lib3mf_beamlattice_setbeams") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setbeams;
	if (sProcName == "lib3mf_beamlattice_getbeams") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getbeams;
	if (sProcName == "lib3mf_beamlattice_getballcount") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getballcount;
	if (sProcName == "lib3mf_beamlattice_getball") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getball;
	if (sProcName == "lib3mf_beamlattice_addball") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_addball;
	if (sProcName == "lib3mf_beamlattice_setball") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setball;
	if (sProcName == "lib3mf_beamlattice_setballs") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_setballs;
	if (sProcName == "lib3mf_beamlattice_getballs") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getballs;
	if (sProcName == "lib3mf_beamlattice_getbeamsetcount") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getbeamsetcount;
	if (sProcName == "lib3mf_beamlattice_addbeamset") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_addbeamset;
	if (sProcName == "lib3mf_beamlattice_getbeamset") 
		*ppProcAddress = (void*) &lib3mf_beamlattice_getbeamset;
	if (sProcName == "lib3mf_scalarfield_getname") 
		*ppProcAddress = (void*) &lib3mf_scalarfield_getname;
	if (sProcName == "lib3mf_scalarfield_setname") 
		*ppProcAddress = (void*) &lib3mf_scalarfield_setname;
	if (sProcName == "lib3mf_scalarfield_isfromimage3d") 
		*ppProcAddress = (void*) &lib3mf_scalarfield_isfromimage3d;
	if (sProcName == "lib3mf_scalarfield_isconstant") 
		*ppProcAddress = (void*) &lib3mf_scalarfield_isconstant;
	if (sProcName == "lib3mf_scalarfield_iscomposed") 
		*ppProcAddress = (void*) &lib3mf_scalarfield_iscomposed;
	if (sProcName == "lib3mf_vector3dfield_getname") 
		*ppProcAddress = (void*) &lib3mf_vector3dfield_getname;
	if (sProcName == "lib3mf_vector3dfield_setname") 
		*ppProcAddress = (void*) &lib3mf_vector3dfield_setname;
	if (sProcName == "lib3mf_vector3dfield_isfromimage3d") 
		*ppProcAddress = (void*) &lib3mf_vector3dfield_isfromimage3d;
	if (sProcName == "lib3mf_vector3dfield_isconstant") 
		*ppProcAddress = (void*) &lib3mf_vector3dfield_isconstant;
	if (sProcName == "lib3mf_vector3dfield_iscomposed") 
		*ppProcAddress = (void*) &lib3mf_vector3dfield_iscomposed;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_getimage") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_getimage;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_setimage") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_setimage;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_setchannel") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_setchannel;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_getchannel") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_getchannel;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_setfilter") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_setfilter;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_getfilter") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_getfilter;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_settilestyles") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_settilestyles;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_gettilestyles") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_gettilestyles;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_getoffset") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_getoffset;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_setoffset") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_setoffset;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_getscale") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_getscale;
	if (sProcName == "lib3mf_scalarfieldfromimage3d_setscale") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldfromimage3d_setscale;
	if (sProcName == "lib3mf_scalarfieldconstant_getvalue") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldconstant_getvalue;
	if (sProcName == "lib3mf_scalarfieldconstant_setvalue") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldconstant_setvalue;
	if (sProcName == "lib3mf_scalarfieldcomposed_setmethod") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_setmethod;
	if (sProcName == "lib3mf_scalarfieldcomposed_getmethod") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_getmethod;
	if (sProcName == "lib3mf_scalarfieldcomposed_getfactor1") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_getfactor1;
	if (sProcName == "lib3mf_scalarfieldcomposed_setfactor1") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_setfactor1;
	if (sProcName == "lib3mf_scalarfieldcomposed_getfactor2") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_getfactor2;
	if (sProcName == "lib3mf_scalarfieldcomposed_setfactor2") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_setfactor2;
	if (sProcName == "lib3mf_scalarfieldcomposed_scalarfieldreference1") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_scalarfieldreference1;
	if (sProcName == "lib3mf_scalarfieldcomposed_scalarfieldreference2") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_scalarfieldreference2;
	if (sProcName == "lib3mf_scalarfieldcomposed_scalarfieldreferencemask") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldcomposed_scalarfieldreferencemask;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_getimage") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_getimage;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_setimage") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_setimage;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_setfilter") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_setfilter;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_getfilter") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_getfilter;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_settilestyles") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_settilestyles;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_gettilestyles") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_gettilestyles;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_getoffset") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_getoffset;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_setoffset") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_setoffset;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_getscale") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_getscale;
	if (sProcName == "lib3mf_vector3dfieldfromimage3d_setscale") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldfromimage3d_setscale;
	if (sProcName == "lib3mf_vector3dfieldconstant_getvaluex") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_getvaluex;
	if (sProcName == "lib3mf_vector3dfieldconstant_setvaluex") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_setvaluex;
	if (sProcName == "lib3mf_vector3dfieldconstant_getvaluey") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_getvaluey;
	if (sProcName == "lib3mf_vector3dfieldconstant_setvaluey") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_setvaluey;
	if (sProcName == "lib3mf_vector3dfieldconstant_getvaluez") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_getvaluez;
	if (sProcName == "lib3mf_vector3dfieldconstant_setvaluez") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldconstant_setvaluez;
	if (sProcName == "lib3mf_vector3dfieldcomposed_setmethod") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_setmethod;
	if (sProcName == "lib3mf_vector3dfieldcomposed_getmethod") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_getmethod;
	if (sProcName == "lib3mf_vector3dfieldcomposed_setspace") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_setspace;
	if (sProcName == "lib3mf_vector3dfieldcomposed_getspace") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_getspace;
	if (sProcName == "lib3mf_vector3dfieldcomposed_getfactor1") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_getfactor1;
	if (sProcName == "lib3mf_vector3dfieldcomposed_setfactor1") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_setfactor1;
	if (sProcName == "lib3mf_vector3dfieldcomposed_getfactor2") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_getfactor2;
	if (sProcName == "lib3mf_vector3dfieldcomposed_setfactor2") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_setfactor2;
	if (sProcName == "lib3mf_vector3dfieldcomposed_vector3dfieldreference1") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_vector3dfieldreference1;
	if (sProcName == "lib3mf_vector3dfieldcomposed_vector3dfieldreference2") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_vector3dfieldreference2;
	if (sProcName == "lib3mf_vector3dfieldcomposed_scalarfieldreferencemask") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldcomposed_scalarfieldreferencemask;
	if (sProcName == "lib3mf_fieldreference_getfieldresourceid") 
		*ppProcAddress = (void*) &lib3mf_fieldreference_getfieldresourceid;
	if (sProcName == "lib3mf_fieldreference_setfieldresourceid") 
		*ppProcAddress = (void*) &lib3mf_fieldreference_setfieldresourceid;
	if (sProcName == "lib3mf_fieldreference_gettransform") 
		*ppProcAddress = (void*) &lib3mf_fieldreference_gettransform;
	if (sProcName == "lib3mf_fieldreference_settransform") 
		*ppProcAddress = (void*) &lib3mf_fieldreference_settransform;
	if (sProcName == "lib3mf_scalarfieldreference_setscalarfield") 
		*ppProcAddress = (void*) &lib3mf_scalarfieldreference_setscalarfield;
	if (sProcName == "lib3mf_vector3dfieldreference_setvector3dfield") 
		*ppProcAddress = (void*) &lib3mf_vector3dfieldreference_setvector3dfield;
	if (sProcName == "lib3mf_volumedataboundary_getsolidthreshold") 
		*ppProcAddress = (void*) &lib3mf_volumedataboundary_getsolidthreshold;
	if (sProcName == "lib3mf_volumedataboundary_setsolidthreshold") 
		*ppProcAddress = (void*) &lib3mf_volumedataboundary_setsolidthreshold;
	if (sProcName == "lib3mf_volumedatacomposite_getbasematerialgroup") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_getbasematerialgroup;
	if (sProcName == "lib3mf_volumedatacomposite_setbasematerialgroup") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_setbasematerialgroup;
	if (sProcName == "lib3mf_volumedatacomposite_getmaterialmappingcount") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_getmaterialmappingcount;
	if (sProcName == "lib3mf_volumedatacomposite_getmaterialmapping") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_getmaterialmapping;
	if (sProcName == "lib3mf_volumedatacomposite_addmaterialmapping") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_addmaterialmapping;
	if (sProcName == "lib3mf_volumedatacomposite_removematerialmapping") 
		*ppProcAddress = (void*) &lib3mf_volumedatacomposite_removematerialmapping;
	if (sProcName == "lib3mf_volumedataproperty_getname") 
		*ppProcAddress = (void*) &lib3mf_volumedataproperty_getname;
	if (sProcName == "lib3mf_volumedataproperty_setisrequired") 
		*ppProcAddress = (void*) &lib3mf_volumedataproperty_setisrequired;
	if (sProcName == "lib3mf_volumedataproperty_isrequired") 
		*ppProcAddress = (void*) &lib3mf_volumedataproperty_isrequired;
	if (sProcName == "lib3mf_volumedata_getboundary") 
		*ppProcAddress = (void*) &lib3mf_volumedata_getboundary;
	if (sProcName == "lib3mf_volumedata_createnewboundary") 
		*ppProcAddress = (void*) &lib3mf_volumedata_createnewboundary;
	if (sProcName == "lib3mf_volumedata_removeboundary") 
		*ppProcAddress = (void*) &lib3mf_volumedata_removeboundary;
	if (sProcName == "lib3mf_volumedata_getcomposite") 
		*ppProcAddress = (void*) &lib3mf_volumedata_getcomposite;
	if (sProcName == "lib3mf_volumedata_createnewcomposite") 
		*ppProcAddress = (void*) &lib3mf_volumedata_createnewcomposite;
	if (sProcName == "lib3mf_volumedata_removecomposite") 
		*ppProcAddress = (void*) &lib3mf_volumedata_removecomposite;
	if (sProcName == "lib3mf_volumedata_getcolor") 
		*ppProcAddress = (void*) &lib3mf_volumedata_getcolor;
	if (sProcName == "lib3mf_volumedata_createnewcolor") 
		*ppProcAddress = (void*) &lib3mf_volumedata_createnewcolor;
	if (sProcName == "lib3mf_volumedata_removecolor") 
		*ppProcAddress = (void*) &lib3mf_volumedata_removecolor;
	if (sProcName == "lib3mf_volumedata_getpropertycount") 
		*ppProcAddress = (void*) &lib3mf_volumedata_getpropertycount;
	if (sProcName == "lib3mf_volumedata_getproperty") 
		*ppProcAddress = (void*) &lib3mf_volumedata_getproperty;
	if (sProcName == "lib3mf_volumedata_addpropertyfromscalarfield") 
		*ppProcAddress = (void*) &lib3mf_volumedata_addpropertyfromscalarfield;
	if (sProcName == "lib3mf_volumedata_addpropertyfromvector3dfield") 
		*ppProcAddress = (void*) &lib3mf_volumedata_addpropertyfromvector3dfield;
	if (sProcName == "lib3mf_volumedata_removeproperty") 
		*ppProcAddress = (void*) &lib3mf_volumedata_removeproperty;
	if (sProcName == "lib3mf_component_getobjectresource") 
		*ppProcAddress = (void*) &lib3mf_component_getobjectresource;
	if (sProcName == "lib3mf_component_getobjectresourceid") 
		*ppProcAddress = (void*) &lib3mf_component_getobjectresourceid;
	if (sProcName == "lib3mf_component_getuuid") 
		*ppProcAddress = (void*) &lib3mf_component_getuuid;
	if (sProcName == "lib3mf_component_setuuid") 
		*ppProcAddress = (void*) &lib3mf_component_setuuid;
	if (sProcName == "lib3mf_component_hastransform") 
		*ppProcAddress = (void*) &lib3mf_component_hastransform;
	if (sProcName == "lib3mf_component_gettransform") 
		*ppProcAddress = (void*) &lib3mf_component_gettransform;
	if (sProcName == "lib3mf_component_settransform") 
		*ppProcAddress = (void*) &lib3mf_component_settransform;
	if (sProcName == "lib3mf_componentsobject_addcomponent") 
		*ppProcAddress = (void*) &lib3mf_componentsobject_addcomponent;
	if (sProcName == "lib3mf_componentsobject_getcomponent") 
		*ppProcAddress = (void*) &lib3mf_componentsobject_getcomponent;
	if (sProcName == "lib3mf_componentsobject_getcomponentcount") 
		*ppProcAddress = (void*) &lib3mf_componentsobject_getcomponentcount;
	if (sProcName == "lib3mf_beamset_setname") 
		*ppProcAddress = (void*) &lib3mf_beamset_setname;
	if (sProcName == "lib3mf_beamset_getname") 
		*ppProcAddress = (void*) &lib3mf_beamset_getname;
	if (sProcName == "lib3mf_beamset_setidentifier") 
		*ppProcAddress = (void*) &lib3mf_beamset_setidentifier;
	if (sProcName == "lib3mf_beamset_getidentifier") 
		*ppProcAddress = (void*) &lib3mf_beamset_getidentifier;
	if (sProcName == "lib3mf_beamset_getreferencecount") 
		*ppProcAddress = (void*) &lib3mf_beamset_getreferencecount;
	if (sProcName == "lib3mf_beamset_setreferences") 
		*ppProcAddress = (void*) &lib3mf_beamset_setreferences;
	if (sProcName == "lib3mf_beamset_getreferences") 
		*ppProcAddress = (void*) &lib3mf_beamset_getreferences;
	if (sProcName == "lib3mf_beamset_getballreferencecount") 
		*ppProcAddress = (void*) &lib3mf_beamset_getballreferencecount;
	if (sProcName == "lib3mf_beamset_setballreferences") 
		*ppProcAddress = (void*) &lib3mf_beamset_setballreferences;
	if (sProcName == "lib3mf_beamset_getballreferences") 
		*ppProcAddress = (void*) &lib3mf_beamset_getballreferences;
	if (sProcName == "lib3mf_basematerialgroup_getcount") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_getcount;
	if (sProcName == "lib3mf_basematerialgroup_getallpropertyids") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_getallpropertyids;
	if (sProcName == "lib3mf_basematerialgroup_addmaterial") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_addmaterial;
	if (sProcName == "lib3mf_basematerialgroup_removematerial") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_removematerial;
	if (sProcName == "lib3mf_basematerialgroup_getname") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_getname;
	if (sProcName == "lib3mf_basematerialgroup_setname") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_setname;
	if (sProcName == "lib3mf_basematerialgroup_setdisplaycolor") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_setdisplaycolor;
	if (sProcName == "lib3mf_basematerialgroup_getdisplaycolor") 
		*ppProcAddress = (void*) &lib3mf_basematerialgroup_getdisplaycolor;
	if (sProcName == "lib3mf_colorgroup_getcount") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_getcount;
	if (sProcName == "lib3mf_colorgroup_getallpropertyids") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_getallpropertyids;
	if (sProcName == "lib3mf_colorgroup_addcolor") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_addcolor;
	if (sProcName == "lib3mf_colorgroup_removecolor") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_removecolor;
	if (sProcName == "lib3mf_colorgroup_setcolor") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_setcolor;
	if (sProcName == "lib3mf_colorgroup_getcolor") 
		*ppProcAddress = (void*) &lib3mf_colorgroup_getcolor;
	if (sProcName == "lib3mf_texture2dgroup_getcount") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_getcount;
	if (sProcName == "lib3mf_texture2dgroup_getallpropertyids") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_getallpropertyids;
	if (sProcName == "lib3mf_texture2dgroup_addtex2coord") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_addtex2coord;
	if (sProcName == "lib3mf_texture2dgroup_gettex2coord") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_gettex2coord;
	if (sProcName == "lib3mf_texture2dgroup_removetex2coord") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_removetex2coord;
	if (sProcName == "lib3mf_texture2dgroup_gettexture2d") 
		*ppProcAddress = (void*) &lib3mf_texture2dgroup_gettexture2d;
	if (sProcName == "lib3mf_compositematerials_getcount") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_getcount;
	if (sProcName == "lib3mf_compositematerials_getallpropertyids") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_getallpropertyids;
	if (sProcName == "lib3mf_compositematerials_getbasematerialgroup") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_getbasematerialgroup;
	if (sProcName == "lib3mf_compositematerials_addcomposite") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_addcomposite;
	if (sProcName == "lib3mf_compositematerials_removecomposite") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_removecomposite;
	if (sProcName == "lib3mf_compositematerials_getcomposite") 
		*ppProcAddress = (void*) &lib3mf_compositematerials_getcomposite;
	if (sProcName == "lib3mf_multipropertygroup_getcount") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_getcount;
	if (sProcName == "lib3mf_multipropertygroup_getallpropertyids") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_getallpropertyids;
	if (sProcName == "lib3mf_multipropertygroup_addmultiproperty") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_addmultiproperty;
	if (sProcName == "lib3mf_multipropertygroup_setmultiproperty") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_setmultiproperty;
	if (sProcName == "lib3mf_multipropertygroup_getmultiproperty") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_getmultiproperty;
	if (sProcName == "lib3mf_multipropertygroup_removemultiproperty") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_removemultiproperty;
	if (sProcName == "lib3mf_multipropertygroup_getlayercount") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_getlayercount;
	if (sProcName == "lib3mf_multipropertygroup_addlayer") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_addlayer;
	if (sProcName == "lib3mf_multipropertygroup_getlayer") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_getlayer;
	if (sProcName == "lib3mf_multipropertygroup_removelayer") 
		*ppProcAddress = (void*) &lib3mf_multipropertygroup_removelayer;
	if (sProcName == "lib3mf_image3d_getname") 
		*ppProcAddress = (void*) &lib3mf_image3d_getname;
	if (sProcName == "lib3mf_image3d_setname") 
		*ppProcAddress = (void*) &lib3mf_image3d_setname;
	if (sProcName == "lib3mf_image3d_isimagestack") 
		*ppProcAddress = (void*) &lib3mf_image3d_isimagestack;
	if (sProcName == "lib3mf_imagestack_getrowcount") 
		*ppProcAddress = (void*) &lib3mf_imagestack_getrowcount;
	if (sProcName == "lib3mf_imagestack_setrowcount") 
		*ppProcAddress = (void*) &lib3mf_imagestack_setrowcount;
	if (sProcName == "lib3mf_imagestack_getcolumncount") 
		*ppProcAddress = (void*) &lib3mf_imagestack_getcolumncount;
	if (sProcName == "lib3mf_imagestack_setcolumncount") 
		*ppProcAddress = (void*) &lib3mf_imagestack_setcolumncount;
	if (sProcName == "lib3mf_imagestack_getsheetcount") 
		*ppProcAddress = (void*) &lib3mf_imagestack_getsheetcount;
	if (sProcName == "lib3mf_imagestack_getsheet") 
		*ppProcAddress = (void*) &lib3mf_imagestack_getsheet;
	if (sProcName == "lib3mf_imagestack_setsheet") 
		*ppProcAddress = (void*) &lib3mf_imagestack_setsheet;
	if (sProcName == "lib3mf_imagestack_createemptysheet") 
		*ppProcAddress = (void*) &lib3mf_imagestack_createemptysheet;
	if (sProcName == "lib3mf_imagestack_createsheetfrombuffer") 
		*ppProcAddress = (void*) &lib3mf_imagestack_createsheetfrombuffer;
	if (sProcName == "lib3mf_imagestack_createsheetfromfile") 
		*ppProcAddress = (void*) &lib3mf_imagestack_createsheetfromfile;
	if (sProcName == "lib3mf_attachment_getpath") 
		*ppProcAddress = (void*) &lib3mf_attachment_getpath;
	if (sProcName == "lib3mf_attachment_setpath") 
		*ppProcAddress = (void*) &lib3mf_attachment_setpath;
	if (sProcName == "lib3mf_attachment_packagepart") 
		*ppProcAddress = (void*) &lib3mf_attachment_packagepart;
	if (sProcName == "lib3mf_attachment_getrelationshiptype") 
		*ppProcAddress = (void*) &lib3mf_attachment_getrelationshiptype;
	if (sProcName == "lib3mf_attachment_setrelationshiptype") 
		*ppProcAddress = (void*) &lib3mf_attachment_setrelationshiptype;
	if (sProcName == "lib3mf_attachment_writetofile") 
		*ppProcAddress = (void*) &lib3mf_attachment_writetofile;
	if (sProcName == "lib3mf_attachment_readfromfile") 
		*ppProcAddress = (void*) &lib3mf_attachment_readfromfile;
	if (sProcName == "lib3mf_attachment_readfromcallback") 
		*ppProcAddress = (void*) &lib3mf_attachment_readfromcallback;
	if (sProcName == "lib3mf_attachment_getstreamsize") 
		*ppProcAddress = (void*) &lib3mf_attachment_getstreamsize;
	if (sProcName == "lib3mf_attachment_writetobuffer") 
		*ppProcAddress = (void*) &lib3mf_attachment_writetobuffer;
	if (sProcName == "lib3mf_attachment_readfrombuffer") 
		*ppProcAddress = (void*) &lib3mf_attachment_readfrombuffer;
	if (sProcName == "lib3mf_texture2d_getattachment") 
		*ppProcAddress = (void*) &lib3mf_texture2d_getattachment;
	if (sProcName == "lib3mf_texture2d_setattachment") 
		*ppProcAddress = (void*) &lib3mf_texture2d_setattachment;
	if (sProcName == "lib3mf_texture2d_getcontenttype") 
		*ppProcAddress = (void*) &lib3mf_texture2d_getcontenttype;
	if (sProcName == "lib3mf_texture2d_setcontenttype") 
		*ppProcAddress = (void*) &lib3mf_texture2d_setcontenttype;
	if (sProcName == "lib3mf_texture2d_gettilestyleuv") 
		*ppProcAddress = (void*) &lib3mf_texture2d_gettilestyleuv;
	if (sProcName == "lib3mf_texture2d_settilestyleuv") 
		*ppProcAddress = (void*) &lib3mf_texture2d_settilestyleuv;
	if (sProcName == "lib3mf_texture2d_getfilter") 
		*ppProcAddress = (void*) &lib3mf_texture2d_getfilter;
	if (sProcName == "lib3mf_texture2d_setfilter") 
		*ppProcAddress = (void*) &lib3mf_texture2d_setfilter;
	if (sProcName == "lib3mf_implicitport_getidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitport_getidentifier;
	if (sProcName == "lib3mf_implicitport_setidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitport_setidentifier;
	if (sProcName == "lib3mf_implicitport_getdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitport_getdisplayname;
	if (sProcName == "lib3mf_implicitport_setdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitport_setdisplayname;
	if (sProcName == "lib3mf_implicitport_settype") 
		*ppProcAddress = (void*) &lib3mf_implicitport_settype;
	if (sProcName == "lib3mf_implicitport_gettype") 
		*ppProcAddress = (void*) &lib3mf_implicitport_gettype;
	if (sProcName == "lib3mf_implicitport_getreference") 
		*ppProcAddress = (void*) &lib3mf_implicitport_getreference;
	if (sProcName == "lib3mf_implicitport_setreference") 
		*ppProcAddress = (void*) &lib3mf_implicitport_setreference;
	if (sProcName == "lib3mf_iterator_movenext") 
		*ppProcAddress = (void*) &lib3mf_iterator_movenext;
	if (sProcName == "lib3mf_iterator_moveprevious") 
		*ppProcAddress = (void*) &lib3mf_iterator_moveprevious;
	if (sProcName == "lib3mf_iterator_count") 
		*ppProcAddress = (void*) &lib3mf_iterator_count;
	if (sProcName == "lib3mf_implicitportiterator_getcurrent") 
		*ppProcAddress = (void*) &lib3mf_implicitportiterator_getcurrent;
	if (sProcName == "lib3mf_implicitnode_getidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getidentifier;
	if (sProcName == "lib3mf_implicitnode_setidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_setidentifier;
	if (sProcName == "lib3mf_implicitnode_getdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getdisplayname;
	if (sProcName == "lib3mf_implicitnode_setdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_setdisplayname;
	if (sProcName == "lib3mf_implicitnode_getnodetype") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getnodetype;
	if (sProcName == "lib3mf_implicitnode_addinput") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_addinput;
	if (sProcName == "lib3mf_implicitnode_getinputs") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getinputs;
	if (sProcName == "lib3mf_implicitnode_addoutput") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_addoutput;
	if (sProcName == "lib3mf_implicitnode_getoutputs") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getoutputs;
	if (sProcName == "lib3mf_implicitnode_findinput") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_findinput;
	if (sProcName == "lib3mf_implicitnode_findoutput") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_findoutput;
	if (sProcName == "lib3mf_implicitnode_setconstant") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_setconstant;
	if (sProcName == "lib3mf_implicitnode_getconstant") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getconstant;
	if (sProcName == "lib3mf_implicitnode_setvector") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_setvector;
	if (sProcName == "lib3mf_implicitnode_getvector") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getvector;
	if (sProcName == "lib3mf_implicitnode_setmatrix") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_setmatrix;
	if (sProcName == "lib3mf_implicitnode_getmatrix") 
		*ppProcAddress = (void*) &lib3mf_implicitnode_getmatrix;
	if (sProcName == "lib3mf_nodeiterator_getcurrent") 
		*ppProcAddress = (void*) &lib3mf_nodeiterator_getcurrent;
	if (sProcName == "lib3mf_implicitfunction_getidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_getidentifier;
	if (sProcName == "lib3mf_implicitfunction_setidentifier") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_setidentifier;
	if (sProcName == "lib3mf_implicitfunction_getdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_getdisplayname;
	if (sProcName == "lib3mf_implicitfunction_setdisplayname") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_setdisplayname;
	if (sProcName == "lib3mf_implicitfunction_addnode") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_addnode;
	if (sProcName == "lib3mf_implicitfunction_getnodes") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_getnodes;
	if (sProcName == "lib3mf_implicitfunction_removenode") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_removenode;
	if (sProcName == "lib3mf_implicitfunction_addinput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_addinput;
	if (sProcName == "lib3mf_implicitfunction_getinputs") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_getinputs;
	if (sProcName == "lib3mf_implicitfunction_removeinput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_removeinput;
	if (sProcName == "lib3mf_implicitfunction_addoutput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_addoutput;
	if (sProcName == "lib3mf_implicitfunction_getoutputs") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_getoutputs;
	if (sProcName == "lib3mf_implicitfunction_removeoutput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_removeoutput;
	if (sProcName == "lib3mf_implicitfunction_addlink") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_addlink;
	if (sProcName == "lib3mf_implicitfunction_findinput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_findinput;
	if (sProcName == "lib3mf_implicitfunction_findoutput") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_findoutput;
	if (sProcName == "lib3mf_implicitfunction_addlinkbynames") 
		*ppProcAddress = (void*) &lib3mf_implicitfunction_addlinkbynames;
	if (sProcName == "lib3mf_builditem_getobjectresource") 
		*ppProcAddress = (void*) &lib3mf_builditem_getobjectresource;
	if (sProcName == "lib3mf_builditem_getuuid") 
		*ppProcAddress = (void*) &lib3mf_builditem_getuuid;
	if (sProcName == "lib3mf_builditem_setuuid") 
		*ppProcAddress = (void*) &lib3mf_builditem_setuuid;
	if (sProcName == "lib3mf_builditem_getobjectresourceid") 
		*ppProcAddress = (void*) &lib3mf_builditem_getobjectresourceid;
	if (sProcName == "lib3mf_builditem_hasobjecttransform") 
		*ppProcAddress = (void*) &lib3mf_builditem_hasobjecttransform;
	if (sProcName == "lib3mf_builditem_getobjecttransform") 
		*ppProcAddress = (void*) &lib3mf_builditem_getobjecttransform;
	if (sProcName == "lib3mf_builditem_setobjecttransform") 
		*ppProcAddress = (void*) &lib3mf_builditem_setobjecttransform;
	if (sProcName == "lib3mf_builditem_getpartnumber") 
		*ppProcAddress = (void*) &lib3mf_builditem_getpartnumber;
	if (sProcName == "lib3mf_builditem_setpartnumber") 
		*ppProcAddress = (void*) &lib3mf_builditem_setpartnumber;
	if (sProcName == "lib3mf_builditem_getmetadatagroup") 
		*ppProcAddress = (void*) &lib3mf_builditem_getmetadatagroup;
	if (sProcName == "lib3mf_builditem_getoutbox") 
		*ppProcAddress = (void*) &lib3mf_builditem_getoutbox;
	if (sProcName == "lib3mf_builditemiterator_movenext") 
		*ppProcAddress = (void*) &lib3mf_builditemiterator_movenext;
	if (sProcName == "lib3mf_builditemiterator_moveprevious") 
		*ppProcAddress = (void*) &lib3mf_builditemiterator_moveprevious;
	if (sProcName == "lib3mf_builditemiterator_getcurrent") 
		*ppProcAddress = (void*) &lib3mf_builditemiterator_getcurrent;
	if (sProcName == "lib3mf_builditemiterator_clone") 
		*ppProcAddress = (void*) &lib3mf_builditemiterator_clone;
	if (sProcName == "lib3mf_builditemiterator_count") 
		*ppProcAddress = (void*) &lib3mf_builditemiterator_count;
	if (sProcName == "lib3mf_slice_setvertices") 
		*ppProcAddress = (void*) &lib3mf_slice_setvertices;
	if (sProcName == "lib3mf_slice_getvertices") 
		*ppProcAddress = (void*) &lib3mf_slice_getvertices;
	if (sProcName == "lib3mf_slice_getvertexcount") 
		*ppProcAddress = (void*) &lib3mf_slice_getvertexcount;
	if (sProcName == "lib3mf_slice_addpolygon") 
		*ppProcAddress = (void*) &lib3mf_slice_addpolygon;
	if (sProcName == "lib3mf_slice_getpolygoncount") 
		*ppProcAddress = (void*) &lib3mf_slice_getpolygoncount;
	if (sProcName == "lib3mf_slice_setpolygonindices") 
		*ppProcAddress = (void*) &lib3mf_slice_setpolygonindices;
	if (sProcName == "lib3mf_slice_getpolygonindices") 
		*ppProcAddress = (void*) &lib3mf_slice_getpolygonindices;
	if (sProcName == "lib3mf_slice_getpolygonindexcount") 
		*ppProcAddress = (void*) &lib3mf_slice_getpolygonindexcount;
	if (sProcName == "lib3mf_slice_getztop") 
		*ppProcAddress = (void*) &lib3mf_slice_getztop;
	if (sProcName == "lib3mf_slicestack_getbottomz") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getbottomz;
	if (sProcName == "lib3mf_slicestack_getslicecount") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getslicecount;
	if (sProcName == "lib3mf_slicestack_getslice") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getslice;
	if (sProcName == "lib3mf_slicestack_addslice") 
		*ppProcAddress = (void*) &lib3mf_slicestack_addslice;
	if (sProcName == "lib3mf_slicestack_getslicerefcount") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getslicerefcount;
	if (sProcName == "lib3mf_slicestack_addslicestackreference") 
		*ppProcAddress = (void*) &lib3mf_slicestack_addslicestackreference;
	if (sProcName == "lib3mf_slicestack_getslicestackreference") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getslicestackreference;
	if (sProcName == "lib3mf_slicestack_collapseslicereferences") 
		*ppProcAddress = (void*) &lib3mf_slicestack_collapseslicereferences;
	if (sProcName == "lib3mf_slicestack_setownpath") 
		*ppProcAddress = (void*) &lib3mf_slicestack_setownpath;
	if (sProcName == "lib3mf_slicestack_getownpath") 
		*ppProcAddress = (void*) &lib3mf_slicestack_getownpath;
	if (sProcName == "lib3mf_consumer_getconsumerid") 
		*ppProcAddress = (void*) &lib3mf_consumer_getconsumerid;
	if (sProcName == "lib3mf_consumer_getkeyid") 
		*ppProcAddress = (void*) &lib3mf_consumer_getkeyid;
	if (sProcName == "lib3mf_consumer_getkeyvalue") 
		*ppProcAddress = (void*) &lib3mf_consumer_getkeyvalue;
	if (sProcName == "lib3mf_accessright_getconsumer") 
		*ppProcAddress = (void*) &lib3mf_accessright_getconsumer;
	if (sProcName == "lib3mf_accessright_getwrappingalgorithm") 
		*ppProcAddress = (void*) &lib3mf_accessright_getwrappingalgorithm;
	if (sProcName == "lib3mf_accessright_getmgfalgorithm") 
		*ppProcAddress = (void*) &lib3mf_accessright_getmgfalgorithm;
	if (sProcName == "lib3mf_accessright_getdigestmethod") 
		*ppProcAddress = (void*) &lib3mf_accessright_getdigestmethod;
	if (sProcName == "lib3mf_contentencryptionparams_getencryptionalgorithm") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getencryptionalgorithm;
	if (sProcName == "lib3mf_contentencryptionparams_getkey") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getkey;
	if (sProcName == "lib3mf_contentencryptionparams_getinitializationvector") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getinitializationvector;
	if (sProcName == "lib3mf_contentencryptionparams_getauthenticationtag") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getauthenticationtag;
	if (sProcName == "lib3mf_contentencryptionparams_setauthenticationtag") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_setauthenticationtag;
	if (sProcName == "lib3mf_contentencryptionparams_getadditionalauthenticationdata") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getadditionalauthenticationdata;
	if (sProcName == "lib3mf_contentencryptionparams_getdescriptor") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getdescriptor;
	if (sProcName == "lib3mf_contentencryptionparams_getkeyuuid") 
		*ppProcAddress = (void*) &lib3mf_contentencryptionparams_getkeyuuid;
	if (sProcName == "lib3mf_resourcedata_getpath") 
		*ppProcAddress = (void*) &lib3mf_resourcedata_getpath;
	if (sProcName == "lib3mf_resourcedata_getencryptionalgorithm") 
		*ppProcAddress = (void*) &lib3mf_resourcedata_getencryptionalgorithm;
	if (sProcName == "lib3mf_resourcedata_getcompression") 
		*ppProcAddress = (void*) &lib3mf_resourcedata_getcompression;
	if (sProcName == "lib3mf_resourcedata_getadditionalauthenticationdata") 
		*ppProcAddress = (void*) &lib3mf_resourcedata_getadditionalauthenticationdata;
	if (sProcName == "lib3mf_resourcedatagroup_getkeyuuid") 
		*ppProcAddress = (void*) &lib3mf_resourcedatagroup_getkeyuuid;
	if (sProcName == "lib3mf_resourcedatagroup_addaccessright") 
		*ppProcAddress = (void*) &lib3mf_resourcedatagroup_addaccessright;
	if (sProcName == "lib3mf_resourcedatagroup_findaccessrightbyconsumer") 
		*ppProcAddress = (void*) &lib3mf_resourcedatagroup_findaccessrightbyconsumer;
	if (sProcName == "lib3mf_resourcedatagroup_removeaccessright") 
		*ppProcAddress = (void*) &lib3mf_resourcedatagroup_removeaccessright;
	if (sProcName == "lib3mf_keystore_addconsumer") 
		*ppProcAddress = (void*) &lib3mf_keystore_addconsumer;
	if (sProcName == "lib3mf_keystore_getconsumercount") 
		*ppProcAddress = (void*) &lib3mf_keystore_getconsumercount;
	if (sProcName == "lib3mf_keystore_getconsumer") 
		*ppProcAddress = (void*) &lib3mf_keystore_getconsumer;
	if (sProcName == "lib3mf_keystore_removeconsumer") 
		*ppProcAddress = (void*) &lib3mf_keystore_removeconsumer;
	if (sProcName == "lib3mf_keystore_findconsumer") 
		*ppProcAddress = (void*) &lib3mf_keystore_findconsumer;
	if (sProcName == "lib3mf_keystore_getresourcedatagroupcount") 
		*ppProcAddress = (void*) &lib3mf_keystore_getresourcedatagroupcount;
	if (sProcName == "lib3mf_keystore_addresourcedatagroup") 
		*ppProcAddress = (void*) &lib3mf_keystore_addresourcedatagroup;
	if (sProcName == "lib3mf_keystore_getresourcedatagroup") 
		*ppProcAddress = (void*) &lib3mf_keystore_getresourcedatagroup;
	if (sProcName == "lib3mf_keystore_removeresourcedatagroup") 
		*ppProcAddress = (void*) &lib3mf_keystore_removeresourcedatagroup;
	if (sProcName == "lib3mf_keystore_findresourcedatagroup") 
		*ppProcAddress = (void*) &lib3mf_keystore_findresourcedatagroup;
	if (sProcName == "lib3mf_keystore_addresourcedata") 
		*ppProcAddress = (void*) &lib3mf_keystore_addresourcedata;
	if (sProcName == "lib3mf_keystore_removeresourcedata") 
		*ppProcAddress = (void*) &lib3mf_keystore_removeresourcedata;
	if (sProcName == "lib3mf_keystore_findresourcedata") 
		*ppProcAddress = (void*) &lib3mf_keystore_findresourcedata;
	if (sProcName == "lib3mf_keystore_getresourcedatacount") 
		*ppProcAddress = (void*) &lib3mf_keystore_getresourcedatacount;
	if (sProcName == "lib3mf_keystore_getresourcedata") 
		*ppProcAddress = (void*) &lib3mf_keystore_getresourcedata;
	if (sProcName == "lib3mf_keystore_getuuid") 
		*ppProcAddress = (void*) &lib3mf_keystore_getuuid;
	if (sProcName == "lib3mf_keystore_setuuid") 
		*ppProcAddress = (void*) &lib3mf_keystore_setuuid;
	if (sProcName == "lib3mf_model_rootmodelpart") 
		*ppProcAddress = (void*) &lib3mf_model_rootmodelpart;
	if (sProcName == "lib3mf_model_findorcreatepackagepart") 
		*ppProcAddress = (void*) &lib3mf_model_findorcreatepackagepart;
	if (sProcName == "lib3mf_model_setunit") 
		*ppProcAddress = (void*) &lib3mf_model_setunit;
	if (sProcName == "lib3mf_model_getunit") 
		*ppProcAddress = (void*) &lib3mf_model_getunit;
	if (sProcName == "lib3mf_model_getlanguage") 
		*ppProcAddress = (void*) &lib3mf_model_getlanguage;
	if (sProcName == "lib3mf_model_setlanguage") 
		*ppProcAddress = (void*) &lib3mf_model_setlanguage;
	if (sProcName == "lib3mf_model_querywriter") 
		*ppProcAddress = (void*) &lib3mf_model_querywriter;
	if (sProcName == "lib3mf_model_queryreader") 
		*ppProcAddress = (void*) &lib3mf_model_queryreader;
	if (sProcName == "lib3mf_model_getresourcebyid") 
		*ppProcAddress = (void*) &lib3mf_model_getresourcebyid;
	if (sProcName == "lib3mf_model_gettexture2dbyid") 
		*ppProcAddress = (void*) &lib3mf_model_gettexture2dbyid;
	if (sProcName == "lib3mf_model_getpropertytypebyid") 
		*ppProcAddress = (void*) &lib3mf_model_getpropertytypebyid;
	if (sProcName == "lib3mf_model_getbasematerialgroupbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getbasematerialgroupbyid;
	if (sProcName == "lib3mf_model_gettexture2dgroupbyid") 
		*ppProcAddress = (void*) &lib3mf_model_gettexture2dgroupbyid;
	if (sProcName == "lib3mf_model_getcompositematerialsbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getcompositematerialsbyid;
	if (sProcName == "lib3mf_model_getmultipropertygroupbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getmultipropertygroupbyid;
	if (sProcName == "lib3mf_model_getmeshobjectbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getmeshobjectbyid;
	if (sProcName == "lib3mf_model_getcomponentsobjectbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getcomponentsobjectbyid;
	if (sProcName == "lib3mf_model_getcolorgroupbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getcolorgroupbyid;
	if (sProcName == "lib3mf_model_getslicestackbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getslicestackbyid;
	if (sProcName == "lib3mf_model_getbuilduuid") 
		*ppProcAddress = (void*) &lib3mf_model_getbuilduuid;
	if (sProcName == "lib3mf_model_setbuilduuid") 
		*ppProcAddress = (void*) &lib3mf_model_setbuilduuid;
	if (sProcName == "lib3mf_model_getbuilditems") 
		*ppProcAddress = (void*) &lib3mf_model_getbuilditems;
	if (sProcName == "lib3mf_model_getoutbox") 
		*ppProcAddress = (void*) &lib3mf_model_getoutbox;
	if (sProcName == "lib3mf_model_getresources") 
		*ppProcAddress = (void*) &lib3mf_model_getresources;
	if (sProcName == "lib3mf_model_getobjects") 
		*ppProcAddress = (void*) &lib3mf_model_getobjects;
	if (sProcName == "lib3mf_model_getmeshobjects") 
		*ppProcAddress = (void*) &lib3mf_model_getmeshobjects;
	if (sProcName == "lib3mf_model_getcomponentsobjects") 
		*ppProcAddress = (void*) &lib3mf_model_getcomponentsobjects;
	if (sProcName == "lib3mf_model_gettexture2ds") 
		*ppProcAddress = (void*) &lib3mf_model_gettexture2ds;
	if (sProcName == "lib3mf_model_getbasematerialgroups") 
		*ppProcAddress = (void*) &lib3mf_model_getbasematerialgroups;
	if (sProcName == "lib3mf_model_getcolorgroups") 
		*ppProcAddress = (void*) &lib3mf_model_getcolorgroups;
	if (sProcName == "lib3mf_model_gettexture2dgroups") 
		*ppProcAddress = (void*) &lib3mf_model_gettexture2dgroups;
	if (sProcName == "lib3mf_model_getcompositematerials") 
		*ppProcAddress = (void*) &lib3mf_model_getcompositematerials;
	if (sProcName == "lib3mf_model_getmultipropertygroups") 
		*ppProcAddress = (void*) &lib3mf_model_getmultipropertygroups;
	if (sProcName == "lib3mf_model_getslicestacks") 
		*ppProcAddress = (void*) &lib3mf_model_getslicestacks;
	if (sProcName == "lib3mf_model_getimage3ds") 
		*ppProcAddress = (void*) &lib3mf_model_getimage3ds;
	if (sProcName == "lib3mf_model_getscalarfields") 
		*ppProcAddress = (void*) &lib3mf_model_getscalarfields;
	if (sProcName == "lib3mf_model_getvector3dfields") 
		*ppProcAddress = (void*) &lib3mf_model_getvector3dfields;
	if (sProcName == "lib3mf_model_mergetomodel") 
		*ppProcAddress = (void*) &lib3mf_model_mergetomodel;
	if (sProcName == "lib3mf_model_addmeshobject") 
		*ppProcAddress = (void*) &lib3mf_model_addmeshobject;
	if (sProcName == "lib3mf_model_addcomponentsobject") 
		*ppProcAddress = (void*) &lib3mf_model_addcomponentsobject;
	if (sProcName == "lib3mf_model_addslicestack") 
		*ppProcAddress = (void*) &lib3mf_model_addslicestack;
	if (sProcName == "lib3mf_model_addtexture2dfromattachment") 
		*ppProcAddress = (void*) &lib3mf_model_addtexture2dfromattachment;
	if (sProcName == "lib3mf_model_addbasematerialgroup") 
		*ppProcAddress = (void*) &lib3mf_model_addbasematerialgroup;
	if (sProcName == "lib3mf_model_addcolorgroup") 
		*ppProcAddress = (void*) &lib3mf_model_addcolorgroup;
	if (sProcName == "lib3mf_model_addtexture2dgroup") 
		*ppProcAddress = (void*) &lib3mf_model_addtexture2dgroup;
	if (sProcName == "lib3mf_model_addcompositematerials") 
		*ppProcAddress = (void*) &lib3mf_model_addcompositematerials;
	if (sProcName == "lib3mf_model_addmultipropertygroup") 
		*ppProcAddress = (void*) &lib3mf_model_addmultipropertygroup;
	if (sProcName == "lib3mf_model_addimagestack") 
		*ppProcAddress = (void*) &lib3mf_model_addimagestack;
	if (sProcName == "lib3mf_model_getimagestackbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getimagestackbyid;
	if (sProcName == "lib3mf_model_addscalarfieldfromimage3d") 
		*ppProcAddress = (void*) &lib3mf_model_addscalarfieldfromimage3d;
	if (sProcName == "lib3mf_model_addscalarfieldcomposed") 
		*ppProcAddress = (void*) &lib3mf_model_addscalarfieldcomposed;
	if (sProcName == "lib3mf_model_addscalarfieldconstant") 
		*ppProcAddress = (void*) &lib3mf_model_addscalarfieldconstant;
	if (sProcName == "lib3mf_model_getscalarfieldbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getscalarfieldbyid;
	if (sProcName == "lib3mf_model_getscalarfieldfromimage3dbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getscalarfieldfromimage3dbyid;
	if (sProcName == "lib3mf_model_getscalarfieldcomposedbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getscalarfieldcomposedbyid;
	if (sProcName == "lib3mf_model_getscalarfieldconstantbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getscalarfieldconstantbyid;
	if (sProcName == "lib3mf_model_addvector3dfieldfromimage3d") 
		*ppProcAddress = (void*) &lib3mf_model_addvector3dfieldfromimage3d;
	if (sProcName == "lib3mf_model_addvector3dfieldcomposed") 
		*ppProcAddress = (void*) &lib3mf_model_addvector3dfieldcomposed;
	if (sProcName == "lib3mf_model_addvector3dfieldconstant") 
		*ppProcAddress = (void*) &lib3mf_model_addvector3dfieldconstant;
	if (sProcName == "lib3mf_model_getvector3dfieldbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getvector3dfieldbyid;
	if (sProcName == "lib3mf_model_getvector3dfieldfromimage3dbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getvector3dfieldfromimage3dbyid;
	if (sProcName == "lib3mf_model_getvector3dfieldcomposedbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getvector3dfieldcomposedbyid;
	if (sProcName == "lib3mf_model_getvector3dfieldconstantbyid") 
		*ppProcAddress = (void*) &lib3mf_model_getvector3dfieldconstantbyid;
	if (sProcName == "lib3mf_model_addbuilditem") 
		*ppProcAddress = (void*) &lib3mf_model_addbuilditem;
	if (sProcName == "lib3mf_model_removebuilditem") 
		*ppProcAddress = (void*) &lib3mf_model_removebuilditem;
	if (sProcName == "lib3mf_model_getmetadatagroup") 
		*ppProcAddress = (void*) &lib3mf_model_getmetadatagroup;
	if (sProcName == "lib3mf_model_addattachment") 
		*ppProcAddress = (void*) &lib3mf_model_addattachment;
	if (sProcName == "lib3mf_model_removeattachment") 
		*ppProcAddress = (void*) &lib3mf_model_removeattachment;
	if (sProcName == "lib3mf_model_getattachment") 
		*ppProcAddress = (void*) &lib3mf_model_getattachment;
	if (sProcName == "lib3mf_model_findattachment") 
		*ppProcAddress = (void*) &lib3mf_model_findattachment;
	if (sProcName == "lib3mf_model_getattachmentcount") 
		*ppProcAddress = (void*) &lib3mf_model_getattachmentcount;
	if (sProcName == "lib3mf_model_haspackagethumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_model_haspackagethumbnailattachment;
	if (sProcName == "lib3mf_model_createpackagethumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_model_createpackagethumbnailattachment;
	if (sProcName == "lib3mf_model_getpackagethumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_model_getpackagethumbnailattachment;
	if (sProcName == "lib3mf_model_removepackagethumbnailattachment") 
		*ppProcAddress = (void*) &lib3mf_model_removepackagethumbnailattachment;
	if (sProcName == "lib3mf_model_addcustomcontenttype") 
		*ppProcAddress = (void*) &lib3mf_model_addcustomcontenttype;
	if (sProcName == "lib3mf_model_removecustomcontenttype") 
		*ppProcAddress = (void*) &lib3mf_model_removecustomcontenttype;
	if (sProcName == "lib3mf_model_setrandomnumbercallback") 
		*ppProcAddress = (void*) &lib3mf_model_setrandomnumbercallback;
	if (sProcName == "lib3mf_model_getkeystore") 
		*ppProcAddress = (void*) &lib3mf_model_getkeystore;
	if (sProcName == "lib3mf_model_getfunctions") 
		*ppProcAddress = (void*) &lib3mf_model_getfunctions;
	if (sProcName == "lib3mf_model_addfunction") 
		*ppProcAddress = (void*) &lib3mf_model_addfunction;
	if (sProcName == "lib3mf_getlibraryversion") 
		*ppProcAddress = (void*) &lib3mf_getlibraryversion;
	if (sProcName == "lib3mf_getprereleaseinformation") 
		*ppProcAddress = (void*) &lib3mf_getprereleaseinformation;
	if (sProcName == "lib3mf_getbuildinformation") 
		*ppProcAddress = (void*) &lib3mf_getbuildinformation;
	if (sProcName == "lib3mf_getspecificationversion") 
		*ppProcAddress = (void*) &lib3mf_getspecificationversion;
	if (sProcName == "lib3mf_createmodel") 
		*ppProcAddress = (void*) &lib3mf_createmodel;
	if (sProcName == "lib3mf_release") 
		*ppProcAddress = (void*) &lib3mf_release;
	if (sProcName == "lib3mf_acquire") 
		*ppProcAddress = (void*) &lib3mf_acquire;
	if (sProcName == "lib3mf_setjournal") 
		*ppProcAddress = (void*) &lib3mf_setjournal;
	if (sProcName == "lib3mf_getlasterror") 
		*ppProcAddress = (void*) &lib3mf_getlasterror;
	if (sProcName == "lib3mf_getsymbollookupmethod") 
		*ppProcAddress = (void*) &lib3mf_getsymbollookupmethod;
	if (sProcName == "lib3mf_retrieveprogressmessage") 
		*ppProcAddress = (void*) &lib3mf_retrieveprogressmessage;
	if (sProcName == "lib3mf_rgbatocolor") 
		*ppProcAddress = (void*) &lib3mf_rgbatocolor;
	if (sProcName == "lib3mf_floatrgbatocolor") 
		*ppProcAddress = (void*) &lib3mf_floatrgbatocolor;
	if (sProcName == "lib3mf_colortorgba") 
		*ppProcAddress = (void*) &lib3mf_colortorgba;
	if (sProcName == "lib3mf_colortofloatrgba") 
		*ppProcAddress = (void*) &lib3mf_colortofloatrgba;
	if (sProcName == "lib3mf_getidentitytransform") 
		*ppProcAddress = (void*) &lib3mf_getidentitytransform;
	if (sProcName == "lib3mf_getuniformscaletransform") 
		*ppProcAddress = (void*) &lib3mf_getuniformscaletransform;
	if (sProcName == "lib3mf_getscaletransform") 
		*ppProcAddress = (void*) &lib3mf_getscaletransform;
	if (sProcName == "lib3mf_gettranslationtransform") 
		*ppProcAddress = (void*) &lib3mf_gettranslationtransform;
	
	if (*ppProcAddress == nullptr) 
		return LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIB3MF_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
Lib3MFResult lib3mf_getlibraryversion(Lib3MF_uint32 * pMajor, Lib3MF_uint32 * pMinor, Lib3MF_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetLibraryVersion");
		}
		if (!pMajor)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		CWrapper::GetLibraryVersion(*pMajor, *pMinor, *pMicro);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Major", *pMajor);
			pJournalEntry->addUInt32Result("Minor", *pMinor);
			pJournalEntry->addUInt32Result("Micro", *pMicro);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getprereleaseinformation(bool * pHasPrereleaseInfo, const Lib3MF_uint32 nPrereleaseInfoBufferSize, Lib3MF_uint32* pPrereleaseInfoNeededChars, char * pPrereleaseInfoBuffer)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetPrereleaseInformation");
		}
		if (pHasPrereleaseInfo == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pPrereleaseInfoBuffer) && !(pPrereleaseInfoNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sPrereleaseInfo("");
		*pHasPrereleaseInfo = CWrapper::GetPrereleaseInformation(sPrereleaseInfo);

		if (pPrereleaseInfoNeededChars)
			*pPrereleaseInfoNeededChars = (Lib3MF_uint32) (sPrereleaseInfo.size()+1);
		if (pPrereleaseInfoBuffer) {
			if (sPrereleaseInfo.size() >= nPrereleaseInfoBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iPrereleaseInfo = 0; iPrereleaseInfo < sPrereleaseInfo.size(); iPrereleaseInfo++)
				pPrereleaseInfoBuffer[iPrereleaseInfo] = sPrereleaseInfo[iPrereleaseInfo];
			pPrereleaseInfoBuffer[sPrereleaseInfo.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasPrereleaseInfo", *pHasPrereleaseInfo);
			pJournalEntry->addStringResult("PrereleaseInfo", sPrereleaseInfo.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getbuildinformation(bool * pHasBuildInfo, const Lib3MF_uint32 nBuildInformationBufferSize, Lib3MF_uint32* pBuildInformationNeededChars, char * pBuildInformationBuffer)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetBuildInformation");
		}
		if (pHasBuildInfo == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if ( (!pBuildInformationBuffer) && !(pBuildInformationNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sBuildInformation("");
		*pHasBuildInfo = CWrapper::GetBuildInformation(sBuildInformation);

		if (pBuildInformationNeededChars)
			*pBuildInformationNeededChars = (Lib3MF_uint32) (sBuildInformation.size()+1);
		if (pBuildInformationBuffer) {
			if (sBuildInformation.size() >= nBuildInformationBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iBuildInformation = 0; iBuildInformation < sBuildInformation.size(); iBuildInformation++)
				pBuildInformationBuffer[iBuildInformation] = sBuildInformation[iBuildInformation];
			pBuildInformationBuffer[sBuildInformation.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("HasBuildInfo", *pHasBuildInfo);
			pJournalEntry->addStringResult("BuildInformation", sBuildInformation.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getspecificationversion(const char * pSpecificationURL, bool * pIsSupported, Lib3MF_uint32 * pMajor, Lib3MF_uint32 * pMinor, Lib3MF_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetSpecificationVersion");
			pJournalEntry->addStringParameter("SpecificationURL", pSpecificationURL);
		}
		if (pSpecificationURL == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pIsSupported)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pMajor)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sSpecificationURL(pSpecificationURL);
		CWrapper::GetSpecificationVersion(sSpecificationURL, *pIsSupported, *pMajor, *pMinor, *pMicro);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("IsSupported", *pIsSupported);
			pJournalEntry->addUInt32Result("Major", *pMajor);
			pJournalEntry->addUInt32Result("Minor", *pMinor);
			pJournalEntry->addUInt32Result("Micro", *pMicro);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_createmodel(Lib3MF_Model * pModel)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("CreateModel");
		}
		if (pModel == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pBaseModel(nullptr);
		pBaseModel = CWrapper::CreateModel();

		*pModel = (IBase*)(pBaseModel);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("Model", *pModel);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_release(Lib3MF_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("Release");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		CWrapper::Release(pIInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_acquire(Lib3MF_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("Acquire");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		CWrapper::Acquire(pIInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_setjournal(const char * pJournalPath)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pJournalPath == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sJournalPath(pJournalPath);
		m_GlobalJournal = nullptr;
		if (sJournalPath != "") {
			m_GlobalJournal = std::make_shared<CLib3MFInterfaceJournal> (sJournalPath);
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

Lib3MFResult lib3mf_getlasterror(Lib3MF_Base pInstance, const Lib3MF_uint32 nLastErrorStringBufferSize, Lib3MF_uint32* pLastErrorStringNeededChars, char * pLastErrorStringBuffer, bool * pHasLastError)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetLastError");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		if ( (!pLastErrorStringBuffer) && !(pLastErrorStringNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (pHasLastError == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDCAST);
		
		std::string sLastErrorString("");
		*pHasLastError = CWrapper::GetLastError(pIInstance, sLastErrorString);

		if (pLastErrorStringNeededChars)
			*pLastErrorStringNeededChars = (Lib3MF_uint32) (sLastErrorString.size()+1);
		if (pLastErrorStringBuffer) {
			if (sLastErrorString.size() >= nLastErrorStringBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iLastErrorString = 0; iLastErrorString < sLastErrorString.size(); iLastErrorString++)
				pLastErrorStringBuffer[iLastErrorString] = sLastErrorString[iLastErrorString];
			pLastErrorStringBuffer[sLastErrorString.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("LastErrorString", sLastErrorString.c_str());
			pJournalEntry->addBooleanResult("HasLastError", *pHasLastError);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getsymbollookupmethod(Lib3MF_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetSymbolLookupMethod");
		}
		if (pSymbolLookupMethod == nullptr)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&Lib3MF::Impl::Lib3MF_GetProcAddress;
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addPointerResult("SymbolLookupMethod", *pSymbolLookupMethod);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_retrieveprogressmessage(eLib3MFProgressIdentifier eTheProgressIdentifier, const Lib3MF_uint32 nProgressMessageBufferSize, Lib3MF_uint32* pProgressMessageNeededChars, char * pProgressMessageBuffer)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("RetrieveProgressMessage");
			pJournalEntry->addEnumParameter("TheProgressIdentifier", "ProgressIdentifier", (Lib3MF_int32)(eTheProgressIdentifier));
		}
		if ( (!pProgressMessageBuffer) && !(pProgressMessageNeededChars) )
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		std::string sProgressMessage("");
		CWrapper::RetrieveProgressMessage(eTheProgressIdentifier, sProgressMessage);

		if (pProgressMessageNeededChars)
			*pProgressMessageNeededChars = (Lib3MF_uint32) (sProgressMessage.size()+1);
		if (pProgressMessageBuffer) {
			if (sProgressMessage.size() >= nProgressMessageBufferSize)
				throw ELib3MFInterfaceException (LIB3MF_ERROR_BUFFERTOOSMALL);
			for (size_t iProgressMessage = 0; iProgressMessage < sProgressMessage.size(); iProgressMessage++)
				pProgressMessageBuffer[iProgressMessage] = sProgressMessage[iProgressMessage];
			pProgressMessageBuffer[sProgressMessage.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("ProgressMessage", sProgressMessage.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_rgbatocolor(Lib3MF_uint8 nRed, Lib3MF_uint8 nGreen, Lib3MF_uint8 nBlue, Lib3MF_uint8 nAlpha, sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("RGBAToColor");
			pJournalEntry->addUInt8Parameter("Red", nRed);
			pJournalEntry->addUInt8Parameter("Green", nGreen);
			pJournalEntry->addUInt8Parameter("Blue", nBlue);
			pJournalEntry->addUInt8Parameter("Alpha", nAlpha);
		}
		if (pTheColor == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTheColor = CWrapper::RGBAToColor(nRed, nGreen, nBlue, nAlpha);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_floatrgbatocolor(Lib3MF_single fRed, Lib3MF_single fGreen, Lib3MF_single fBlue, Lib3MF_single fAlpha, sLib3MFColor * pTheColor)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("FloatRGBAToColor");
			pJournalEntry->addSingleParameter("Red", fRed);
			pJournalEntry->addSingleParameter("Green", fGreen);
			pJournalEntry->addSingleParameter("Blue", fBlue);
			pJournalEntry->addSingleParameter("Alpha", fAlpha);
		}
		if (pTheColor == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTheColor = CWrapper::FloatRGBAToColor(fRed, fGreen, fBlue, fAlpha);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colortorgba(const sLib3MFColor * pTheColor, Lib3MF_uint8 * pRed, Lib3MF_uint8 * pGreen, Lib3MF_uint8 * pBlue, Lib3MF_uint8 * pAlpha)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("ColorToRGBA");
		}
		if (!pRed)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pGreen)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pBlue)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pAlpha)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		CWrapper::ColorToRGBA(*pTheColor, *pRed, *pGreen, *pBlue, *pAlpha);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt8Result("Red", *pRed);
			pJournalEntry->addUInt8Result("Green", *pGreen);
			pJournalEntry->addUInt8Result("Blue", *pBlue);
			pJournalEntry->addUInt8Result("Alpha", *pAlpha);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_colortofloatrgba(const sLib3MFColor * pTheColor, Lib3MF_single * pRed, Lib3MF_single * pGreen, Lib3MF_single * pBlue, Lib3MF_single * pAlpha)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("ColorToFloatRGBA");
		}
		if (!pRed)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pGreen)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pBlue)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		if (!pAlpha)
			throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		CWrapper::ColorToFloatRGBA(*pTheColor, *pRed, *pGreen, *pBlue, *pAlpha);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addSingleResult("Red", *pRed);
			pJournalEntry->addSingleResult("Green", *pGreen);
			pJournalEntry->addSingleResult("Blue", *pBlue);
			pJournalEntry->addSingleResult("Alpha", *pAlpha);
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getidentitytransform(sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetIdentityTransform");
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTransform = CWrapper::GetIdentityTransform();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getuniformscaletransform(Lib3MF_single fFactor, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetUniformScaleTransform");
			pJournalEntry->addSingleParameter("Factor", fFactor);
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTransform = CWrapper::GetUniformScaleTransform(fFactor);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_getscaletransform(Lib3MF_single fFactorX, Lib3MF_single fFactorY, Lib3MF_single fFactorZ, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetScaleTransform");
			pJournalEntry->addSingleParameter("FactorX", fFactorX);
			pJournalEntry->addSingleParameter("FactorY", fFactorY);
			pJournalEntry->addSingleParameter("FactorZ", fFactorZ);
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTransform = CWrapper::GetScaleTransform(fFactorX, fFactorY, fFactorZ);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

Lib3MFResult lib3mf_gettranslationtransform(Lib3MF_single fVectorX, Lib3MF_single fVectorY, Lib3MF_single fVectorZ, sLib3MFTransform * pTransform)
{
	IBase* pIBaseClass = nullptr;

	PLib3MFInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetTranslationTransform");
			pJournalEntry->addSingleParameter("VectorX", fVectorX);
			pJournalEntry->addSingleParameter("VectorY", fVectorY);
			pJournalEntry->addSingleParameter("VectorZ", fVectorZ);
		}
		if (pTransform == nullptr)
		throw ELib3MFInterfaceException (LIB3MF_ERROR_INVALIDPARAM);
		*pTransform = CWrapper::GetTranslationTransform(fVectorX, fVectorY, fVectorZ);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIB3MF_SUCCESS;
	}
	catch (ELib3MFInterfaceException & Exception) {
		return handleLib3MFException(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


